{"config":{"output_file":null,"full_docs":false,"pub_only":false,"reachable_only":false,"distro_crate":false,"signatures":false,"borrow_data":false},"version":"0.19.1","compilation":{"directory":"/Users/zhangalex/Work/Consultation/GeekTime/inviting-rust","program":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/bin/rls","arguments":[],"output":"/Users/zhangalex/Work/Consultation/GeekTime/inviting-rust/target/rls/debug/deps/libinviting_rust-8900b4ba208d2c8f.rmeta"},"prelude":{"crate_id":{"name":"inviting_rust","disambiguator":[12361996849156886837,15747726852956746209]},"crate_root":"src","external_crates":[{"file_name":"/Users/zhangalex/Work/Consultation/GeekTime/inviting-rust/src/lib.rs","num":1,"id":{"name":"std","disambiguator":[15271846124424689693,12828167138405415005]}},{"file_name":"/Users/zhangalex/Work/Consultation/GeekTime/inviting-rust/src/lib.rs","num":2,"id":{"name":"core","disambiguator":[3522436643036113830,3458472283245946581]}},{"file_name":"/Users/zhangalex/Work/Consultation/GeekTime/inviting-rust/src/lib.rs","num":3,"id":{"name":"compiler_builtins","disambiguator":[18443775081675161881,8871531110487799323]}},{"file_name":"/Users/zhangalex/Work/Consultation/GeekTime/inviting-rust/src/lib.rs","num":4,"id":{"name":"rustc_std_workspace_core","disambiguator":[14133466982911310258,776543773745642680]}},{"file_name":"/Users/zhangalex/Work/Consultation/GeekTime/inviting-rust/src/lib.rs","num":5,"id":{"name":"alloc","disambiguator":[1810916959507492673,6992362399719939798]}},{"file_name":"/Users/zhangalex/Work/Consultation/GeekTime/inviting-rust/src/lib.rs","num":6,"id":{"name":"libc","disambiguator":[14542582121781483850,6595427450071768280]}},{"file_name":"/Users/zhangalex/Work/Consultation/GeekTime/inviting-rust/src/lib.rs","num":7,"id":{"name":"unwind","disambiguator":[13128264859918991565,1389008832397617215]}},{"file_name":"/Users/zhangalex/Work/Consultation/GeekTime/inviting-rust/src/lib.rs","num":8,"id":{"name":"cfg_if","disambiguator":[13519202797247513544,2344338743936253762]}},{"file_name":"/Users/zhangalex/Work/Consultation/GeekTime/inviting-rust/src/lib.rs","num":9,"id":{"name":"hashbrown","disambiguator":[15198817458514557480,12619727005655851827]}},{"file_name":"/Users/zhangalex/Work/Consultation/GeekTime/inviting-rust/src/lib.rs","num":10,"id":{"name":"rustc_std_workspace_alloc","disambiguator":[7792981388631258554,13574744570605464789]}},{"file_name":"/Users/zhangalex/Work/Consultation/GeekTime/inviting-rust/src/lib.rs","num":11,"id":{"name":"rustc_demangle","disambiguator":[18366362480168335528,6204773997848079802]}},{"file_name":"/Users/zhangalex/Work/Consultation/GeekTime/inviting-rust/src/lib.rs","num":12,"id":{"name":"addr2line","disambiguator":[10062380695705566486,8667061503757010039]}},{"file_name":"/Users/zhangalex/Work/Consultation/GeekTime/inviting-rust/src/lib.rs","num":13,"id":{"name":"gimli","disambiguator":[7067261615280639564,60947903771806555]}},{"file_name":"/Users/zhangalex/Work/Consultation/GeekTime/inviting-rust/src/lib.rs","num":14,"id":{"name":"object","disambiguator":[15231746228855223727,7991947149439765402]}},{"file_name":"/Users/zhangalex/Work/Consultation/GeekTime/inviting-rust/src/lib.rs","num":15,"id":{"name":"panic_unwind","disambiguator":[6287783694532592178,16708986191446005949]}}],"span":{"file_name":"src/lib.rs","byte_start":1,"byte_end":235,"line_start":2,"line_end":10,"column_start":1,"column_end":14}},"imports":[],"defs":[{"kind":"Mod","id":{"krate":0,"index":0},"span":{"file_name":"src/lib.rs","byte_start":1,"byte_end":235,"line_start":2,"line_end":10,"column_start":1,"column_end":14},"name":"","qualname":"::","value":"src/lib.rs","parent":null,"children":[{"krate":0,"index":1},{"krate":0,"index":2},{"krate":0,"index":3},{"krate":0,"index":33},{"krate":0,"index":80}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":3},"span":{"file_name":"src/ch01/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"ch01","qualname":"::ch01","value":"src/ch01/mod.rs","parent":null,"children":[{"krate":0,"index":4},{"krate":0,"index":15},{"krate":0,"index":20},{"krate":0,"index":32}],"decl_id":null,"docs":" ç¬¬ä¸€ç« ï¼šRustè¯­è¨€åŸºç¡€","sig":null,"attributes":[{"value":"/ ç¬¬ä¸€ç« ï¼šRustè¯­è¨€åŸºç¡€","span":{"file_name":"src/ch01/mod.rs","byte_start":237,"byte_end":269,"line_start":2,"line_end":2,"column_start":1,"column_end":17}},{"value":"/","span":{"file_name":"src/ch01/mod.rs","byte_start":270,"byte_end":273,"line_start":3,"line_end":3,"column_start":1,"column_end":4}}]},{"kind":"Mod","id":{"krate":0,"index":4},"span":{"file_name":"src/ch01/lexical.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"lexical","qualname":"::ch01::lexical","value":"src/ch01/lexical.rs","parent":null,"children":[{"krate":0,"index":5},{"krate":0,"index":6},{"krate":0,"index":8},{"krate":0,"index":9}],"decl_id":null,"docs":" ç¬¬ä¸€ç« ï¼šRustè¯­è¨€åŸºç¡€\n 1.3 è¯­æ³•é¢é¢è§‚ï¼ˆä¸€ï¼‰ è¯æ³•ç»“æ„\n \n åŒ…æ‹¬ï¼š\n    1. Rust è¯­è¨€ç‰ˆæœ¬è¯´æ˜\n    2. Rust è¯æ³•ç»“æ„\n","sig":null,"attributes":[{"value":"allow(unused_variables)","span":{"file_name":"src/ch01/lexical.rs","byte_start":505,"byte_end":532,"line_start":1,"line_end":1,"column_start":1,"column_end":28}},{"value":"/ ç¬¬ä¸€ç« ï¼šRustè¯­è¨€åŸºç¡€","span":{"file_name":"src/ch01/lexical.rs","byte_start":533,"byte_end":565,"line_start":2,"line_end":2,"column_start":1,"column_end":17}},{"value":"/ 1.3 è¯­æ³•é¢é¢è§‚ï¼ˆä¸€ï¼‰ è¯æ³•ç»“æ„","span":{"file_name":"src/ch01/lexical.rs","byte_start":566,"byte_end":611,"line_start":3,"line_end":3,"column_start":1,"column_end":22}},{"value":"/ ","span":{"file_name":"src/ch01/lexical.rs","byte_start":612,"byte_end":616,"line_start":4,"line_end":4,"column_start":1,"column_end":5}},{"value":"/ åŒ…æ‹¬ï¼š","span":{"file_name":"src/ch01/lexical.rs","byte_start":617,"byte_end":630,"line_start":5,"line_end":5,"column_start":1,"column_end":8}},{"value":"/    1. Rust è¯­è¨€ç‰ˆæœ¬è¯´æ˜","span":{"file_name":"src/ch01/lexical.rs","byte_start":631,"byte_end":664,"line_start":6,"line_end":6,"column_start":1,"column_end":22}},{"value":"/    2. Rust è¯æ³•ç»“æ„","span":{"file_name":"src/ch01/lexical.rs","byte_start":665,"byte_end":692,"line_start":7,"line_end":7,"column_start":1,"column_end":20}}]},{"kind":"Function","id":{"krate":0,"index":5},"span":{"file_name":"src/ch01/lexical.rs","byte_start":1152,"byte_end":1162,"line_start":30,"line_end":30,"column_start":8,"column_end":18},"name":"ident_show","qualname":"::ch01::lexical::ident_show","value":"pub fn ident_show()","parent":null,"children":[],"decl_id":null,"docs":"    # æ ‡è¯†ç¬¦:","sig":null,"attributes":[{"value":"*\n\n    # æ ‡è¯†ç¬¦:\n\n   ```rust\n   let thinking = \"thinking\";\n   let thinking123_ = \"thinking 123\";\n   \n   // error: invalid suffix `thinking` for integer literal\n   // let 321_thinking = \"thinking\";\n   \n   // ok\n   let _321_thinking = \"thinking\";\n\n   // non-ascii ident\n   // RFC: https://github.com/rust-lang/rfcs/blob/master/text/2457-non-ascii-idents.md\n   // error: unknown start of token: \\u{1f914} \n   //  let ğŸ¤” = \"thinking \"; \n   ```\n\n*/","span":{"file_name":"src/ch01/lexical.rs","byte_start":694,"byte_end":1144,"line_start":9,"line_end":29,"column_start":1,"column_end":3}}]},{"kind":"Local","id":{"krate":0,"index":3221225477},"span":{"file_name":"src/ch01/lexical.rs","byte_start":1174,"byte_end":1182,"line_start":31,"line_end":31,"column_start":9,"column_end":17},"name":"thinking","qualname":"thinking$HirId { owner: DefId(0:5 ~ inviting_rust[ab8e]::ch01::lexical::ident_show), local_id: 3 }","value":"&str","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6},"span":{"file_name":"src/ch01/lexical.rs","byte_start":1871,"byte_end":1881,"line_start":64,"line_end":64,"column_start":8,"column_end":18},"name":"macro_show","qualname":"::ch01::lexical::macro_show","value":"pub fn macro_show()","parent":null,"children":[],"decl_id":null,"docs":"    # å£°æ˜å®ç¤ºä¾‹","sig":null,"attributes":[{"value":"*\n\n    # å£°æ˜å®ç¤ºä¾‹\n\n    ```rust\n    macro_rules! calculate {\n        (eval $e:expr) => {{\n            {\n                let val: usize = $e; // Force types to be integers\n                println!(\"{} = {}\", stringify!{$e}, val);\n            }\n        }};\n    }\n\n    fn main() {\n        calculate! {\n            eval 1 + 2 // hehehe `eval` is _not_ a Rust keyword!\n        }\n\n        calculate! {\n            eval (1 + 2) * (3 / 4)\n        }\n    }\n    ```\n*/","span":{"file_name":"src/ch01/lexical.rs","byte_start":1398,"byte_end":1863,"line_start":39,"line_end":63,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":8},"span":{"file_name":"src/ch01/lexical.rs","byte_start":3160,"byte_end":3169,"line_start":130,"line_end":130,"column_start":8,"column_end":17},"name":"path_show","qualname":"::ch01::lexical::path_show","value":"pub fn path_show()","parent":null,"children":[],"decl_id":null,"docs":"    # Path å±•ç¤º","sig":null,"attributes":[{"value":"*\n\n    # Path å±•ç¤º\n\n    ```\n    // æ¨¡å—è·¯å¾„\n    mod a {\n        fn foo() {}\n\n        mod b {\n            mod c {\n                fn foo() {\n                    super::super::foo(); // call a's foo function\n                    self::super::super::foo(); // call a's foo function\n                }\n            }\n        }\n    }\n    \n    // æ–¹æ³•è°ƒç”¨\n    \n    struct S;\n    impl S {\n        fn f() { println!(\"S\"); }\n    }\n    trait T1 {\n        fn f() { println!(\"T1 f\"); }\n    }\n    impl T1 for S {}\n    trait T2 {\n        fn f() { println!(\"T2 f\"); }\n    }\n    impl T2 for S {}\n    S::f();  // Calls the inherent impl.\n    // å®Œå…¨é™å®šæ— æ­§ä¹‰è°ƒç”¨\n    <S as T1>::f();  // Calls the T1 trait function.\n    <S as T2>::f();  // Calls the T2 trait function.\n\n\n    // æ³›å‹å‡½æ•°-turbofishæ“ä½œç¬¦\n    (0..10).collect::<Vec<_>>();\n    Vec::<u8>::with_capacity(1024);\n    ```\n\n*/","span":{"file_name":"src/ch01/lexical.rs","byte_start":2260,"byte_end":3152,"line_start":85,"line_end":129,"column_start":1,"column_end":3}}]},{"kind":"Mod","id":{"krate":0,"index":9},"span":{"file_name":"src/ch01/lexical.rs","byte_start":4996,"byte_end":5008,"line_start":200,"line_end":200,"column_start":9,"column_end":21},"name":"outer_module","qualname":"::ch01::lexical::outer_module","value":"src/ch01/lexical.rs","parent":null,"children":[{"krate":0,"index":10},{"krate":0,"index":11},{"krate":0,"index":13}],"decl_id":null,"docs":"    # æ³¨é‡Šç¤ºä¾‹\n    pub mod outer_module {\n \n        //!  - æ¨¡å—çº§æ–‡æ¡£æ³¨é‡Šï¼Œç½®äºæ¨¡å—å¤´éƒ¨\n        //!! - æ¨¡å—çº§æ–‡æ¡£æ³¨é‡Šï¼Œä½†æ˜¯å’Œä¸Šé¢æ³¨é‡Šç½®äºåŒä¸€è¡Œ","sig":null,"attributes":[{"value":"*  \n    # æ³¨é‡Šç¤ºä¾‹\n    pub mod outer_module {\n \n        //!  - æ¨¡å—çº§æ–‡æ¡£æ³¨é‡Šï¼Œç½®äºæ¨¡å—å¤´éƒ¨\n        //!! - æ¨¡å—çº§æ–‡æ¡£æ³¨é‡Šï¼Œä½†æ˜¯å’Œä¸Šé¢æ³¨é‡Šç½®äºåŒä¸€è¡Œ\n\n        //!  - æ¨¡å—çº§æ–‡æ¡£æ³¨é‡Šï¼Œä½†ä¼šæ¢è¡Œ\n \n        /*!  - æ¨¡å—å—çº§æ–‡æ¡£æ³¨é‡Š */\n        /*!! - æ¨¡å—çº§æ³¨é‡Šï¼Œä½†æ˜¯å’Œä¸Šé¢æ³¨é‡Šç½®äºåŒä¸€è¡Œ */\n\n        /*!  - æ¨¡å—å—çº§æ³¨é‡Šï¼Œä½†ä¼šæ¢è¡Œ */\n \n        //   - æ™®é€šè¡Œæ³¨é‡Š\n        ///  - è¡Œçº§æ–‡æ¡£æ³¨é‡Š ( å¿…é¡»æ˜¯ 3 ä¸ªæ–œæ )\n        //// - æ™®é€šè¡Œæ³¨é‡Š\n \n        /*   - æ™®é€šå—çº§æ³¨é‡Š */\n        /**  - å—çº§æ–‡æ¡£æ³¨é‡Š (ç²¾ç¡®) 2 ä¸ªæ˜Ÿå· */\n        /*** - æ™®é€šæ³¨é‡Š */\n \n        pub mod inner_module {}\n \n        pub mod nested_comments {\n            /* Rust ä¸­çš„æ³¨é‡Šå†…/* å¯ä»¥ /* åµŒå…¥æ³¨é‡Š */ */ */\n \n            // æ‰€æœ‰ä¸‰ç§å—æ³¨é‡Šéƒ½å¯ä»¥ç›¸äº’åŒ…å«æˆ–åµŒå¥—\n \n            /*   /* */  /** */  /*! */  */\n            /*!  /* */  /** */  /*! */  */\n            /**  /* */  /** */  /*! */  */\n            pub mod dummy_item {}\n        }\n \n        pub mod degenerate_cases {\n            // ç©ºçš„æ¨¡å—çº§æ–‡æ¡£æ³¨é‡Š\n            //!\n \n            // ç©ºçš„æ¨¡å—å—çº§æ–‡æ¡£æ³¨é‡Š\n            /*!*/\n \n            // ç©ºçš„è¡Œæ³¨é‡Š\n            //\n \n            // empty outer line doc\n            /// ç©ºçš„è¡Œçº§æ–‡æ¡£æ³¨é‡Š\n \n            // ç©ºçš„å—æ³¨é‡Š\n            /**/\n \n            pub mod dummy_item {}\n \n            // æ³¨æ„ï¼Œæ­¤å¤„ä¸æ˜¯ç©ºçš„å—çº§æ–‡æ¡£æ³¨é‡Šï¼Œè€Œåªæ˜¯ä¸€ä¸ªæ™®é€šçš„å—çº§æ³¨é‡Š\n            /***/\n \n        }\n \n        /* \n        ä¸‹é¢è¿™ç§æ–‡æ¡£æ³¨é‡Šæ˜¯ä¸å…è®¸çš„ï¼Œå› ä¸ºæ–‡æ¡£æ³¨é‡Šä¸‹é¢å¿…é¡»è¦æœ‰è¯­è¨€é¡¹ï¼Œæ¯”å¦‚æ–¹æ³•ã€å‡½æ•°ç­‰\n        /// Where is my item?\n        */\n    }\n\n*/","span":{"file_name":"src/ch01/lexical.rs","byte_start":3246,"byte_end":4987,"line_start":135,"line_end":199,"column_start":1,"column_end":3}},{"value":"/  - æ¨¡å—çº§æ–‡æ¡£æ³¨é‡Šï¼Œç½®äºæ¨¡å—å¤´éƒ¨","span":{"file_name":"src/ch01/lexical.rs","byte_start":5016,"byte_end":5065,"line_start":202,"line_end":202,"column_start":5,"column_end":26}},{"value":"/! - æ¨¡å—çº§æ–‡æ¡£æ³¨é‡Šï¼Œä½†æ˜¯å’Œä¸Šé¢æ³¨é‡Šç½®äºåŒä¸€è¡Œ","span":{"file_name":"src/ch01/lexical.rs","byte_start":5070,"byte_end":5137,"line_start":203,"line_end":203,"column_start":5,"column_end":32}},{"value":"/  - æ¨¡å—çº§æ–‡æ¡£æ³¨é‡Šï¼Œä½†ä¼šæ¢è¡Œ","span":{"file_name":"src/ch01/lexical.rs","byte_start":5143,"byte_end":5186,"line_start":205,"line_end":205,"column_start":5,"column_end":24}},{"value":"*  - æ¨¡å—å—çº§æ–‡æ¡£æ³¨é‡Š */","span":{"file_name":"src/ch01/lexical.rs","byte_start":5193,"byte_end":5227,"line_start":207,"line_end":207,"column_start":5,"column_end":23}},{"value":"*! - æ¨¡å—çº§æ³¨é‡Šï¼Œä½†æ˜¯å’Œä¸Šé¢æ³¨é‡Šç½®äºåŒä¸€è¡Œ */","span":{"file_name":"src/ch01/lexical.rs","byte_start":5232,"byte_end":5296,"line_start":208,"line_end":208,"column_start":5,"column_end":33}},{"value":"*  - æ¨¡å—å—çº§æ³¨é‡Šï¼Œä½†ä¼šæ¢è¡Œ */","span":{"file_name":"src/ch01/lexical.rs","byte_start":5302,"byte_end":5345,"line_start":210,"line_end":210,"column_start":5,"column_end":26}}]},{"kind":"Mod","id":{"krate":0,"index":10},"span":{"file_name":"src/ch01/lexical.rs","byte_start":5585,"byte_end":5597,"line_start":220,"line_end":220,"column_start":13,"column_end":25},"name":"inner_module","qualname":"::ch01::lexical::outer_module::inner_module","value":"src/ch01/lexical.rs","parent":null,"children":[],"decl_id":null,"docs":"  - è¡Œçº§æ–‡æ¡£æ³¨é‡Š ( å¿…é¡»æ˜¯ 3 ä¸ªæ–œæ )\n  - å—çº§æ–‡æ¡£æ³¨é‡Š (ç²¾ç¡®) 2 ä¸ªæ˜Ÿå· \n","sig":null,"attributes":[{"value":"/  - è¡Œçº§æ–‡æ¡£æ³¨é‡Š ( å¿…é¡»æ˜¯ 3 ä¸ªæ–œæ )","span":{"file_name":"src/ch01/lexical.rs","byte_start":5379,"byte_end":5429,"line_start":213,"line_end":213,"column_start":5,"column_end":31}},{"value":"*  - å—çº§æ–‡æ¡£æ³¨é‡Š (ç²¾ç¡®) 2 ä¸ªæ˜Ÿå· */","span":{"file_name":"src/ch01/lexical.rs","byte_start":5495,"byte_end":5544,"line_start":217,"line_end":217,"column_start":5,"column_end":32}}]},{"kind":"Mod","id":{"krate":0,"index":11},"span":{"file_name":"src/ch01/lexical.rs","byte_start":5642,"byte_end":5657,"line_start":223,"line_end":223,"column_start":13,"column_end":28},"name":"nested_comments","qualname":"::ch01::lexical::outer_module::nested_comments","value":"src/ch01/lexical.rs","parent":null,"children":[{"krate":0,"index":12}],"decl_id":null,"docs":" mod å®šä¹‰ä¸ªæ¨¡å—\n  /* */  /** */  /*! */  \n","sig":null,"attributes":[{"value":"/ mod å®šä¹‰ä¸ªæ¨¡å—","span":{"file_name":"src/ch01/lexical.rs","byte_start":5606,"byte_end":5629,"line_start":222,"line_end":222,"column_start":5,"column_end":18}},{"value":"*  /* */  /** */  /*! */  */","span":{"file_name":"src/ch01/lexical.rs","byte_start":5838,"byte_end":5868,"line_start":229,"line_end":229,"column_start":9,"column_end":39}}]},{"kind":"Mod","id":{"krate":0,"index":12},"span":{"file_name":"src/ch01/lexical.rs","byte_start":5924,"byte_end":5934,"line_start":231,"line_end":231,"column_start":17,"column_end":27},"name":"dummy_item","qualname":"::ch01::lexical::outer_module::nested_comments::dummy_item","value":"src/ch01/lexical.rs","parent":null,"children":[],"decl_id":null,"docs":"  /* */  /** */  /*! */  \n","sig":null,"attributes":[{"value":"*  /* */  /** */  /*! */  */","span":{"file_name":"src/ch01/lexical.rs","byte_start":5877,"byte_end":5907,"line_start":230,"line_end":230,"column_start":9,"column_end":39}}]},{"kind":"Mod","id":{"krate":0,"index":13},"span":{"file_name":"src/ch01/lexical.rs","byte_start":5957,"byte_end":5973,"line_start":234,"line_end":234,"column_start":13,"column_end":29},"name":"degenerate_cases","qualname":"::ch01::lexical::outer_module::degenerate_cases","value":"src/ch01/lexical.rs","parent":null,"children":[{"krate":0,"index":14}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"/","span":{"file_name":"src/ch01/lexical.rs","byte_start":6023,"byte_end":6026,"line_start":236,"line_end":236,"column_start":9,"column_end":12}},{"value":"**/","span":{"file_name":"src/ch01/lexical.rs","byte_start":6078,"byte_end":6083,"line_start":239,"line_end":239,"column_start":9,"column_end":14}}]},{"kind":"Mod","id":{"krate":0,"index":14},"span":{"file_name":"src/ch01/lexical.rs","byte_start":6251,"byte_end":6261,"line_start":250,"line_end":250,"column_start":17,"column_end":27},"name":"dummy_item","qualname":"::ch01::lexical::outer_module::degenerate_cases::dummy_item","value":"src/ch01/lexical.rs","parent":null,"children":[],"decl_id":null,"docs":" ç©ºçš„è¡Œçº§æ–‡æ¡£æ³¨é‡Š\n","sig":null,"attributes":[{"value":"/ ç©ºçš„è¡Œçº§æ–‡æ¡£æ³¨é‡Š","span":{"file_name":"src/ch01/lexical.rs","byte_start":6164,"byte_end":6192,"line_start":245,"line_end":245,"column_start":9,"column_end":21}}]},{"kind":"Mod","id":{"krate":0,"index":15},"span":{"file_name":"src/ch01/expr.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"expr","qualname":"::ch01::expr","value":"src/ch01/expr.rs","parent":null,"children":[{"krate":0,"index":16},{"krate":0,"index":17},{"krate":0,"index":18},{"krate":0,"index":19}],"decl_id":null,"docs":" ç¬¬ä¸€ç« ï¼šRustè¯­è¨€åŸºç¡€\n 1.4 è¯­æ³•é¢é¢è§‚ï¼ˆäºŒï¼‰ï¼šé¢å‘è¡¨è¾¾å¼ï¼ˆä¸Šï¼‰\n \n \n    \n","sig":null,"attributes":[{"value":"allow(unused_variables)","span":{"file_name":"src/ch01/expr.rs","byte_start":6551,"byte_end":6578,"line_start":1,"line_end":1,"column_start":1,"column_end":28}},{"value":"/ ç¬¬ä¸€ç« ï¼šRustè¯­è¨€åŸºç¡€","span":{"file_name":"src/ch01/expr.rs","byte_start":6579,"byte_end":6611,"line_start":2,"line_end":2,"column_start":1,"column_end":17}},{"value":"/ 1.4 è¯­æ³•é¢é¢è§‚ï¼ˆäºŒï¼‰ï¼šé¢å‘è¡¨è¾¾å¼ï¼ˆä¸Šï¼‰","span":{"file_name":"src/ch01/expr.rs","byte_start":6612,"byte_end":6671,"line_start":3,"line_end":3,"column_start":1,"column_end":26}},{"value":"/ ","span":{"file_name":"src/ch01/expr.rs","byte_start":6672,"byte_end":6676,"line_start":4,"line_end":4,"column_start":1,"column_end":5}},{"value":"/ ","span":{"file_name":"src/ch01/expr.rs","byte_start":6677,"byte_end":6681,"line_start":5,"line_end":5,"column_start":1,"column_end":5}},{"value":"/    ","span":{"file_name":"src/ch01/expr.rs","byte_start":6682,"byte_end":6689,"line_start":6,"line_end":6,"column_start":1,"column_end":8}}]},{"kind":"Function","id":{"krate":0,"index":16},"span":{"file_name":"src/ch01/expr.rs","byte_start":7263,"byte_end":7266,"line_start":39,"line_end":39,"column_start":8,"column_end":11},"name":"eop","qualname":"::ch01::expr::eop","value":"pub fn eop()","parent":null,"children":[],"decl_id":null,"docs":"    ### é¢å‘è¡¨è¾¾å¼ (Expression-Oriented programming)","sig":null,"attributes":[{"value":"*\n\n    ### é¢å‘è¡¨è¾¾å¼ (Expression-Oriented programming)\n\n    ```\n    use std::collections::HashMap;\n\n    fn add_one(i: &mut u32) {\n        *i += 1;\n    }\n\n    fn plus_one(i: &u32) -> u32 {\n        let i = i + 1;\n        i\n    }\n\n    fn main() {\n        let mut a = 41 ;\n        add_one(&mut a) ;\n        println!(\"{:?}\", a) ;\n        \n        let a = 41;\n        let b = plus_one(&a);\n        println!(\"{:?}\", b) ;\n        \n        let mut h = HashMap::new();\n        h.insert(\"anwser\", 42);\n        println!(\"anwser is {:?}\", h[\"anwser\"]);\n    }\n    ```\n*/","span":{"file_name":"src/ch01/expr.rs","byte_start":6691,"byte_end":7255,"line_start":8,"line_end":38,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":17},"span":{"file_name":"src/ch01/expr.rs","byte_start":7875,"byte_end":7894,"line_start":70,"line_end":70,"column_start":8,"column_end":27},"name":"semi_and_block_expr","qualname":"::ch01::expr::semi_and_block_expr","value":"pub fn semi_and_block_expr()","parent":null,"children":[],"decl_id":null,"docs":"    ### åˆ†å·è¡¨è¾¾å¼ vs å—è¡¨è¾¾å¼","sig":null,"attributes":[{"value":"*\n\n    ### åˆ†å·è¡¨è¾¾å¼ vs å—è¡¨è¾¾å¼\n\n    1. åˆ†å·è¡¨è¾¾å¼è¿”å›å€¼æ°¸è¿œä¸ºè‡ªèº«çš„å•å…ƒ(Unit)ç±»å‹ï¼š`()`\n    2. åˆ†å·è¡¨è¾¾å¼åªæœ‰åœ¨å—è¡¨è¾¾å¼æœ€åä¸€è¡Œæ‰ä¼šè¿›è¡Œæ±‚å€¼ï¼Œå…¶ä»–æ—¶å€™åªä½œä¸ºã€Œè¿æ¥ç¬¦ã€å­˜åœ¨\n    3. å—è¡¨è¾¾å¼åªå¯¹å…¶æœ€åä¸€è¡Œè¡¨è¾¾å¼è¿›è¡Œæ±‚å€¼ã€‚\n\n    ```\n    fn main(){\n        ; \n        ;\n        {\n            ()\n        }\n        {\n            ();\n            use std::vec::Vec;\n        }\n        ();\n        &();\n        &{;}; // -> &()\n        ; // ->  ()\n    }\n    ```\n*/","span":{"file_name":"src/ch01/expr.rs","byte_start":7330,"byte_end":7867,"line_start":44,"line_end":69,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":18},"span":{"file_name":"src/ch01/expr.rs","byte_start":8286,"byte_end":8300,"line_start":92,"line_end":92,"column_start":8,"column_end":22},"name":"fizzbuzz_match","qualname":"::ch01::expr::fizzbuzz_match","value":"pub fn fizzbuzz_match()","parent":null,"children":[],"decl_id":null,"docs":"    ### FizzBuzz in match ","sig":null,"attributes":[{"value":"*\n\n    ### FizzBuzz in match \n\n    ```\n    fn main() {\n        for i in 1..102 {\n            match (i%3, i%5) {\n                (0, 0) => println!(\"FizzBuzz\"),\n                (0, _) => println!(\"Fizz\"),\n                (_, 0) => println!(\"Buzz\"),\n                (_, _) => println!(\"{}\", i)\n            }\n        }\n    }   \n    ```\n*/","span":{"file_name":"src/ch01/expr.rs","byte_start":7941,"byte_end":8278,"line_start":75,"line_end":91,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":19},"span":{"file_name":"src/ch01/expr.rs","byte_start":8663,"byte_end":8674,"line_start":114,"line_end":114,"column_start":8,"column_end":19},"name":"fizzbuzz_if","qualname":"::ch01::expr::fizzbuzz_if","value":"pub fn fizzbuzz_if()","parent":null,"children":[],"decl_id":null,"docs":"    ### FizzBuzz in if ","sig":null,"attributes":[{"value":"*\n\n    ### FizzBuzz in if \n\n    ```\n    fn main() {\n        for i in 1..102 {\n            if i % 15 == 0 { println!(\"FizzBuzz\") }\n            else if i % 3 == 0 { println!(\"Fizz\") }\n            else if i % 5 == 0 { println!(\"Buzz\") }\n            else { println!(\"{}\", i) }\n        }\n    }\n\n    ```\n\n*/","span":{"file_name":"src/ch01/expr.rs","byte_start":8352,"byte_end":8655,"line_start":97,"line_end":113,"column_start":1,"column_end":3}}]},{"kind":"Mod","id":{"krate":0,"index":20},"span":{"file_name":"src/ch01/ctfe.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"ctfe","qualname":"::ch01::ctfe","value":"src/ch01/ctfe.rs","parent":null,"children":[{"krate":0,"index":21},{"krate":0,"index":22},{"krate":0,"index":23},{"krate":0,"index":24},{"krate":0,"index":25},{"krate":0,"index":26},{"krate":0,"index":27},{"krate":0,"index":28},{"krate":0,"index":29},{"krate":0,"index":30},{"krate":0,"index":31}],"decl_id":null,"docs":" ç¬¬ä¸€ç« ï¼šRustè¯­è¨€åŸºç¡€\n 1.4 è¯­æ³•é¢é¢è§‚ï¼ˆäºŒï¼‰ï¼šé¢å‘è¡¨è¾¾å¼ï¼ˆä¸­ï¼‰\n \n \n    \n","sig":null,"attributes":[{"value":"allow(unused_variables)","span":{"file_name":"src/ch01/ctfe.rs","byte_start":8722,"byte_end":8749,"line_start":1,"line_end":1,"column_start":1,"column_end":28}},{"value":"/ ç¬¬ä¸€ç« ï¼šRustè¯­è¨€åŸºç¡€","span":{"file_name":"src/ch01/ctfe.rs","byte_start":8750,"byte_end":8782,"line_start":2,"line_end":2,"column_start":1,"column_end":17}},{"value":"/ 1.4 è¯­æ³•é¢é¢è§‚ï¼ˆäºŒï¼‰ï¼šé¢å‘è¡¨è¾¾å¼ï¼ˆä¸­ï¼‰","span":{"file_name":"src/ch01/ctfe.rs","byte_start":8783,"byte_end":8842,"line_start":3,"line_end":3,"column_start":1,"column_end":26}},{"value":"/ ","span":{"file_name":"src/ch01/ctfe.rs","byte_start":8843,"byte_end":8847,"line_start":4,"line_end":4,"column_start":1,"column_end":5}},{"value":"/ ","span":{"file_name":"src/ch01/ctfe.rs","byte_start":8848,"byte_end":8852,"line_start":5,"line_end":5,"column_start":1,"column_end":5}},{"value":"/    ","span":{"file_name":"src/ch01/ctfe.rs","byte_start":8853,"byte_end":8860,"line_start":6,"line_end":6,"column_start":1,"column_end":8}}]},{"kind":"Function","id":{"krate":0,"index":21},"span":{"file_name":"src/ch01/ctfe.rs","byte_start":9092,"byte_end":9107,"line_start":19,"line_end":19,"column_start":8,"column_end":23},"name":"must_const_expr","qualname":"::ch01::ctfe::must_const_expr","value":"pub fn must_const_expr()","parent":null,"children":[],"decl_id":null,"docs":"    ### å¿…é¡»æ˜¯å¸¸é‡è¡¨è¾¾å¼æ‰èƒ½åœ¨å¸¸é‡ä¸Šä¸‹æ–‡ä½¿ç”¨","sig":null,"attributes":[{"value":"*\n    ### å¿…é¡»æ˜¯å¸¸é‡è¡¨è¾¾å¼æ‰èƒ½åœ¨å¸¸é‡ä¸Šä¸‹æ–‡ä½¿ç”¨\n\n    ```\n    fn main(){\n        let an = (42,).0;\n        const AN: i32 = an; // Error: attempt to use a non-constant value in a constant\n    }\n    ```\n*/","span":{"file_name":"src/ch01/ctfe.rs","byte_start":8863,"byte_end":9084,"line_start":9,"line_end":18,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":22},"span":{"file_name":"src/ch01/ctfe.rs","byte_start":9367,"byte_end":9382,"line_start":38,"line_end":38,"column_start":8,"column_end":23},"name":"const_array_len","qualname":"::ch01::ctfe::const_array_len","value":"pub fn const_array_len()","parent":null,"children":[],"decl_id":null,"docs":"    ### const fn","sig":null,"attributes":[{"value":"*\n\n    ### const fn\n\n\n    ```\n    const fn len() -> usize { 3 }\n\n    fn main(){\n        // æ•°ç»„é•¿åº¦æ˜¯å¸¸é‡ä¸Šä¸‹æ–‡\n        let array: [i32; len()] = [1, 2, 3];\n    }\n    ```\n\n*/","span":{"file_name":"src/ch01/ctfe.rs","byte_start":9173,"byte_end":9359,"line_start":23,"line_end":37,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":23},"span":{"file_name":"src/ch01/ctfe.rs","byte_start":10259,"byte_end":10268,"line_start":81,"line_end":81,"column_start":8,"column_end":17},"name":"const_fib","qualname":"::ch01::ctfe::const_fib","value":"pub fn const_fib()","parent":null,"children":[],"decl_id":null,"docs":"    ### const fn : fib","sig":null,"attributes":[{"value":"*\n    ### const fn : fib\n\n    ```\n    const fn gcd(a: u32, b: u32) -> u32 {\n        match (a, b) {\n            (x, 0) | (0, x) => x,\n\n            (x, y) if x % 2 == 0 && y % 2 == 0 => 2*gcd(x/2, y/2),\n            (x, y) | (y, x) if x % 2 == 0 => gcd(x/2, y),\n\n            (x, y) if x < y => gcd((y-x)/2, x),\n            (x, y) => gcd((x-y)/2, y),\n        }\n    }\n\n\n    const fn fib(n: u128) -> u128 {\n        const fn helper(n: u128, a: u128, b: u128, i: u128) -> u128 {\n            if i <= n {\n                helper(n, b, a + b, i + 1)\n            } else {\n                b\n            }\n        }\n        helper(n, 1, 1, 2)\n    }\n\n    const X: u128 = fib(10);\n    const GCD: u32 = gcd(21, 7);\n\n    fn main(){\n        println!(\"{}\", X);\n        println!(\"{}\", GCD);\n    }\n\n    ```\n\n*/","span":{"file_name":"src/ch01/ctfe.rs","byte_start":9462,"byte_end":10251,"line_start":42,"line_end":80,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":24},"span":{"file_name":"src/ch01/ctfe.rs","byte_start":10974,"byte_end":10983,"line_start":118,"line_end":118,"column_start":8,"column_end":17},"name":"const_fn_","qualname":"::ch01::ctfe::const_fn_","value":"pub fn const_fn_()","parent":null,"children":[],"decl_id":null,"docs":"    ### const fn","sig":null,"attributes":[{"value":"*\n\n    ### const fn\n\n    ```\n    const UNIT_TUPLE: [(u64, &str); 6] = {\n        let mut i = 0;\n        [\n            (1 << (10 * { i += 1; i }), \"KiB\"),\n            (1 << (10 * { i += 1; i }), \"MiB\"),\n            (1 << (10 * { i += 1; i }), \"GiB\"),\n            (1 << (10 * { i += 1; i }), \"TiB\"),\n            (1 << (10 * { i += 1; i }), \"PiB\"),\n            (1 << (10 * { i += 1; i }), \"EiB\")\n        ]\n    };\n\n    const fn square_area(a: i32) -> i32 {\n        let area = a * a;\n        area\n    }\n\n    const AREA: i32 = square_area(5);\n\n    fn main (){\n        dbg!(UNIT_TUPLE);\n        dbg!(AREA);\n    }\n    \n    ```\n*/","span":{"file_name":"src/ch01/ctfe.rs","byte_start":10344,"byte_end":10966,"line_start":87,"line_end":117,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":25},"span":{"file_name":"src/ch01/ctfe.rs","byte_start":11307,"byte_end":11321,"line_start":143,"line_end":143,"column_start":8,"column_end":22},"name":"const_fn_error","qualname":"::ch01::ctfe::const_fn_error","value":"pub fn const_fn_error()","parent":null,"children":[],"decl_id":null,"docs":"    ### å±•ç¤ºé”™è¯¯çš„ const æ±‚å€¼ç”¨æ³•","sig":null,"attributes":[{"value":"*\n\n    ### å±•ç¤ºé”™è¯¯çš„ const æ±‚å€¼ç”¨æ³•\n\n    ```\n    #![feature(const_fn)]\n\n    // Error\n    const fn hello() -> String{\n        \"Hello\".to_string()\n    }\n\n    // Error\n    const S : String = hello();\n\n    fn main(){ \n        println!(\" {:?} \", S);\n    }\n\n    ```\n*/","span":{"file_name":"src/ch01/ctfe.rs","byte_start":11025,"byte_end":11299,"line_start":122,"line_end":142,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":26},"span":{"file_name":"src/ch01/ctfe.rs","byte_start":11584,"byte_end":11604,"line_start":164,"line_end":164,"column_start":8,"column_end":28},"name":"fixed_const_fn_error","qualname":"::ch01::ctfe::fixed_const_fn_error","value":"pub fn fixed_const_fn_error()","parent":null,"children":[],"decl_id":null,"docs":"    ### ä¿®æ­£é”™è¯¯çš„ const æ±‚å€¼ç”¨æ³•","sig":null,"attributes":[{"value":"*\n    ### ä¿®æ­£é”™è¯¯çš„ const æ±‚å€¼ç”¨æ³•\n\n    ```\n\n    const fn hello() -> &'static str{\n        \"Hello\"\n    }\n\n    const Y: &str = hello();\n\n    fn main(){\n        println!(\"{}\", Y);\n    }\n\n    ```\n*/","span":{"file_name":"src/ch01/ctfe.rs","byte_start":11369,"byte_end":11576,"line_start":147,"line_end":163,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":27},"span":{"file_name":"src/ch01/ctfe.rs","byte_start":11853,"byte_end":11868,"line_start":184,"line_end":184,"column_start":8,"column_end":23},"name":"others_const_fn","qualname":"::ch01::ctfe::others_const_fn","value":"pub fn others_const_fn()","parent":null,"children":[],"decl_id":null,"docs":"    ### å…¶ä»–çš„Const fn ç”¨æ³•","sig":null,"attributes":[{"value":"*\n\n    ### å…¶ä»–çš„Const fn ç”¨æ³•\n\n    ```\n    #[derive(Debug)]\n    struct Answer(u32);\n    const A: Answer = Answer(42);\n\n    fn main(){\n        println!(\"{}\", A);\n    }\n\n    ```\n*/","span":{"file_name":"src/ch01/ctfe.rs","byte_start":11659,"byte_end":11845,"line_start":169,"line_end":183,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":28},"span":{"file_name":"src/ch01/ctfe.rs","byte_start":12092,"byte_end":12100,"line_start":202,"line_end":202,"column_start":8,"column_end":16},"name":"mir_show","qualname":"::ch01::ctfe::mir_show","value":"pub fn mir_show()","parent":null,"children":[],"decl_id":null,"docs":"    ### ç¼–è¯‘æœŸè®¡ç®—åŸç†ï¼šMIR å±•ç¤º\n    ```\n    const fn anwser() -> u32 { 42 }","sig":null,"attributes":[{"value":"*\n\n    ### ç¼–è¯‘æœŸè®¡ç®—åŸç†ï¼šMIR å±•ç¤º\n    ```\n    const fn anwser() -> u32 { 42 }\n\n    const A: u32 = anwser();\n\n    fn main(){\n        A;\n    }\n    ```\n\n*/","span":{"file_name":"src/ch01/ctfe.rs","byte_start":11918,"byte_end":12084,"line_start":188,"line_end":201,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":29},"span":{"file_name":"src/ch01/ctfe.rs","byte_start":12789,"byte_end":12802,"line_start":239,"line_end":239,"column_start":8,"column_end":21},"name":"if_while_true","qualname":"::ch01::ctfe::if_while_true","value":"pub fn if_while_true()","parent":null,"children":[],"decl_id":null,"docs":"    ### If True && While True","sig":null,"attributes":[{"value":"*\n\n    ### If True && While True\n\n    ```\n    fn if_true(x: i32) -> i32 {\n        if true {  // error[E0308]: mismatched typesï¼Œexpected type `i32` found type `()`\n            return x+1;\n        }\n    }\n\n    fn while_true(x: i32) -> i32 {\n        while true {  // error[E0308]: mismatched typesï¼Œexpected type `i32` found type `()`\n            return x+1;\n        }\n    }\n\n    fn main() {\n        let y = while_true(5);\n        assert_eq!(y, 6);\n\n        let y = if_true(5);\n        assert_eq!(y, 6);\n\n        let x;\n        // while true { x = 1; break; } \n        loop { x = 1; break; }\n        println!(\"{}\", x);\n\n    }\n    ```\n\n*/","span":{"file_name":"src/ch01/ctfe.rs","byte_start":12142,"byte_end":12781,"line_start":206,"line_end":238,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":30},"span":{"file_name":"src/ch01/ctfe.rs","byte_start":14146,"byte_end":14164,"line_start":297,"line_end":297,"column_start":8,"column_end":26},"name":"const_generic_show","qualname":"::ch01::ctfe::const_generic_show","value":"pub fn const_generic_show()","parent":null,"children":[],"decl_id":null,"docs":"    ### const generic ","sig":null,"attributes":[{"value":"*\n    ### const generic \n\n    ```\n    #![feature(min_const_generics)]\n    #![feature(const_in_array_repeat_expressions)]\n\n    use core::mem::MaybeUninit;\n\n    #[derive(Debug)]\n    pub struct ArrayVec<T, const N: usize> {\n        items: [MaybeUninit<T>; N],\n        length: usize,\n    }\n\n    impl<T, const N: usize> ArrayVec<T,  {N} > {\n        pub const fn new() -> ArrayVec<T, {N} > {\n            ArrayVec {\n                items: [MaybeUninit::uninit(); N],\n                length: 0,\n            }\n        }\n        \n        #[inline]\n        pub const fn len(&self) -> usize { self.length }\n        \n        #[inline]\n        pub const fn is_empty(&self) -> bool { self.len() == 0 }\n        \n        #[inline]\n        pub const fn capacity(&self) -> usize { N }\n        \n        #[inline]\n        pub const fn is_full(&self) -> bool { self.len() >= self.capacity() }\n        \n    }\n\n    impl<T, const N: usize> Drop for ArrayVec<T, { N }> {\n        #[inline]\n        fn drop(&mut self) {\n            // Makes sure the destructors for all items are run.\n            // self.clear();\n        }\n    }\n\n\n    fn main(){\n        // let mut vector = ArrayVec::new();\n        // println!(\"{}, {}\", vector.len(), vector.capacity());\n        // println!(\"{:?}\", vector);\n    }\n    ```\n*/","span":{"file_name":"src/ch01/ctfe.rs","byte_start":12855,"byte_end":14138,"line_start":244,"line_end":296,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":31},"span":{"file_name":"src/ch01/ctfe.rs","byte_start":14630,"byte_end":14646,"line_start":320,"line_end":320,"column_start":8,"column_end":24},"name":"array_chunk_show","qualname":"::ch01::ctfe::array_chunk_show","value":"pub fn array_chunk_show()","parent":null,"children":[],"decl_id":null,"docs":"    ### array chunk æ¼”ç¤º","sig":null,"attributes":[{"value":"*\n\n    ### array chunk æ¼”ç¤º\n\n    ```\n    #![feature(array_chunks)]\n    fn main() {\n        let data = [1, 2, 3, 4, 5, 6];\n        let sum1 = data.array_chunks().map(|&[x, y]| x * y).sum::<i32>();\n        assert_eq!(sum1, (1 * 2) + (3 * 4) + (5 * 6));\n\n        let sum2 = data.array_chunks().map(|&[x, y, z]| x * y * z).sum::<i32>();\n        assert_eq!(sum2, (1 * 2 * 3) + (4 * 5 * 6));\n    }\n\n    ```\n*/","span":{"file_name":"src/ch01/ctfe.rs","byte_start":14215,"byte_end":14622,"line_start":303,"line_end":319,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":32},"span":{"file_name":"src/ch01/mod.rs","byte_start":442,"byte_end":447,"line_start":18,"line_end":18,"column_start":8,"column_end":13},"name":"title","qualname":"::ch01::title","value":"pub fn title()","parent":null,"children":[],"decl_id":null,"docs":" # Examples","sig":null,"attributes":[{"value":"/ # Examples","span":{"file_name":"src/ch01/mod.rs","byte_start":322,"byte_end":336,"line_start":10,"line_end":10,"column_start":1,"column_end":15}},{"value":"/","span":{"file_name":"src/ch01/mod.rs","byte_start":337,"byte_end":340,"line_start":11,"line_end":11,"column_start":1,"column_end":4}},{"value":"/ Basic usage:","span":{"file_name":"src/ch01/mod.rs","byte_start":341,"byte_end":357,"line_start":12,"line_end":12,"column_start":1,"column_end":17}},{"value":"/","span":{"file_name":"src/ch01/mod.rs","byte_start":358,"byte_end":361,"line_start":13,"line_end":13,"column_start":1,"column_end":4}},{"value":"/ ```","span":{"file_name":"src/ch01/mod.rs","byte_start":362,"byte_end":369,"line_start":14,"line_end":14,"column_start":1,"column_end":8}},{"value":"/   println!(\"ç¬¬1ç« ï¼š{}\", \"Rustè¯­è¨€åŸºç¡€\");","span":{"file_name":"src/ch01/mod.rs","byte_start":370,"byte_end":421,"line_start":15,"line_end":15,"column_start":1,"column_end":38}},{"value":"/ ","span":{"file_name":"src/ch01/mod.rs","byte_start":422,"byte_end":426,"line_start":16,"line_end":16,"column_start":1,"column_end":5}},{"value":"/ ```","span":{"file_name":"src/ch01/mod.rs","byte_start":427,"byte_end":434,"line_start":17,"line_end":17,"column_start":1,"column_end":8}}]},{"kind":"Mod","id":{"krate":0,"index":33},"span":{"file_name":"src/ch02/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"ch02","qualname":"::ch02","value":"src/ch02/mod.rs","parent":null,"children":[{"krate":0,"index":34},{"krate":0,"index":42},{"krate":0,"index":50},{"krate":0,"index":55},{"krate":0,"index":57},{"krate":0,"index":65},{"krate":0,"index":67},{"krate":0,"index":71},{"krate":0,"index":76}],"decl_id":null,"docs":" ç¬¬äºŒç« ï¼šRustæ ¸å¿ƒæ¦‚å¿µ","sig":null,"attributes":[{"value":"/ ç¬¬äºŒç« ï¼šRustæ ¸å¿ƒæ¦‚å¿µ","span":{"file_name":"src/ch02/mod.rs","byte_start":14693,"byte_end":14725,"line_start":1,"line_end":1,"column_start":1,"column_end":17}},{"value":"/","span":{"file_name":"src/ch02/mod.rs","byte_start":14726,"byte_end":14729,"line_start":2,"line_end":2,"column_start":1,"column_end":4}},{"value":"/ æœ¬ç« åŒ…æ‹¬ï¼š","span":{"file_name":"src/ch02/mod.rs","byte_start":14730,"byte_end":14749,"line_start":3,"line_end":3,"column_start":1,"column_end":10}},{"value":"/ 1. å®‰å…¨ç®¡ç†","span":{"file_name":"src/ch02/mod.rs","byte_start":14750,"byte_end":14769,"line_start":4,"line_end":4,"column_start":1,"column_end":12}},{"value":"/ 2. å·¥ç¨‹èƒ½åŠ›","span":{"file_name":"src/ch02/mod.rs","byte_start":14770,"byte_end":14789,"line_start":5,"line_end":5,"column_start":1,"column_end":12}},{"value":"/ 3. å…ƒç¼–ç¨‹","span":{"file_name":"src/ch02/mod.rs","byte_start":14790,"byte_end":14806,"line_start":6,"line_end":6,"column_start":1,"column_end":11}},{"value":"/ 4. å®‰å…¨è¾¹ç•Œ","span":{"file_name":"src/ch02/mod.rs","byte_start":14807,"byte_end":14826,"line_start":7,"line_end":7,"column_start":1,"column_end":12}}]},{"kind":"Mod","id":{"krate":0,"index":34},"span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"s1_ownership","qualname":"::ch02::s1_ownership","value":"src/ch02/s1_ownership.rs","parent":null,"children":[{"krate":0,"index":35},{"krate":0,"index":36},{"krate":0,"index":37},{"krate":0,"index":38},{"krate":0,"index":39},{"krate":0,"index":40},{"krate":0,"index":41}],"decl_id":null,"docs":" ç¬¬äºŒç« ï¼šRustæ ¸å¿ƒæ¦‚å¿µ\n 2.1 å®‰å…¨ç®¡ç†ä¹‹å†…å­˜å®‰å…¨\n \n æ‰€æœ‰æƒç›¸å…³ä»£ç \n \n  String ç»“æ„ï¼š\n  \n  ```text\n  ---  \n                   buffer\n                  /   capacity\n                 /   /  length\n                /   /   /\n              +â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+\n  stack frame â”‚ â€¢ â”‚ 8 â”‚ 6 â”‚ <- my_name: String\n              +â€“â”‚â€“+â€“â€“â€“+â€“â€“â€“+\n                â”‚\n              [â€“â”‚â€“â€“â€“â€“â€“â€“â€“â€“ capacity â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“]\n                â”‚\n              +â€“Vâ€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+\n  heap        â”‚ P â”‚ a â”‚ s â”‚ c â”‚ a â”‚ l â”‚   â”‚   â”‚\n              +â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+\n              [â€“â€“â€“â€“â€“â€“â€“ length â€“â€“â€“â€“â€“â€“â€“â€“]\n   \n  &'static str ç»“æ„ï¼š\n              [â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“]\n              +â€“â€“â€“+â€“â€“â€“+\n  stack frame â”‚ â€¢ â”‚ 6 â”‚ \n              +â€“â”‚â€“+â€“â€“â€“+\n                â”‚                 \n                +â€“â€“+                \n                   â”‚\n  preallocated   +â€“Vâ€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+\n  read-only      â”‚ P â”‚ a â”‚ s â”‚ c â”‚ a â”‚ l â”‚\n  memory         +â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+\n  ```\n","sig":null,"attributes":[{"value":"/ ç¬¬äºŒç« ï¼šRustæ ¸å¿ƒæ¦‚å¿µ","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15171,"byte_end":15203,"line_start":1,"line_end":1,"column_start":1,"column_end":17}},{"value":"/ 2.1 å®‰å…¨ç®¡ç†ä¹‹å†…å­˜å®‰å…¨","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15204,"byte_end":15239,"line_start":2,"line_end":2,"column_start":1,"column_end":18}},{"value":"/ ","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15240,"byte_end":15244,"line_start":3,"line_end":3,"column_start":1,"column_end":5}},{"value":"/ æ‰€æœ‰æƒç›¸å…³ä»£ç ","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15245,"byte_end":15270,"line_start":4,"line_end":4,"column_start":1,"column_end":12}},{"value":"/ ","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15271,"byte_end":15275,"line_start":5,"line_end":5,"column_start":1,"column_end":5}},{"value":"/  String ç»“æ„ï¼š","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15276,"byte_end":15297,"line_start":6,"line_end":6,"column_start":1,"column_end":16}},{"value":"/  ","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15298,"byte_end":15303,"line_start":7,"line_end":7,"column_start":1,"column_end":6}},{"value":"/  ```text","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15304,"byte_end":15316,"line_start":8,"line_end":8,"column_start":1,"column_end":13}},{"value":"/  ---  ","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15317,"byte_end":15327,"line_start":9,"line_end":9,"column_start":1,"column_end":11}},{"value":"/                   buffer","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15328,"byte_end":15356,"line_start":10,"line_end":10,"column_start":1,"column_end":29}},{"value":"/                  /   capacity","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15357,"byte_end":15390,"line_start":11,"line_end":11,"column_start":1,"column_end":34}},{"value":"/                 /   /  length","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15391,"byte_end":15424,"line_start":12,"line_end":12,"column_start":1,"column_end":34}},{"value":"/                /   /   /","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15425,"byte_end":15453,"line_start":13,"line_end":13,"column_start":1,"column_end":29}},{"value":"/              +â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15454,"byte_end":15502,"line_start":14,"line_end":14,"column_start":1,"column_end":31}},{"value":"/  stack frame â”‚ â€¢ â”‚ 8 â”‚ 6 â”‚ <- my_name: String","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15503,"byte_end":15562,"line_start":15,"line_end":15,"column_start":1,"column_end":50}},{"value":"/              +â€“â”‚â€“+â€“â€“â€“+â€“â€“â€“+","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15563,"byte_end":15611,"line_start":16,"line_end":16,"column_start":1,"column_end":31}},{"value":"/                â”‚","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15612,"byte_end":15634,"line_start":17,"line_end":17,"column_start":1,"column_end":21}},{"value":"/              [â€“â”‚â€“â€“â€“â€“â€“â€“â€“â€“ capacity â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“]","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15635,"byte_end":15727,"line_start":18,"line_end":18,"column_start":1,"column_end":51}},{"value":"/                â”‚","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15728,"byte_end":15750,"line_start":19,"line_end":19,"column_start":1,"column_end":21}},{"value":"/              +â€“Vâ€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15751,"byte_end":15847,"line_start":20,"line_end":20,"column_start":1,"column_end":51}},{"value":"/  heap        â”‚ P â”‚ a â”‚ s â”‚ c â”‚ a â”‚ l â”‚   â”‚   â”‚","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15848,"byte_end":15916,"line_start":21,"line_end":21,"column_start":1,"column_end":51}},{"value":"/              +â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15917,"byte_end":16015,"line_start":22,"line_end":22,"column_start":1,"column_end":51}},{"value":"/              [â€“â€“â€“â€“â€“â€“â€“ length â€“â€“â€“â€“â€“â€“â€“â€“]","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":16016,"byte_end":16088,"line_start":23,"line_end":23,"column_start":1,"column_end":43}},{"value":"/   ","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":16089,"byte_end":16095,"line_start":24,"line_end":24,"column_start":1,"column_end":7}},{"value":"/  &'static str ç»“æ„ï¼š","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":16096,"byte_end":16123,"line_start":25,"line_end":25,"column_start":1,"column_end":22}},{"value":"/              [â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“]","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":16124,"byte_end":16176,"line_start":26,"line_end":26,"column_start":1,"column_end":31}},{"value":"/              +â€“â€“â€“+â€“â€“â€“+","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":16177,"byte_end":16215,"line_start":27,"line_end":27,"column_start":1,"column_end":27}},{"value":"/  stack frame â”‚ â€¢ â”‚ 6 â”‚ ","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":16216,"byte_end":16251,"line_start":28,"line_end":28,"column_start":1,"column_end":28}},{"value":"/              +â€“â”‚â€“+â€“â€“â€“+","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":16252,"byte_end":16290,"line_start":29,"line_end":29,"column_start":1,"column_end":27}},{"value":"/                â”‚                 ","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":16291,"byte_end":16330,"line_start":30,"line_end":30,"column_start":1,"column_end":38}},{"value":"/                +â€“â€“+                ","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":16331,"byte_end":16374,"line_start":31,"line_end":31,"column_start":1,"column_end":40}},{"value":"/                   â”‚","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":16375,"byte_end":16400,"line_start":32,"line_end":32,"column_start":1,"column_end":24}},{"value":"/  preallocated   +â€“Vâ€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":16401,"byte_end":16480,"line_start":33,"line_end":33,"column_start":1,"column_end":46}},{"value":"/  read-only      â”‚ P â”‚ a â”‚ s â”‚ c â”‚ a â”‚ l â”‚","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":16481,"byte_end":16540,"line_start":34,"line_end":34,"column_start":1,"column_end":46}},{"value":"/  memory         +â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":16541,"byte_end":16622,"line_start":35,"line_end":35,"column_start":1,"column_end":46}},{"value":"/  ```","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":16623,"byte_end":16631,"line_start":36,"line_end":36,"column_start":1,"column_end":9}}]},{"kind":"Function","id":{"krate":0,"index":35},"span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":17831,"byte_end":17846,"line_start":83,"line_end":83,"column_start":8,"column_end":23},"name":"primitive_types","qualname":"::ch02::s1_ownership::primitive_types","value":"pub fn primitive_types()","parent":null,"children":[],"decl_id":null,"docs":"    ### Rust è¯­ä¹‰ï¼šMove è¯­ä¹‰ ä¸ Copy è¯­ä¹‰","sig":null,"attributes":[{"value":"*\n    ### Rust è¯­ä¹‰ï¼šMove è¯­ä¹‰ ä¸ Copy è¯­ä¹‰\n\n    åŸºæœ¬æ•°æ®ç±»å‹ï¼š https://doc.rust-lang.org/std/index.html#primitives\n\n    ```\n    fn main(){\n        // impl Copy for i32\n        let a = 42;\n        let b = a;\n        println!(\"{:?}\", a);  // work\n\n        // impl Copy for &'static str\n        let a = \"42\";\n        let b = a;\n        println!(\"{:?}\", a); // work\n        \n        // impl !Copy for String\n        let a = \"42\".to_string();\n        // &String deref to &str\n        let b : &str = &a;\n        // impl Copy for &'a T\n        let c = b;\n        println!(\"{:?}\", b); // work\n\n        // impl !Copy for String\n        let mut a = \"42\".to_string();\n        // impl !Copy for &mut T\n        let b : &mut str = &mut a;\n        let c = b;\n        // println!(\"{:?}\", b); // don't work, b have been moved\n        \n        // auto impl Copy for Tuple, if all item implemented Copy trait in Tuple\n        let t = (42, \"42\");\n        let t2 = t;\n        println!(\"{:?}\", t); // work\n        \n        // auto impl !Copy for Tuple\n        let t = (42, \"42\".to_string());\n        let t2 = t;\n        // println!(\"{:?}\", t); // don't work, t have been moved\n    }\n    ```\n*/","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":16634,"byte_end":17823,"line_start":39,"line_end":82,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":36},"span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":18686,"byte_end":18698,"line_start":129,"line_end":129,"column_start":8,"column_end":20},"name":"custom_types","qualname":"::ch02::s1_ownership::custom_types","value":"pub fn custom_types()","parent":null,"children":[],"decl_id":null,"docs":"    ### Rust è¯­ä¹‰ï¼šMove è¯­ä¹‰ ä¸ Copy è¯­ä¹‰","sig":null,"attributes":[{"value":"*\n    ### Rust è¯­ä¹‰ï¼šMove è¯­ä¹‰ ä¸ Copy è¯­ä¹‰\n\n    è‡ªå®šä¹‰æ•°æ®ç±»å‹ï¼š\n\n    ```\n    // #[derive(Copy, Clone)]\n    struct A;\n\n    // #[derive(Copy, Clone)]\n    struct Point(u32);\n\n    // #[derive(Copy, Clone)]\n    struct Member {\n        name: &'static str,\n        age: u32,\n    }\n\n    // #[derive(Copy, Clone)]\n    struct Person {\n        name: String,\n        age: u32,\n    }\n\n    fn main(){\n        let a = A;\n        let b = a;\n        println!(\"{:?}\", a);  // work\n\n        let a = Point(60);\n        let b = a;\n        println!(\"{:?}\", a);  // work\n\n        let a = Member{name: \"Alex\", age: \"18\"};\n        let b = a;\n\n        let a = Member{name: \"Alex\".to_string(), age: \"18\"};\n        let b = a;\n    }\n    ```\n*/","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":17944,"byte_end":18678,"line_start":88,"line_end":128,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":37},"span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":19275,"byte_end":19296,"line_start":161,"line_end":161,"column_start":8,"column_end":29},"name":"understand_copy_clone","qualname":"::ch02::s1_ownership::understand_copy_clone","value":"pub fn understand_copy_clone()","parent":null,"children":[],"decl_id":null,"docs":"    ### Rust è¯­ä¹‰ï¼šMove è¯­ä¹‰ ä¸ Copy è¯­ä¹‰","sig":null,"attributes":[{"value":"*\n    ### Rust è¯­ä¹‰ï¼šMove è¯­ä¹‰ ä¸ Copy è¯­ä¹‰\n\n    - ç†è§£ Copyï¼šClone  https://doc.rust-lang.org/std/marker/trait.Copy.html\n\n\n    ```\n    struct A;\n\n    // æ²¡ç”¨ï¼Œè‡ªå·±å®ç°Copyå’ŒCloneæ— æ³•æ”¹å˜ç¼–è¯‘å™¨é»˜è®¤è¡Œä¸º\n    impl Clone for A {\n        fn clone(&self) -> Self {\n            println!(\"from Custom Copy: Clone\");\n            *self\n        }\n    }\n\n    impl Copy for A {}\n\n\n    fn main(){\n        let a = A;\n        let b = a;\n    }\n    \n    ```\n*/","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":18793,"byte_end":19267,"line_start":134,"line_end":160,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":38},"span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":21458,"byte_end":21473,"line_start":259,"line_end":259,"column_start":8,"column_end":23},"name":"understand_copy","qualname":"::ch02::s1_ownership::understand_copy","value":"pub fn understand_copy()","parent":null,"children":[],"decl_id":null,"docs":"    ### Rust è¯­ä¹‰ï¼šMove è¯­ä¹‰ ä¸ Copy è¯­ä¹‰","sig":null,"attributes":[{"value":"*\n    ### Rust è¯­ä¹‰ï¼šMove è¯­ä¹‰ ä¸ Copy è¯­ä¹‰\n\n    - ç†è§£ æŒ‰ä½å¤åˆ¶\n\n    ```\n    #[derive(Copy, Clone)]\n    struct A(i8, i32);\n    fn main() {\n        let a = A(1, 2);\n        let b = a; // æŒ‰ä½å¤åˆ¶ï¼Œå¤åˆ¶åï¼Œbå’Œaå®Œå…¨ç›¸åŒï¼ŒåŒ…æ‹¬å†…å­˜å¯¹é½å¡«å……çš„paddingéƒ¨åˆ†ã€‚\n        let c = A(a.0, a.1); // é€æˆå‘˜å¤åˆ¶ï¼ŒéæŒ‰ä½å¤åˆ¶ï¼Œcå’Œaçš„paddingéƒ¨åˆ†ä¸ä¸€å®šç›¸åŒã€‚        \n    }\n    \n    ```\n\n    ç¤ºä¾‹äºŒï¼š\n    \n    ```rust\n    #[derive(Debug, Copy, Clone)]\n    struct A {\n        a: u16,\n        b: u8,\n        c: bool,\n    }\n\n    fn main() {\n        let a = unsound_a();\n        // å°è¯•å°† Some(a) æ”¹ä¸º a\n        let some_a = Some(a);\n        \n        println!(\"a: {:#?}\", a);\n        println!(\"some_a: {:#?}\", some_a);\n    }\n\n\n    fn unsound_a() -> A {\n        #[derive(Debug, Copy, Clone)]\n        struct B {\n            a: u16,\n            b: u8,\n            c: u8,\n        }\n        // ä¾æ¬¡ä¿®æ”¹ c çš„å€¼ä¸º 0ï¼Œ1ï¼Œ2 æ‰“å°è¾“å‡ºç»“æœ\n        let b = B { a: 1, b: 1, c: 1 };\n        unsafe {*(&b as *const B as *const A) }\n    }\n    ```\n\n    ç¤ºä¾‹ä¸‰ï¼š\n\n    ```rust\n    #![allow(unused_variables)]\n\n    use std::{ptr, mem};\n\n    fn main() {\n        let mut d = String::from(\"cccc\");\n        let d_len = d.len();\n        // {\n            let mut c = String::with_capacity(d_len);\n\n            unsafe {\n                ptr::copy(&d, &mut c, 1);\n            };\n            println!(\"{:?}\", c.as_ptr());\n            // unsafe {\n            //     ptr::drop_in_place(c.as_mut_ptr());\n            // }\n            // æ³¨æ‰ dropï¼Œä¼šäº§ç”Ÿdouble freeï¼Œ\n            // ä½†æ˜¯ä¸æ³¨æ‰ dropï¼Œä¼šäº§ç”Ÿæ— æ•ˆæŒ‡é’ˆ\n            mem::drop(c);\n        // }\n\n        println!(\"{:?}\", d.as_ptr());\n        d.push_str(\"c\");\n        println!(\"{}\", d);\n    }\n    ```\n\n    ç¤ºä¾‹å››: Copy ä¸ä¸€å®šåªåœ¨æ ˆä¸Šè¿›è¡Œ\n\n    ```rust\n    use std::cell::RefCell;\n\n    fn main() {\n        let a = Box::new(RefCell::new(1));\n        let b = Box::new(RefCell::new(2));\n        *b.borrow_mut() = *a.borrow();\n        println!(\"b = {}\", b.borrow());\n    }\n    ```\n*/","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":19352,"byte_end":21450,"line_start":166,"line_end":258,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":39},"span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":22319,"byte_end":22334,"line_start":302,"line_end":302,"column_start":8,"column_end":23},"name":"understand_move","qualname":"::ch02::s1_ownership::understand_move","value":"pub fn understand_move()","parent":null,"children":[],"decl_id":null,"docs":"    ç¤ºä¾‹1: Box<T> å®ç° DereMove","sig":null,"attributes":[{"value":"*\n\n    ç¤ºä¾‹1: Box<T> å®ç° DereMove\n\n    ```rust\n    fn main(){\n        let s = Box::new(\"hello\".to_string());\n        println!(\"{:p}\", &s);\n        println!(\"{:p}\", s.as_ptr());\n        // DerefMove\n        let s2 = *s;\n        // println!(\"{:p}\", s.as_ptr()); // Moved s\n        println!(\"{:p}\", s2.as_ptr());\n    }\n    ```\n\n    ç¤ºä¾‹äºŒï¼šArc æ— æ³• DerefMove\n\n    https://doc.rust-lang.org/std/sync/struct.Arc.html\n\n\n\n    ```rust\n    use std::sync::Arc;\n\n    fn main(){\n        let s = Arc::new(\"hello\".to_string());\n        println!(\"{:p}\", &s);\n        println!(\"{:p}\", s.as_ptr());\n        // DerefMove Error : cannot move out of an `Arc`\n        let s2 = *s;\n        // println!(\"{:p}\", s.as_ptr()); // Moved s\n        println!(\"{:p}\", s2.as_ptr());\n    }\n    ```\n\n*/","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":21530,"byte_end":22311,"line_start":265,"line_end":301,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":40},"span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":22577,"byte_end":22593,"line_start":312,"line_end":312,"column_start":8,"column_end":24},"name":"understand_clone","qualname":"::ch02::s1_ownership::understand_clone","value":"pub fn understand_clone()","parent":null,"children":[],"decl_id":null,"docs":"    è¯­ä¹‰å±‚é¢æ¥ç†è§£ Clone ï¼šæ˜¾å¼çš„cloneæ–¹æ³•è°ƒç”¨åŒä¸€ç§è¯­ä¹‰ä¸‹çš„ä¸¤ç§å®ç°\n    1. String ç­‰ å¼•ç”¨ç±»å‹çš„ Clone\n    2. Rc/Arc ç±»å‹çš„ Clone\n","sig":null,"attributes":[{"value":"*\n    è¯­ä¹‰å±‚é¢æ¥ç†è§£ Clone ï¼šæ˜¾å¼çš„cloneæ–¹æ³•è°ƒç”¨åŒä¸€ç§è¯­ä¹‰ä¸‹çš„ä¸¤ç§å®ç°\n    1. String ç­‰ å¼•ç”¨ç±»å‹çš„ Clone\n    2. Rc/Arc ç±»å‹çš„ Clone\n*/","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":22398,"byte_end":22569,"line_start":307,"line_end":311,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":41},"span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":26030,"byte_end":26045,"line_start":476,"line_end":476,"column_start":8,"column_end":23},"name":"understand_drop","qualname":"::ch02::s1_ownership::understand_drop","value":"pub fn understand_drop()","parent":null,"children":[],"decl_id":null,"docs":"    ç¤ºä¾‹1: Move çš„æœ¬è´¨ï¼šdrop æ ‡è®°","sig":null,"attributes":[{"value":"*\n\n    ç¤ºä¾‹1: Move çš„æœ¬è´¨ï¼šdrop æ ‡è®°\n\n    ```rust\n    fn main(){\n        // impl Copy for i32\n        let mut a = \"42\".to_string();\n        let b = a; // drop(a);\n        \n        a = \"32\".to_string();\n        println!(\"{:?}\", a);\n    }\n    ```\n\n    ç¤ºä¾‹äºŒï¼šDrop ææ„å‡½æ•°\n\n\n    ```rust\n    struct PrintDrop(&'static str);\n    impl Drop for PrintDrop {\n        fn drop(&mut self) {\n            println!(\"Dropping {}\", self.0)\n        }\n    }\n    fn main() {\n        let x = PrintDrop(\"x\");\n        let y = PrintDrop(\"y\");\n    }\n    ```\n    \n    å…ƒç»„ï¼š\n\n    ```rust\n    struct PrintDrop(&'static str);\n        impl Drop for PrintDrop {\n            fn drop(&mut self) {\n                println!(\"Dropping {}\", self.0)\n        }\n    }\n    fn main() {\n        let tup1 = (PrintDrop(\"a\"), PrintDrop(\"b\"), PrintDrop(\"c\"));\n        let tup2 = (PrintDrop(\"x\"), PrintDrop(\"y\"), PrintDrop(\"z\"));\n    }\n    ```\n\n    å¸¦panicçš„å…ƒç»„ï¼š\n\n    ```rust\n    struct PrintDrop(&'static str);\n    impl Drop for PrintDrop {\n        fn drop(&mut self) {\n            println!(\"Dropping {}\", self.0)\n    }\n    }\n    fn main() {\n        let tup1 = (PrintDrop(\"a\"), PrintDrop(\"b\"), PrintDrop(\"c\"));\n        let tup2 = (PrintDrop(\"x\"), PrintDrop(\"y\"), panic!());\n    }\n\n    ```\n \n    ç»“æ„ä½“ï¼š\n\n    ```rust\n    struct PrintDrop(&'static str);\n\n    impl Drop for PrintDrop {\n        fn drop(&mut self) {\n            println!(\"Dropping {}\", self.0)\n        }\n    }\n\n    struct Foo {\n        bar: PrintDrop,\n        baz: PrintDrop,\n    }\n\n    impl Drop for Foo {\n        fn drop(&mut self) {\n            println!(\"Dropping Foo\")\n        }\n    }\n\n    fn main() {\n        let foo = Foo {\n            bar: PrintDrop(\"bar\"),\n            baz: PrintDrop(\"baz\"),\n        };\n    }\n    ```\n\n    é—­åŒ…ï¼š\n\n    ```\n    struct PrintDrop(&'static str);\n    impl Drop for PrintDrop {\n        fn drop(&mut self) {\n            println!(\"Dropping {}\", self.0)\n        }\n    }\n    fn main() {\n        let z = PrintDrop(\"z\");\n        let x = PrintDrop(\"x\");\n        let y = PrintDrop(\"y\");\n        let closure = move || { y; z; x; };\n    }\n    ```\n\n    é—­åŒ…ä¿®æ”¹å˜é‡ï¼š\n\n    ```\n    struct PrintDrop(&'static str);\n    impl Drop for PrintDrop {\n        fn drop(&mut self) {\n            println!(\"Dropping {}\", self.0)\n        }\n    }\n    fn main() {\n        let y = PrintDrop(\"y\");\n        let x = PrintDrop(\"x\");\n        let z = PrintDrop(\"z\");\n        let closure = move || {\n            { let z_ref = &z; }\n            x; y; z;\n        };\n    }\n    ```\n\n    ç¤ºä¾‹ä¸‰ï¼š æ‰€æœ‰æƒ forget/ ManuallyDrop\n\n    ```rust\n    // https://doc.rust-lang.org/src/alloc/sync.rs.html#319\n    impl<T> Arc<T> {\n        pub fn new(data: T) -> Arc<T> {\n            // Start the weak pointer count as 1 which is the weak pointer that's\n            // held by all the strong pointers (kinda), see std/rc.rs for more info\n            let x: Box<_> = box ArcInner {\n                strong: atomic::AtomicUsize::new(1),\n                weak: atomic::AtomicUsize::new(1),\n                data,\n            };\n            // ManuallyDrop\n            Self::from_inner(Box::leak(x).into())\n        }\n\n        // ...\n    }\n\n    impl<T> Weak<T> {\n        pub fn into_raw(self) -> *const T {\n            let result = self.as_ptr();\n            mem::forget(self);\n            result\n        }\n    }\n    ```\n\n*/","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":22657,"byte_end":26022,"line_start":317,"line_end":475,"column_start":1,"column_end":3}}]},{"kind":"Mod","id":{"krate":0,"index":42},"span":{"file_name":"src/ch02/s2_lifetime.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"s2_lifetime","qualname":"::ch02::s2_lifetime","value":"src/ch02/s2_lifetime.rs","parent":null,"children":[{"krate":0,"index":43},{"krate":0,"index":44},{"krate":0,"index":45},{"krate":0,"index":46},{"krate":0,"index":47},{"krate":0,"index":48},{"krate":0,"index":49}],"decl_id":null,"docs":" ç¬¬äºŒç« ï¼šRustæ ¸å¿ƒæ¦‚å¿µ\n 2.2 ç”Ÿå‘½å‘¨æœŸä¸å€Ÿç”¨æ£€æŸ¥\n \n å€Ÿç”¨æ£€æŸ¥ç›¸å…³ä»£ç \n","sig":null,"attributes":[{"value":"/ ç¬¬äºŒç« ï¼šRustæ ¸å¿ƒæ¦‚å¿µ","span":{"file_name":"src/ch02/s2_lifetime.rs","byte_start":26083,"byte_end":26115,"line_start":1,"line_end":1,"column_start":1,"column_end":17}},{"value":"/ 2.2 ç”Ÿå‘½å‘¨æœŸä¸å€Ÿç”¨æ£€æŸ¥","span":{"file_name":"src/ch02/s2_lifetime.rs","byte_start":26116,"byte_end":26151,"line_start":2,"line_end":2,"column_start":1,"column_end":18}},{"value":"/ ","span":{"file_name":"src/ch02/s2_lifetime.rs","byte_start":26152,"byte_end":26156,"line_start":3,"line_end":3,"column_start":1,"column_end":5}},{"value":"/ å€Ÿç”¨æ£€æŸ¥ç›¸å…³ä»£ç ","span":{"file_name":"src/ch02/s2_lifetime.rs","byte_start":26157,"byte_end":26185,"line_start":4,"line_end":4,"column_start":1,"column_end":13}}]},{"kind":"Function","id":{"krate":0,"index":43},"span":{"file_name":"src/ch02/s2_lifetime.rs","byte_start":26474,"byte_end":26490,"line_start":22,"line_end":22,"column_start":8,"column_end":24},"name":"understand_scope","qualname":"::ch02::s2_lifetime::understand_scope","value":"pub fn understand_scope()","parent":null,"children":[],"decl_id":null,"docs":"    ### ç†è§£è¯æ³•ä½œç”¨åŸŸ","sig":null,"attributes":[{"value":"*\n    ### ç†è§£è¯æ³•ä½œç”¨åŸŸ\n\n    åŸºæœ¬æ•°æ®ç±»å‹ï¼š https://doc.rust-lang.org/std/index.html#primitives\n\n    ```\n    fn main(){\n        let mut v = vec![];\n        v.push(1);\n        {\n            println!(\"{:?}\", v[0]);\n            v.push(2);\n        }\n    }\n    ```\n*/","span":{"file_name":"src/ch02/s2_lifetime.rs","byte_start":26187,"byte_end":26466,"line_start":6,"line_end":21,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":44},"span":{"file_name":"src/ch02/s2_lifetime.rs","byte_start":27712,"byte_end":27726,"line_start":58,"line_end":58,"column_start":8,"column_end":22},"name":"understand_nll","qualname":"::ch02::s2_lifetime::understand_nll","value":"pub fn understand_nll()","parent":null,"children":[],"decl_id":null,"docs":"    ### ç†è§£å€Ÿç”¨æ£€æŸ¥ NLL","sig":null,"attributes":[{"value":"*\n    ### ç†è§£å€Ÿç”¨æ£€æŸ¥ NLL\n\n    ç¤ºä¾‹ï¼šæ›¿æ¢å­—ç¬¦ä¸²ä¸­çš„é—®å·\n\n    ```\n    fn main(){\n        let s = \"abc?d\";\n        let mut chars = s.chars().collect::<Vec<char>>();\n        \n        // å¤„ç†å­—ç¬¦ä¸²\n        for (i, c) in chars.iter_mut().enumerate() {\n            // å®šä¹‰ a-z å­—æ¯é›†\n            let mut words = ('a'..='z').into_iter();\n            // æ­¤å¤„ `chars[i]` æ˜¯å¯¹charsçš„ä¸å¯å˜å€Ÿç”¨\n            if chars[i] == '?' {\n                // æ­¤å¤„ `chars[i]` æ˜¯å¯¹charsçš„ä¸å¯å˜å€Ÿç”¨\n                let left = if i==0 {None} else { Some(chars[i-1]) };\n                // æ­¤å¤„ `chars[i]` æ˜¯å¯¹charsçš„ä¸å¯å˜å€Ÿç”¨\n                let right = if i==s.len()-1 {None} else {Some(chars[i+1])};\n                // æ­¤å¤„ `chars[i]` æ˜¯å¯¹charsçš„å¯å˜å€Ÿç”¨ï¼Œè¦ä¿®æ”¹charsæ•°ç»„äº†\n                // ä»a-z å­—æ¯é›†ä¸­æŸ¥æ‰¾å’Œå·¦å³ä¸¤è¾¹ä¸ä¸€æ ·çš„å­—æ¯å»æ›¿æ¢å½“å‰å­—ç¬¦ï¼Œé¿å…é‡å¤\n                chars[i] = words.find(|&w| Some(w) != left && Some(w) != right).unwrap();\n            }\n        }\n        \n        let s = chars.into_iter().collect::<String>();\n        println!(\"{:?}\", s);\n    }\n    ```\n*/","span":{"file_name":"src/ch02/s2_lifetime.rs","byte_start":26540,"byte_end":27704,"line_start":27,"line_end":57,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":45},"span":{"file_name":"src/ch02/s2_lifetime.rs","byte_start":29266,"byte_end":29285,"line_start":135,"line_end":135,"column_start":8,"column_end":27},"name":"understand_lifetime","qualname":"::ch02::s2_lifetime::understand_lifetime","value":"pub fn understand_lifetime()","parent":null,"children":[],"decl_id":null,"docs":"    ç†è§£æ™®é€šç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼š","sig":null,"attributes":[{"value":"*\n\n    ç†è§£æ™®é€šç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼š\n\n    è¯´æ˜ï¼š ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼šlate bound vs early bound\n\n    ç¤ºä¾‹1: \n\n    ```rust\n    fn return_str<'a>() -> &'a str {\n        let mut s = \"Rust\".to_string();\n        for i in 0..3 {\n            s.push_str(\"Good \");\n        }\n        &s[..]                   //\"Rust Good Good Good\"\n    }\n    fn main() {\n        let x = return_str();\n    }\n\n    ```\n\n    ç¤ºä¾‹2: \n\n    ```rust\n    fn foo<'a>(x: &'a str, y: &'a str) -> &'a str {\n        let result = String::from(\"really long string\");\n        // error\n        result.as_str()\n    }\n\n    fn main() {\n        let x = \"hello\";\n        let y = \"rust\";\n        foo(x, y);\n    }\n    ```\n\n    ç¤ºä¾‹3: \n\n    ```rust\n    fn the_longest(s1: &str, s2: &str) -> &str {\n        if s1.len() > s2.len() { s1 } else { s2 }\n    }\n    fn main() {\n        let s1 = String::from(\"Rust\");\n        let s1_r = &s1;\n        {\n            let s2 = String::from(\"C\");\n            let res = the_longest(s1_r, &s2);\n        println!(\"{} is the longest\", res);\n    }\n    \n    ```\n\n    ç¤ºä¾‹4: \n\n    ```rust\n    fn the_longest<'a>(s1: &'a str, s2: &'a str) -> &'a str {\n        if s1.len() > s2.len() { s1 } else { s2}\n    }\n    fn main() {\n        let s1 = String::from(\"Rust\");\n        let s1_r = &s1;\n        {\n            let s2 = String::from(\"C\");\n            let res = the_longest(s1_r, &s2);\n        println!(\"{} is the longest\", res); // Rust is the longest\n    }\n\n    ```\n*/","span":{"file_name":"src/ch02/s2_lifetime.rs","byte_start":27799,"byte_end":29258,"line_start":63,"line_end":134,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":46},"span":{"file_name":"src/ch02/s2_lifetime.rs","byte_start":30950,"byte_end":30986,"line_start":233,"line_end":233,"column_start":8,"column_end":44},"name":"understand_lifetime_early_late_bound","qualname":"::ch02::s2_lifetime::understand_lifetime_early_late_bound","value":"pub fn understand_lifetime_early_late_bound()","parent":null,"children":[],"decl_id":null,"docs":"è¯´æ˜ï¼š ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼šlate bound vs early bound ","sig":null,"attributes":[{"value":"*\n\nè¯´æ˜ï¼š ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼šlate bound vs early bound \n\nQuiz 11: [https://dtolnay.github.io/rust-quiz/11](https://dtolnay.github.io/rust-quiz/11)\n\n\n```rust\n\nfn f<'a>() {}\nfn g<'a: 'a>() {}\n\nfn main() {\n    let pf = f::<'static> as fn(); // late bound\n    let pg = g::<'static> as fn(); // early bound\n    print!(\"{}\", pf == pg);\n}\n\n```\n\n\nç¤ºä¾‹ä¸€ï¼šlate bound lifetime\n\n```rust\nstruct Buffer {\n    buf: Vec<u8>,\n    pos: usize,\n}\n\nimpl Buffer {\n    fn new() -> Buffer {\n        Buffer {\n            buf: vec![1,2,3, 4, 5,6],\n            pos: 0,\n        }\n    }\n\n    fn read_bytes<'a>(&'a mut self) -> &'a [u8] {\n        self.pos += 3;\n        &self.buf[self.pos-3..self.pos]\n    }\n}\n\nfn print(b1 :&[u8], b2: &[u8]) {\n    println!(\"{:#?} {:#?}\", b1, b2)\n}\n\nfn main() {\n    let mut buf = Buffer::new();\n    // let b1 = buf.read_bytes(); // don't work\n    let b1 = &(buf.read_bytes().to_owned());\n    let b2 = buf.read_bytes();\n    print(b1,b2)\n}\n```\n\nç¤ºä¾‹äºŒï¼š early bound lifetime\n\n```rust\nfn main() {\n    let v = vec![1,2,3, 4, 5,6];\n    let mut buf = Buffer::new(&v);\n    let b1 = buf.read_bytes();\n    // let b1 = &buf.read_bytes().to_owned();\n    let b2 = buf.read_bytes();\n    print(b1,b2)\n}\n\nfn print(b1 :&[u8], b2: &[u8]) {\n    println!(\"{:#?} {:#?}\", b1, b2)\n}\n\nstruct Buffer<'a> {\n    buf: &'a [u8],\n    pos: usize,\n}\n\nimpl<'b, 'a: 'b> Buffer<'a> {\n    fn new(b: &'a [u8]) -> Buffer {\n        Buffer {\n            buf: b,\n            pos: 0,\n        }\n    }\n\n    fn read_bytes(&'b mut self) -> &'a [u8] {\n        self.pos += 3;\n        &self.buf[self.pos-3..self.pos]\n    }\n}\n```\n*/","span":{"file_name":"src/ch02/s2_lifetime.rs","byte_start":29340,"byte_end":30942,"line_start":141,"line_end":232,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":47},"span":{"file_name":"src/ch02/s2_lifetime.rs","byte_start":31824,"byte_end":31855,"line_start":273,"line_end":273,"column_start":8,"column_end":39},"name":"understand_lifetime_for_closure","qualname":"::ch02::s2_lifetime::understand_lifetime_for_closure","value":"pub fn understand_lifetime_for_closure()","parent":null,"children":[],"decl_id":null,"docs":"    ### é—­åŒ… ä¸ é«˜é˜¶ç”Ÿå‘½å‘¨æœŸ","sig":null,"attributes":[{"value":"*\n\n    ### é—­åŒ… ä¸ é«˜é˜¶ç”Ÿå‘½å‘¨æœŸ\n\n    ```rust\n\n    fn main() {\n        let f = |x: &i32| x; // error\n        // å‡å¦‚æ”¯æŒä¸‹é¢çš„è¯­æ³•å°±æ–¹ä¾¿å¤šäº†ï¼Œç›®å‰è¿˜æœªæ”¯æŒ\n        // let f: for<'a> Fn(&'a i32) -> &'a i32 = |x| x; \n        let i = &3;\n        let j = f(i);\n    }\n\n    ```\n\n    ä¿®æ­£ï¼š\n\n    ç›¸å…³ï¼š[Explicit lifetime bounds RFC 0192](https://rust-lang.github.io/rfcs/0192-bounds-on-object-and-generic-types.html)\n    ```rust\n\n    // fn annotate<'a, T: 'a ,F>(f: F) -> F where F: Fn(&'a T) -> &'a T { f }\n\n    fn annotate<T,F>(f: F) -> F where for<'a> F: Fn(&'a T) -> &'a T { f }\n\n    fn main() {\n        let f = annotate(|x| x);\n        let i = &3;\n        let j = f(i);\n        assert_eq!(*j, 3);\n    }\n\n    ```\n*/","span":{"file_name":"src/ch02/s2_lifetime.rs","byte_start":31068,"byte_end":31816,"line_start":239,"line_end":272,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":48},"span":{"file_name":"src/ch02/s2_lifetime.rs","byte_start":34122,"byte_end":34157,"line_start":382,"line_end":382,"column_start":8,"column_end":43},"name":"understand_lifetime_in_generic_type","qualname":"::ch02::s2_lifetime::understand_lifetime_in_generic_type","value":"pub fn understand_lifetime_in_generic_type()","parent":null,"children":[],"decl_id":null,"docs":"    ### ç†è§£ T vs &T","sig":null,"attributes":[{"value":"*\n\n    ### ç†è§£ T vs &T\n\n    ```rust\n    use std::fmt::Debug;\n\n    #[derive(Debug)]\n    struct Ref<'a, T: 'a>(&'a T);\n\n    fn print<T>(t: T)\n    where\n        T: Debug,\n    {\n        println!(\"`print`: t is {:?}\", t);\n    }\n\n    fn print_ref<'a, T>(t: &'a T)\n    where\n    T: Debug + 'a,\n    {\n    println!(\"`print_ref`: t is {:?}\", t);\n    }\n\n    fn main() {\n        let x = 7;\n        let ref_x = Ref(&x);\n        print_ref(&ref_x);\n        print(ref_x);\n    }\n    ```\n\n    ç¤ºä¾‹ï¼šRust Quiz 5 ï¼š[https://zhuanlan.zhihu.com/p/51616607](https://zhuanlan.zhihu.com/p/51616607)\n\n    ä»¥ä¸‹ä»£ç è¾“å‡ºä»€ä¹ˆï¼Ÿ\n\n    ```rust\n    trait Trait {\n        fn f(self);\n    }\n\n    impl<T> Trait for fn(T) {\n        fn f(self) {\n            print!(\"1\");\n        }\n    }\n\n    impl<T> Trait for fn(&T) {\n        fn f(self) {\n            print!(\"2\");\n        }\n    }\n\n    fn main() {\n        let a: fn(_) = |_: u8| {};\n        let b: fn(_) = |_: &u8| {};\n        let c: fn(&_) = |_: &u8| {};\n        a.f();\n        b.f();\n        c.f();\n    }\n    ```\n\n    ç¤ºä¾‹ï¼šæ¥è‡ªäºç¤¾åŒº Potato TooLarge çš„æ¡ˆä¾‹ \n         \n    [https://zhuanlan.zhihu.com/p/194156624](https://zhuanlan.zhihu.com/p/194156624)\n\n    ```rust\n\n    // https://doc.rust-lang.org/std/collections/struct.HashSet.html\n\n    use std::collections::HashSet;\n\n    fn main() {\n        \n        let hello = \"hello\".to_owned();\n        let mut items = HashSet::new();\n        \n        items.insert(hello.as_str());\n        \n        let mut global_set = HashSet::new();\n        global_set.insert(hello.as_str());\n        \n        while !global_set.is_empty() {\n            let mut temp_set = HashSet::new();\n            \n            for &item in global_set.iter() {\n                let copy = item.to_owned();\n                let copy_str = copy.as_str();\n                \n                // copy_str <==> &copy  ===>  HashSet::get() \n                // &copy_str <==> &'x &'a copy \n\n                if let Some(inner) = items.get(copy_str).cloned() {\n                    temp_set.insert(inner);\n                };\n            };\n            std::mem::swap(&mut global_set, &mut temp_set);\n            break;\n        };\n    }\n    ```\n\n    \n*/","span":{"file_name":"src/ch02/s2_lifetime.rs","byte_start":31920,"byte_end":34114,"line_start":277,"line_end":381,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":49},"span":{"file_name":"src/ch02/s2_lifetime.rs","byte_start":37858,"byte_end":37882,"line_start":535,"line_end":535,"column_start":8,"column_end":32},"name":"understand_lifetime_hrtb","qualname":"::ch02::s2_lifetime::understand_lifetime_hrtb","value":"pub fn understand_lifetime_hrtb()","parent":null,"children":[],"decl_id":null,"docs":"    ç¤ºä¾‹ï¼š ç†è§£ traitå¯¹è±¡ä¸­çš„ç”Ÿå‘½å‘¨æœŸå‚æ•°","sig":null,"attributes":[{"value":"*\n\n    ç¤ºä¾‹ï¼š ç†è§£ traitå¯¹è±¡ä¸­çš„ç”Ÿå‘½å‘¨æœŸå‚æ•°\n\n    ```rust\n    trait Foo<'a> {}\n    struct FooImpl<'a> {\n        s: &'a [u32],\n    }\n    impl<'a> Foo<'a> for FooImpl<'a> {\n    }\n    // ä¸º traitå¯¹è±¡ å¢åŠ  'a ï¼Œå› ä¸º Box é»˜è®¤æ˜¯ static çš„ï¼Œè€ŒFooImpl ä¸­çš„ s åˆ™æ˜¯å¼•ç”¨\n    // è¡¨æ˜è¯¥traitå¯¹è±¡ï¼ˆç»“æ„ä½“å®ä¾‹ï¼‰ä¸å…¶ç»“æ„ä½“ä¸­çš„å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸæ˜¯ä¸€æ ·é•¿çš„ï¼ˆ<=ï¼‰\n    fn foo<'a>(s: &'a [u32]) -> Box<dyn Foo<'a> + 'a> {\n        Box::new(FooImpl { s: s })\n    }\n    fn main(){}\n    ```\n\n    ###  ç†è§£ HRTB (higher ranked trait bounds)\n\n    ç¤ºä¾‹ä¸€ï¼š \n\n    ```rust\n    use std::fmt::Debug;\n    trait DoSomething<T> {\n        fn do_sth(&self, value: T);\n    }\n    impl<'a, T: Debug> DoSomething<T> for &'a usize {\n        fn do_sth(&self, value: T) {\n            println!(\"{:?}\", value);\n        }\n    }\n    fn foo<'a>(b: Box<DoSomething<&'a usize>>) {\n        let s: usize = 10;\n        b.do_sth(&s) // error[E0597]: `s` does not live long enough\n    }\n    fn main(){\n        let x  = Box::new(&2usize);\n        foo(x);\n    }\n    ```\n\n    ä¿®æ­£ï¼šä½¿ç”¨ `for<'f>` æ”¹ä¸º late bound\n\n    ```rust\n\n    use std::fmt::Debug;\n    trait DoSomething<T> {\n        fn do_sth(&self, value: T);\n    }\n    impl<'a, T: Debug> DoSomething<T> for &'a usize {\n        fn do_sth(&self, value: T) {\n            println!(\"{:?}\", value);\n        }\n    }\n    fn bar(b: Box<for<'f> DoSomething<&'f usize>>) {\n        let s: usize = 10;\n        b.do_sth(&s);\n    }\n    fn main(){\n        let x  = Box::new(&2usize);\n        bar(x);\n    }\n    ```\n\n    ç¤ºä¾‹ 2:\n\n    ```rust\n    use rand;\n    use std::io::Read;\n\n    trait Checksum<R: Read> {\n        fn calc(&mut self, r: R) -> Vec<u8>;\n    }\n\n    struct Xor;\n\n    impl<R: Read> Checksum<R> for Xor {\n        fn calc(&mut self, mut r: R) -> Vec<u8> {\n            let mut res: u8 = 0;\n            let mut buf = [0u8; 8];\n            loop {\n                let read = r.read(&mut buf).unwrap();\n                if read == 0 {\n                    break;\n                }\n                for b in &buf[..read] {\n                    res ^= b;\n                }\n            }\n\n            vec![res]\n        }\n    }\n\n    struct Add;\n\n    impl<R: Read> Checksum<R> for Add {\n        fn calc(&mut self, mut r: R) -> Vec<u8> {\n            let mut res: u8 = 0;\n            let mut buf = [0u8; 8];\n            loop {\n                let read = r.read(&mut buf).unwrap();\n                if read == 0 {\n                    break;\n                }\n                for b in &buf[..read] {\n                    let tmp = res as u16 + *b as u16;\n                    res = tmp as u8;\n                }\n            }\n\n            vec![res]\n        }\n    }\n\n    fn main() {\n        let mut buf = [0u8; 8];\n        // error[E0308]: `if` and `else` have incompatible types\n        // ä¿®æ­£ï¼š\n        // step 1: Box<dyn Checksum<&[u8]>> è½¬ä¸º trait å¯¹è±¡\n        // step 2: Box<dyn for<'a> Checksum<&'a [u8]>> ä½¿ç”¨ for<'a> è½¬ä¸º late bound\n        let mut checker = if rand::random() {\n            println!(\"Initializing Xor Checksum\");\n            Box::new(Xor)\n        } else {\n            println!(\"Initializing Add Checksum\");\n            Box::new(Add)\n        };\n\n        let mut data = \"Sedm lumpu slohlo pumpu za uplnku\".as_bytes();\n        let mut i = 0;\n\n        loop {\n            let chunk_size = data.read(&mut buf).unwrap();\n            if chunk_size == 0 {\n                break;\n            }\n            let cs = checker.calc(&buf[..chunk_size]);\n            println!(\"Checksum {} is {:?}\", i, cs);\n            i += 1;\n        }\n    }\n    ```\n\n    \n\n*/","span":{"file_name":"src/ch02/s2_lifetime.rs","byte_start":34219,"byte_end":37850,"line_start":386,"line_end":534,"column_start":1,"column_end":3}}]},{"kind":"Mod","id":{"krate":0,"index":50},"span":{"file_name":"src/ch02/s3_thread_safe.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"s3_thread_safe","qualname":"::ch02::s3_thread_safe","value":"src/ch02/s3_thread_safe.rs","parent":null,"children":[{"krate":0,"index":51},{"krate":0,"index":52},{"krate":0,"index":53},{"krate":0,"index":54}],"decl_id":null,"docs":" ç¬¬äºŒç« ï¼šRustæ ¸å¿ƒæ¦‚å¿µ\n 2.3 Thread Safe\n","sig":null,"attributes":[{"value":"/ ç¬¬äºŒç« ï¼šRustæ ¸å¿ƒæ¦‚å¿µ","span":{"file_name":"src/ch02/s3_thread_safe.rs","byte_start":37969,"byte_end":38001,"line_start":1,"line_end":1,"column_start":1,"column_end":17}},{"value":"/ 2.3 Thread Safe","span":{"file_name":"src/ch02/s3_thread_safe.rs","byte_start":38002,"byte_end":38021,"line_start":2,"line_end":2,"column_start":1,"column_end":20}}]},{"kind":"Function","id":{"krate":0,"index":51},"span":{"file_name":"src/ch02/s3_thread_safe.rs","byte_start":39019,"byte_end":39042,"line_start":41,"line_end":41,"column_start":8,"column_end":31},"name":"understand_local_thread","qualname":"::ch02::s3_thread_safe::understand_local_thread","value":"pub fn understand_local_thread()","parent":null,"children":[],"decl_id":null,"docs":"    ### ç†è§£æœ¬åœ°çº¿ç¨‹ï¼Œç†è§£å¹¶å‘","sig":null,"attributes":[{"value":"*\n    ### ç†è§£æœ¬åœ°çº¿ç¨‹ï¼Œç†è§£å¹¶å‘\n\n    - å¹¶å‘ï¼šåŒæ—¶ã€Œåº”å¯¹ã€å¾ˆå¤šäº‹çš„èƒ½åŠ›\n    - å¹¶è¡Œï¼šåŒæ—¶ã€Œæ‰§è¡Œã€å¾ˆå¤šäº‹çš„èƒ½åŠ›\n\n    ç›¸å…³ç±»å‹ï¼š\n\n    - [Duration](https://doc.rust-lang.org/std/time/struct.Duration.html)\n    - [JoinHandle](https://doc.rust-lang.org/std/thread/struct.JoinHandle.html)\n\n    ```\n    use std::thread;\n\n    fn main() {\n        // Duration å®ç°äº† Copyã€Sendã€Sync\n        let duration = std::time::Duration::from_millis(3000);\n\n        println!(\"Main thread\");\n\n        let handle  = thread::spawn(move || {\n            println!(\"Sub thread 1\");\n\n            // æ³¨æ„ï¼šå®ƒçš„çˆ¶çº¿ç¨‹æ˜¯ä¸»çº¿ç¨‹ï¼Œè€Œä¸æ˜¯çº¿ç¨‹1\n            let handle2 = thread::spawn( move || {\n                println!(\"Sub thread 2\");\n                thread::sleep(duration);\n            });\n\n            handle2.join().unwrap();\n            thread::sleep(duration);\n        });\n\n        handle.join().unwrap();\n        thread::sleep(duration);\n    }\n*/","span":{"file_name":"src/ch02/s3_thread_safe.rs","byte_start":38023,"byte_end":39011,"line_start":4,"line_end":40,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":52},"span":{"file_name":"src/ch02/s3_thread_safe.rs","byte_start":41848,"byte_end":41872,"line_start":173,"line_end":173,"column_start":8,"column_end":32},"name":"understand_shared_thread","qualname":"::ch02::s3_thread_safe::understand_shared_thread","value":"pub fn understand_shared_thread()","parent":null,"children":[],"decl_id":null,"docs":"    ### çº¿ç¨‹é—´å…±äº«æ•°æ®","sig":null,"attributes":[{"value":"*\n    ### çº¿ç¨‹é—´å…±äº«æ•°æ®\n\n    [https://doc.rust-lang.org/std/time/struct.Duration.html](https://doc.rust-lang.org/std/time/struct.Duration.html)\n\n    ```\n    use std::thread;\n\n    fn main() {\n        let mut v = vec![1,2,3];\n        thread::spawn(move || {\n            v.push(4);\n        });\n        // Can no longer access `v` here.\n    }\n    ```\n\n    ```\n    // invalid\n    use std::thread;\n\n    fn main() {\n        let mut v = vec![1,2,3];\n        for i in 0..10 {\n            thread::spawn(move || {\n                v.push(i);\n            });\n        }\n    }\n    ```\n\n    å€Ÿç”¨æ£€æŸ¥é˜»æ­¢å¹¶å‘Bug\n\n    ```\n    // invalid \n    fn inner_func(vref: &mut Vec<u32>) {\n        std::thread::spawn(move || {\n        vref.push(3);\n        });\n    }\n\n    fn main() {\n        let mut v = vec![1,2,3];\n        inner_func(&mut v);\n    }\n    ```\n\n    `'static' ä¸ çº¿ç¨‹å®‰å…¨\n\n    Note: [æ›¾ç»çš„ thread::scoped ä¼šæ³„æ¼ JoinGuard æ‰€ä»¥è¢«åºŸå¼ƒ](https://github.com/rust-lang/rust/issues/24292)\n\n    ```\n    use std::fmt;\n    use std::time::Duration;\n    use std::thread;\n\n    struct Foo {\n        string: String,\n        v: Vec<f64>,\n    }\n\n    impl fmt::Display for Foo {\n        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n            write!(f, \"{}: {:?}\", self.string, self.v)\n        }\n    }\n\n    fn test<T: Send + Sync + fmt::Display + 'static >(val: T) {\n        thread::spawn(move || println!(\"{}\", val));\n    }\n\n    fn main() {\n        test(\"hello\");                // &'static str\n        test(String::from(\"hello\"));  // String\n        test(5);                      // i32\n        \n        // Arbitrary struct containing String and Vec<f64>\n        test(Foo {string: String::from(\"hi\"), v: vec![1.2, 2.3]});\n        thread::sleep(Duration::new(1, 0));\n    }\n    ```\n\n    ä½¿ç”¨ crossbeam::scope å…±äº«æ•°æ®\n\n    ```rust\n    use crossbeam; \n    use std::{thread, time::Duration};\n\n    fn main() {\n        let mut vec = vec![1, 2, 3, 4, 5];\n\n        crossbeam::scope(|scope| {\n            for e in &vec {\n                scope.spawn(move |_| {\n                    println!(\"{:?}\", e);\n                });\n            }\n        })\n        .expect(\"A child thread panicked\");\n\n        println!(\"{:?}\", vec);\n    }\n    ```\n\n    scope thread ä¿®æ”¹æ•°æ®\n\n    ```rust\n    use crossbeam; // 0.6.0\n    use std::{thread, time::Duration};\n\n    fn main() {\n        let mut vec = vec![1, 2, 3, 4, 5];\n\n        crossbeam::scope(|scope| {\n            for e in &mut vec {\n                scope.spawn(move |_| {\n                    thread::sleep(Duration::from_secs(1));\n                    *e += 1;\n                });\n            }\n        })\n        .expect(\"A child thread panicked\");\n\n        println!(\"{:?}\", vec);\n    }\n    ```\n*/","span":{"file_name":"src/ch02/s3_thread_safe.rs","byte_start":39089,"byte_end":41840,"line_start":46,"line_end":172,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":53},"span":{"file_name":"src/ch02/s3_thread_safe.rs","byte_start":42303,"byte_end":42333,"line_start":196,"line_end":196,"column_start":8,"column_end":38},"name":"understand_safed_shared_thread","qualname":"::ch02::s3_thread_safe::understand_safed_shared_thread","value":"pub fn understand_safed_shared_thread()","parent":null,"children":[],"decl_id":null,"docs":"    ### ä½¿ç”¨ Arc å’Œ Mutex å®‰å…¨å…±äº«æ•°æ®","sig":null,"attributes":[{"value":"*\n    ### ä½¿ç”¨ Arc å’Œ Mutex å®‰å…¨å…±äº«æ•°æ®\n\n    ```\n    use std::sync::{Arc, Mutex};\n    use std::thread;\n\n    fn main() {\n        let v = Arc::new(Mutex::new(vec![1,2,3]));\n\n        for i in 0..3 {\n            let cloned_v = v.clone();\n            thread::spawn(move || {\n                cloned_v.lock().unwrap().push(i);\n            });\n        }\n    }\n    ```\n*/","span":{"file_name":"src/ch02/s3_thread_safe.rs","byte_start":41921,"byte_end":42295,"line_start":177,"line_end":195,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":54},"span":{"file_name":"src/ch02/s3_thread_safe.rs","byte_start":86558,"byte_end":86588,"line_start":1241,"line_end":1241,"column_start":8,"column_end":38},"name":"understand_channel_and_condvar","qualname":"::ch02::s3_thread_safe::understand_channel_and_condvar","value":"pub fn understand_channel_and_condvar()","parent":null,"children":[],"decl_id":null,"docs":"    ### æ„å»ºã€Œæ— æ‚”ã€å¹¶å‘ç³»ç»Ÿ","sig":null,"attributes":[{"value":"*\n    ### æ„å»ºã€Œæ— æ‚”ã€å¹¶å‘ç³»ç»Ÿ\n\n    ä½¿ç”¨ channel å’Œ condvar ï¼š æ¨¡æ‹Ÿå¹¶è¡Œç»„ä»¶\n\n    - [parking_lot](https://github.com/Amanieu/parking_lot)\n    - [crossbeam](https://github.com/crossbeam-rs/crossbeam)\n\n    > 1. Rust ä¿è¯å®‰å…¨æ€§ä¸Šã€Œæ— ç•ã€ï¼Œä½†ä¸ä¿è¯å·¥ç¨‹æ€§ä¸Šçš„ã€Œæ— æ‚”ã€ã€‚\n    > 2. ä½† Rust æœ‰æä¾›å¸®åŠ©æˆ‘ä»¬å»ºç«‹ã€Œæ— æ‚”ã€å¹¶å‘çš„ã€Œå·¥å…·ã€ã€‚\n    > 3. é€šè¿‡è¿™äº›å·¥å…·ï¼Œç»“åˆä»å®é™…æ²‰æ·€å‡ºæ¥å¹¶å‘æ¨¡å‹çš„æœ€ä½³é»˜è®¤æ¨¡å¼ã€Œevent-loopã€æ¥å»ºç«‹å¥å£®çš„å¹¶å‘åº”ç”¨ã€‚\n    > 4. æ‹“å±•é˜…è¯»ï¼š\n    > [Rust concurrency patterns: regret-less concurrency](https://medium.com/@polyglot_factotum/rust-regret-less-concurrency-2238b9e53333)\n\n\n    ç¤ºä¾‹1: ç”¨ channel æ¨¡æ‹Ÿ event \n\n    ```text\n\n                    \n                                    +--------------+\n                                    | main thread  |      send work msg\n    +-----------------------------> |    ä¸» ç»„ ä»¶     |  +-------------+\n    |           receive result msg  |              |                  |\n    |                               +--------------+                  work1\n    |                                                                 |\n    |                       send result msg                           |\n    |              +-----------------------+                          work1\n    |              |                       |                          |\n    |              v                       |                          v\n    |        result channel                |                      work channel\n    |            +---+                     |                         +---+\n    |            |   |                     |                         |   |\n    |            +---+                     |                         +---+\n    |            |   |                     |                         |   |\n    |            +---+                 +---+----+                    +---+\n    |            |   |                 | worker |                    |   |\n    |            +---+                 | thread |                    +---+\n    |            |   |                 |   å¹¶    |                   |   |\n    |            +---+                 |   è¡Œ    |                   +---+\n    |            |   |                 |   ç»„    |                   |   |\n    |            +---+                 |   ä»¶    |                   +---+\n    |            |   |                 +----+---+                    |   |\n    |            +-+-+                      ^                        +-+-+\n    |              |                        |receive work msg          |\n    |              |                        |                          |\n    +--------------+                        +--------------------------+\n\n    ```\n\n    ä»£ç \n\n    ```\n    #[macro_use]\n    extern crate crossbeam_channel;\n    extern crate rayon;\n\n    use crossbeam_channel::unbounded;\n    use std::collections::HashMap;\n    use std::sync::{Arc, Condvar, Mutex};\n    // use parking_lot::{Mutex, Condvar};\n    // use std::sync::Arc;\n    use std::thread;\n\n    // æ­¤æ¶ˆæ¯ç”¨äºå‘é€åˆ°ä¸ã€Œä¸»ç»„ä»¶ã€å¹¶è¡Œè¿è¡Œçš„å…¶ä»–ç»„ä»¶ã€‚\n    enum WorkMsg {\n        Work(u8),\n        Exit,\n    }\n\n    // æ­¤æ¶ˆæ¯ç”¨äºä»å¹¶è¡Œè¿è¡Œçš„å…¶ä»–ç»„ä»¶ å‘é€å›ã€Œä¸»ç»„ä»¶ã€ã€‚\n    enum ResultMsg {\n        Result(u8),\n        Exited,\n    }\n\n    fn main() {\n        let (work_sender, work_receiver) = unbounded();\n        let (result_sender, result_receiver) = unbounded();\n\n        // ç”Ÿæˆå­çº¿ç¨‹ç”¨äºæ‰§è¡Œå¦ä¸€ä¸ªå¹¶è¡Œç»„ä»¶\n        let _ = thread::spawn(move || loop {\n            // æ¥æ”¶å¹¶å¤„ç†æ¶ˆæ¯ï¼Œç›´åˆ°æ”¶åˆ° exit æ¶ˆæ¯\n            match work_receiver.recv() {\n                Ok(WorkMsg::Work(num)) => {\n                    // æ‰§è¡Œä¸€äº›å·¥ä½œï¼Œå¹¶ä¸”å‘é€æ¶ˆæ¯ç»™ Result é˜Ÿåˆ—\n                    let _ = result_sender.send(ResultMsg::Result(num));\n                }\n                Ok(WorkMsg::Exit) => {\n                    // å‘é€ exit ç¡®è®¤æ¶ˆæ¯\n                    let _ = result_sender.send(ResultMsg::Exited);\n                    break;\n                }\n                _ => panic!(\"Error receiving a WorkMsg.\"),\n            }\n        });\n\n        let _ = work_sender.send(WorkMsg::Work(0));\n        let _ = work_sender.send(WorkMsg::Work(1));\n        let _ = work_sender.send(WorkMsg::Exit);\n\n        // workeræ‰§è¡Œè®¡æ•°\n        let mut counter = 0;\n\n        loop {\n            match result_receiver.recv() {\n                Ok(ResultMsg::Result(num)) => {\n                    // æ–­è¨€ç¡®ä¿æ¥æ”¶å’Œå‘é€çš„é¡ºåºæ˜¯ä¸€è‡´çš„\n                    assert_eq!(num, counter);\n                    counter += 1;\n                }\n                Ok(ResultMsg::Exited) => {\n                    // æ–­è¨€ç¡®ä¿åœ¨æ¥æ”¶ä¸¤æ¡å·¥ä½œæ¶ˆæ¯ä¹‹åæ”¶åˆ°é€€å‡ºæ¶ˆæ¯\n                    assert_eq!(2, counter);\n                    break;\n                }\n                _ => panic!(\"Error receiving a ResultMsg.\"),\n            }\n        }\n    }\n    ```\n\n    ç¤ºä¾‹äºŒï¼šå¼•å…¥çº¿ç¨‹æ± ï¼Œå·¥ä½œçš„é¡ºåºå°†æ— æ³•ç¡®å®š\n\n    ```text\n                                    +--------------+\n                                    | main thread  |      send work msg\n    +-----------------------------> |    ä¸» ç»„ ä»¶   |  +---------------+\n    |           receive result msg  |              |                  |\n    |                               +--------------+                  work1\n    |                                                                 |\n    |                       send result msg                           |\n    |              +-----------------------+                          work0\n    |              |                       |                          |\n    |              v                       |                          v\n    |        result channel       +--------+------+               work channel\n    |            +---+            |               |                  +---+\n    |            |   |            |               |                  |   |\n    |            +---+       +----+---+      +----+----+             +---+\n    |            |   |       | worker |      |  worker |             |   |\n    |            +---+       | thread |thread|  thread |             +---+\n    |            |   |       |   å¹¶    | pool|    å¹¶    |             |   |\n    |            +---+       |   è¡Œ    |     |    è¡Œ    |             +---+\n    |            |   |       |   ç»„    |     |    ç»„    |             |   |\n    |            +---+       |   ä»¶    |     |    ä»¶    |             +---+\n    |            |   |       +----+---+      +-----+---+             |   |\n    |            +---+            ^                ^                 +---+\n    |            |   |            |                |                 |   |\n    |            +-+-+            +receive-work-msg+                 +-+-+\n    |              |                        |                          |\n    |              |                        |                          |\n    +--------------+                        +--------------------------+\n\n    ```\n\n    ä»£ç ï¼š\n\n    ```rust\n    #[macro_use]\n    extern crate crossbeam_channel;\n    extern crate rayon;\n\n    use crossbeam_channel::unbounded;\n    use std::collections::HashMap;\n    // use std::sync::{Arc, Condvar, Mutex};\n\n    use parking_lot::{Condvar, Mutex};\n    use std::sync::Arc;\n    use std::thread;\n\n    enum WorkMsg {\n        Work(u8),\n        Exit,\n    }\n\n    enum ResultMsg {\n        Result(u8),\n        Exited,\n    }\n\n    fn main() {\n        let (work_sender, work_receiver) = unbounded();\n        let (result_sender, result_receiver) = unbounded();\n        // å¼•å…¥çº¿ç¨‹æ± ï¼Œå¼€ä¸¤ä¸ªå·¥ä½œçº¿ç¨‹\n        let pool = rayon::ThreadPoolBuilder::new()\n            .num_threads(2)\n            .build()\n            .unwrap();\n\n        let _ = thread::spawn(move || loop {\n            match work_receiver.recv() {\n                Ok(WorkMsg::Work(num)) => {\n                    let result_sender = result_sender.clone();\n                    // ä½¿ç”¨çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹\n                    pool.spawn(move || {\n                        // æ‰§è¡Œä¸€äº›å·¥ä½œï¼Œå¹¶ä¸”å‘é€æ¶ˆæ¯ç»™ Result é˜Ÿåˆ—\n                        let _ = result_sender.send(ResultMsg::Result(num));\n                    });\n                }\n                Ok(WorkMsg::Exit) => {\n                    let _ = result_sender.send(ResultMsg::Exited);\n                    break;\n                }\n                _ => panic!(\"Error receiving a WorkMsg.\"),\n            }\n        });\n\n        let _ = work_sender.send(WorkMsg::Work(0));\n        let _ = work_sender.send(WorkMsg::Work(1));\n        let _ = work_sender.send(WorkMsg::Exit);\n\n        loop {\n            match result_receiver.recv() {\n                Ok(ResultMsg::Result(_)) => {\n                    // ä¸èƒ½å†æ–­è¨€é¡ºåºäº†\n                }\n                Ok(ResultMsg::Exited) => {\n                    // ä¹Ÿä¸èƒ½æ–­è¨€åœ¨é€€å‡ºæ¶ˆæ¯ä¹‹å‰å·²ç»æ”¶åˆ°äº†ç»“æœ\n                    break;\n                }\n                _ => panic!(\"Error receiving a ResultMsg.\"),\n            }\n        }\n    }\n    ```\n\n    ç¤ºä¾‹3: ç¡®ä¿å·¥ä½œç»“æŸå†é€€å‡º\n\n    ```text\n\n                                        +--------------+\n                                        | main thread  |      send work msg\n        +-----------------------------> |    ä¸» ç»„ ä»¶   |  +--------------------------+\n        |           receive result msg  |              |                             +\n        |                               +--------------+                             work1\n        |                                                                            |\n        |                       send result msg                                      |\n        |              +-----------------------+                                     work0\n        |              |                       |                                     |\n        |              v                       |                                     v\n        |        result channel       +--------+-------------------------+       work channel\n        |            +---+            |              thread              |          +---+\n        |            |   |            |               pool               |          |   |\n        |            +---+       +----+---+                         +----+----+     +---+\n        |            |   |       | worker |                         |  worker |     |   |\n        |            +---+       | thread |     pool_res_channel    |  thread |     +---+\n        |            |   |       |   å¹¶   +-------------------------+    å¹¶    |     |   |\n        |            +---+       |   è¡Œ    send msg when job finished     è¡Œ   |     +---+\n        |            |   |       |   ç»„   +-------------------------+    ç»„    |     |   |\n        |            +---+       |   ä»¶   |                         |    ä»¶    |     +---+\n        |            |   |       +----+---+                         +-----+---+     |   |\n        |            +---+            ^                                   ^         +---+\n        |            |   |            |                                   |         |   |\n        |            +-+-+            +receive-work-msg+------------------+         +-+-+\n        |              |                        |                                     |\n        |              |                        |                                     |\n        +--------------+                        +-------------------------------------+\n\n\n\n    ```\n\n    ä»£ç ï¼š\n\n    ```rust\n    #[macro_use]\n    extern crate crossbeam_channel;\n    extern crate rayon;\n\n    use crossbeam_channel::unbounded;\n    use std::collections::HashMap;\n    // use std::sync::{Arc, Condvar, Mutex};\n\n    use parking_lot::{Condvar, Mutex};\n    use std::sync::Arc;\n    use std::thread;\n\n    enum WorkMsg {\n        Work(u8),\n        Exit,\n    }\n\n    enum ResultMsg {\n        Result(u8),\n        Exited,\n    }\n\n    fn main() {\n        let (work_sender, work_receiver) = unbounded();\n        let (result_sender, result_receiver) = unbounded();\n        // æ·»åŠ ä¸€ä¸ªæ–°çš„Channelï¼ŒWorkerä½¿ç”¨å®ƒæ¥é€šçŸ¥â€œå¹¶è¡Œâ€ç»„ä»¶å·²ç»å®Œæˆäº†ä¸€ä¸ªå·¥ä½œå•å…ƒ\n        let (pool_result_sender, pool_result_receiver) = unbounded();\n        let mut ongoing_work = 0;\n        let mut exiting = false;\n        // ä½¿ç”¨çº¿ç¨‹æ± \n        let pool = rayon::ThreadPoolBuilder::new()\n            .num_threads(2)\n            .build()\n            .unwrap();\n\n        let _ = thread::spawn(move || loop {\n            // ä½¿ç”¨ corssbeam æä¾›çš„ select! å® é€‰æ‹©ä¸€ä¸ªå°±ç»ªå·¥ä½œ\n            select! {\n                recv(work_receiver) -> msg => {\n                    match msg {\n                        Ok(WorkMsg::Work(num)) => {\n                            let result_sender = result_sender.clone();\n                            let pool_result_sender = pool_result_sender.clone();\n\n                            // æ³¨æ„ï¼Œè¿™é‡Œæ­£åœ¨æ± ä¸Šå¯åŠ¨ä¸€ä¸ªæ–°çš„å·¥ä½œå•å…ƒã€‚\n                            ongoing_work += 1;\n\n                            pool.spawn(move || {\n                                // 1. å‘é€ç»“æœç»™ã€Œä¸»ç»„ä»¶ã€\n                                let _ = result_sender.send(ResultMsg::Result(num));\n\n                                // 2. è®©å¹¶è¡Œç»„ä»¶çŸ¥é“è¿™é‡Œå®Œæˆäº†ä¸€ä¸ªå·¥ä½œå•å…ƒ\n                                let _ = pool_result_sender.send(());\n                            });\n                        },\n                        Ok(WorkMsg::Exit) => {\n                            // Næ³¨æ„ï¼Œè¿™é‡Œæ¥æ”¶è¯·æ±‚å¹¶é€€å‡º\n                            exiting = true;\n\n                            // å¦‚æœæ²¡æœ‰æ­£åˆ™è¿›è¡Œçš„å·¥ä½œåˆ™ç«‹å³é€€å‡º\n                            if ongoing_work == 0 {\n                                let _ = result_sender.send(ResultMsg::Exited);\n                                break;\n                            }\n                        },\n                        _ => panic!(\"Error receiving a WorkMsg.\"),\n                    }\n                },\n                recv(pool_result_receiver) -> _ => {\n                    if ongoing_work == 0 {\n                        panic!(\"Received an unexpected pool result.\");\n                    }\n\n                    // æ³¨æ„ï¼Œä¸€ä¸ªå·¥ä½œå•å…ƒå·²ç»è¢«å®Œæˆ\n                    ongoing_work -=1;\n\n                    // å¦‚æœæ²¡æœ‰æ­£åœ¨è¿›è¡Œçš„å·¥ä½œï¼Œå¹¶ä¸”æ¥æ”¶åˆ°äº†é€€å‡ºè¯·æ±‚ï¼Œé‚£ä¹ˆå°±é€€å‡º\n                    if ongoing_work == 0 && exiting {\n                        let _ = result_sender.send(ResultMsg::Exited);\n                        break;\n                    }\n                },\n            }\n        });\n\n        let _ = work_sender.send(WorkMsg::Work(0));\n        let _ = work_sender.send(WorkMsg::Work(1));\n        let _ = work_sender.send(WorkMsg::Exit);\n\n        let mut counter = 0;\n\n        loop {\n            match result_receiver.recv() {\n                Ok(ResultMsg::Result(_)) => {\n                    // è®¡æ•°å½“å‰å®Œæˆçš„å·¥ä½œå•å…ƒ\n                    counter += 1;\n                }\n                Ok(ResultMsg::Exited) => {\n                    // æ–­è¨€æ£€æµ‹ï¼šæ˜¯åœ¨æ¥æ”¶åˆ°ä¸¤ä¸ªè¯·æ±‚ä»¥åé€€å‡ºçš„\n                    assert_eq!(2, counter);\n                    break;\n                }\n                _ => panic!(\"Error receiving a ResultMsg.\"),\n            }\n        }\n    }\n    ```\n\n    ç¤ºä¾‹3 é‡æ„\n\n    ```rust\n    #[macro_use]\n    extern crate crossbeam_channel;\n    extern crate rayon;\n\n    use crossbeam_channel::unbounded;\n    use std::collections::HashMap;\n    // use std::sync::{Arc, Condvar, Mutex};\n\n    use parking_lot::{Condvar, Mutex};\n    use std::sync::Arc;\n    use std::thread;\n\n    enum WorkMsg {\n        Work(u8),\n        Exit,\n    }\n\n    enum ResultMsg {\n        Result(u8),\n        Exited,\n    }\n\n    struct WorkerState {\n        ongoing: i16,\n        exiting: bool,\n    }\n\n    impl WorkerState {\n        fn init() -> Self {\n            WorkerState{ ongoing: 0, exiting: false }\n        }\n        \n        fn set_ongoing(&mut self, count: i16) {\n            self.ongoing += count;\n        }\n        \n        fn set_exiting(&mut self, exit_state: bool) {\n            self.exiting = exit_state;\n        }\n        \n        fn is_exiting(&self) -> bool {\n            self.exiting == true\n        }\n        \n        fn is_nomore_work(&self)-> bool {\n            self.ongoing == 0\n        }\n        \n    }\n\n    fn main() {\n        let (work_sender, work_receiver) = unbounded();\n        let (result_sender, result_receiver) = unbounded();\n        // æ·»åŠ ä¸€ä¸ªæ–°çš„Channelï¼ŒWorkerä½¿ç”¨å®ƒæ¥é€šçŸ¥â€œå¹¶è¡Œâ€ç»„ä»¶å·²ç»å®Œæˆäº†ä¸€ä¸ªå·¥ä½œå•å…ƒ\n        let (pool_result_sender, pool_result_receiver) = unbounded();\n        let mut worker_state = WorkerState::init();\n        \n        // ä½¿ç”¨çº¿ç¨‹æ± \n        let pool = rayon::ThreadPoolBuilder::new()\n            .num_threads(2)\n            .build()\n            .unwrap();\n\n        let _ = thread::spawn(move || loop {\n            // ä½¿ç”¨ corssbeam æä¾›çš„ select! å® é€‰æ‹©ä¸€ä¸ªå°±ç»ªå·¥ä½œ\n            select! {\n                recv(work_receiver) -> msg => {\n                    match msg {\n                        Ok(WorkMsg::Work(num)) => {\n                            let result_sender = result_sender.clone();\n                            let pool_result_sender = pool_result_sender.clone();\n\n                            // æ³¨æ„ï¼Œè¿™é‡Œæ­£åœ¨æ± ä¸Šå¯åŠ¨ä¸€ä¸ªæ–°çš„å·¥ä½œå•å…ƒã€‚\n                            worker_state.set_ongoing(1);\n\n                            pool.spawn(move || {\n                                // 1. å‘é€ç»“æœç»™ã€Œä¸»ç»„ä»¶ã€\n                                result_sender.send(ResultMsg::Result(num));\n\n                                // 2. è®©å¹¶è¡Œç»„ä»¶çŸ¥é“è¿™é‡Œå®Œæˆäº†ä¸€ä¸ªå·¥ä½œå•å…ƒ\n                                pool_result_sender.send(());\n                            });\n                        },\n                        Ok(WorkMsg::Exit) => {\n                            // Næ³¨æ„ï¼Œè¿™é‡Œæ¥æ”¶è¯·æ±‚å¹¶é€€å‡º\n                            // exiting = true;\n                            worker_state.set_exiting(true);\n\n                            // å¦‚æœæ²¡æœ‰æ­£åˆ™è¿›è¡Œçš„å·¥ä½œåˆ™ç«‹å³é€€å‡º\n                            if worker_state.is_nomore_work() {\n                                result_sender.send(ResultMsg::Exited);\n                                break;\n                            }\n                        },\n                        _ => panic!(\"Error receiving a WorkMsg.\"),\n                    }\n                },\n                recv(pool_result_receiver) -> _ => {\n                    if worker_state.is_nomore_work() {\n                        panic!(\"Received an unexpected pool result.\");\n                    }\n\n                    // æ³¨æ„ï¼Œä¸€ä¸ªå·¥ä½œå•å…ƒå·²ç»è¢«å®Œæˆ\n                    worker_state.set_ongoing(-1);\n\n                    // å¦‚æœæ²¡æœ‰æ­£åœ¨è¿›è¡Œçš„å·¥ä½œï¼Œå¹¶ä¸”æ¥æ”¶åˆ°äº†é€€å‡ºè¯·æ±‚ï¼Œé‚£ä¹ˆå°±é€€å‡º\n                    if worker_state.is_nomore_work() && worker_state.is_exiting() {\n                        result_sender.send(ResultMsg::Exited);\n                        break;\n                    }\n                },\n            }\n        });\n\n        work_sender.send(WorkMsg::Work(0));\n        work_sender.send(WorkMsg::Work(1));\n        work_sender.send(WorkMsg::Exit);\n\n        let mut counter = 0;\n\n        loop {\n            match result_receiver.recv() {\n                Ok(ResultMsg::Result(_)) => {\n                    // è®¡æ•°å½“å‰å®Œæˆçš„å·¥ä½œå•å…ƒ\n                    counter += 1;\n                }\n                Ok(ResultMsg::Exited) => {\n                    // æ–­è¨€æ£€æµ‹ï¼šæ˜¯åœ¨æ¥æ”¶åˆ°ä¸¤ä¸ªè¯·æ±‚ä»¥åé€€å‡ºçš„\n                    assert_eq!(2, counter);\n                    break;\n                }\n                _ => panic!(\"Error receiving a ResultMsg.\"),\n            }\n        }\n    }\n    ```\n\n    ç¤ºä¾‹4: ä½¿ç”¨ç¼“å­˜å…±äº«æ•°æ®\n\n    ```text\n                                        +--------------+\n                                        | main thread  |      send work msg\n        +-----------------------------> |    ä¸» ç»„ ä»¶   |  +--------------------------+\n        |           receive result msg  |              |                             +\n        |                               +--------------+                             work1\n        |                                                                            |\n        |                       send result msg                                      |\n        |              +------------------------+                                    work0\n        |              |                        |                                    +\n        |              v                        |                                    |\n        |        result channel                 |                                    |\n        |            +---+            +---------+------------------------+           |\n        |            |   |            |              thread              |           |\n        |            +---+            |               pool               |           |\n        |            |   |       +----+---+                         +----+----+      |\n        |            +---+       | worker |                         |  worker |      |\n        |            |   |       | thread |                         |  thread |      |\n        |            +---+       |        |                         |         |      |\n        |            |   |       |        |                         |         |      +\n        |            +---+       |        |                         |         |  work channel\n        |            |   |       |        |get +--------------+  get|         |     +---+\n        |            +---+       |        +--->+  work cache  +<----+         |     |   |\n        |            |   |       |        |    +--------------+     |         |     +---+\n        |            +-+-+       |        |                         |         |     |   |\n        |              |         |        |     pool_res_channel    |         |     +---+\n        |              |         |   å¹¶    +-------------------------+    å¹¶   |     |   |\n        +--------------+         |   è¡Œ    send msg when job finished     è¡Œ   |     +---+\n                                 |   ç»„    +-------------------------+    ç»„    |    |   |\n                                 |   ä»¶    |                         |    ä»¶    |    +---+\n                                 +----+---+                         +-----+---+     |   |\n                                      ^                                   ^         +---+\n                                      |                                   |         |   |\n                                      +receive-work-msg+------------------+         +-+-+\n                                                |                                     |\n                                                |                                     |\n                                                +-------------------------------------+\n\n\n    ```\n\n    ä»£ç ï¼š\n\n    ```rust\n    #[macro_use]\n    extern crate crossbeam_channel;\n    extern crate rayon;\n\n    use crossbeam_channel::unbounded;\n    use std::collections::HashMap;\n    use std::sync::{Arc, Condvar, Mutex};\n\n    // use parking_lot::{Condvar, Mutex};\n    // use std::sync::Arc;\n    use std::thread;\n\n    enum WorkMsg {\n        Work(u8),\n        Exit,\n    }\n\n    enum ResultMsg {\n        Result(u8, WorkPerformed),\n        Exited,\n    }\n\n    struct WorkerState {\n        ongoing: i16,\n        exiting: bool,\n    }\n\n    impl WorkerState {\n        fn init() -> Self {\n            WorkerState{ ongoing: 0, exiting: false }\n        }\n        \n        fn set_ongoing(&mut self, count: i16) {\n            self.ongoing += count;\n        }\n        \n        fn set_exiting(&mut self, exit_state: bool) {\n            self.exiting = exit_state;\n        }\n        \n        fn is_exiting(&self) -> bool {\n            self.exiting == true\n        }\n        \n        fn is_nomore_work(&self)-> bool {\n            self.ongoing == 0\n        }\n    }\n\n    #[derive(Debug, Eq, PartialEq)]\n    enum WorkPerformed {\n        FromCache,\n        New,\n    }\n\n    #[derive(Eq, Hash, PartialEq)]\n    struct CacheKey(u8);\n\n    fn main() {\n        let (work_sender, work_receiver) = unbounded();\n        let (result_sender, result_receiver) = unbounded();\n        // æ·»åŠ ä¸€ä¸ªæ–°çš„Channelï¼ŒWorkerä½¿ç”¨å®ƒæ¥é€šçŸ¥â€œå¹¶è¡Œâ€ç»„ä»¶å·²ç»å®Œæˆäº†ä¸€ä¸ªå·¥ä½œå•å…ƒ\n        let (pool_result_sender, pool_result_receiver) = unbounded();\n        let mut worker_state = WorkerState::init();\n        \n        // ä½¿ç”¨çº¿ç¨‹æ± \n        let pool = rayon::ThreadPoolBuilder::new()\n            .num_threads(2)\n            .build()\n            .unwrap();\n            \n        // ç¼“å­˜ work ï¼Œç”± æ±  ä¸­çš„ worker å…±äº«\n        let cache: Arc<Mutex<HashMap<CacheKey, u8>>> = Arc::new(Mutex::new(HashMap::new()));\n\n        let _ = thread::spawn(move || loop {\n            // ä½¿ç”¨ corssbeam æä¾›çš„ select! å® é€‰æ‹©ä¸€ä¸ªå°±ç»ªå·¥ä½œ\n            select! {\n                recv(work_receiver) -> msg => {\n                    match msg {\n                        Ok(WorkMsg::Work(num)) => {\n                            let result_sender = result_sender.clone();\n                            let pool_result_sender = pool_result_sender.clone();\n                            // ä½¿ç”¨ç¼“å­˜\n                            let cache = cache.clone();\n\n                            // æ³¨æ„ï¼Œè¿™é‡Œæ­£åœ¨æ± ä¸Šå¯åŠ¨ä¸€ä¸ªæ–°çš„å·¥ä½œå•å…ƒã€‚\n                            worker_state.set_ongoing(1);\n\n                            pool.spawn(move || {\n                                let num = {\n                                    // ç¼“å­˜å¼€å§‹\n                                    let cache = cache.lock().unwrap();\n                                    let key = CacheKey(num);\n                                    if let Some(result) = cache.get(&key) {\n                                        // ä»ç¼“å­˜ä¸­è·å¾—ä¸€ä¸ªç»“æœï¼Œå¹¶å°†å…¶å‘é€å›å»ï¼Œ\n                                        // åŒæ—¶å¸¦æœ‰ä¸€ä¸ªæ ‡å¿—ï¼Œè¡¨æ˜æ˜¯ä»ç¼“å­˜ä¸­è·å¾—äº†å®ƒ\n                                        let _ = result_sender.send(ResultMsg::Result(result.clone(), WorkPerformed::FromCache));\n                                        let _ = pool_result_sender.send(());\n                                        return;\n                                    }\n                                    key.0\n                                    // ç¼“å­˜ç»“æŸ\n                                };\n\n                                // work work work work work work...\n\n                                // è¿”å›ç»“æœï¼Œè¡¨æ˜æˆ‘ä»¬å¿…é¡»æ‰§è¡Œwork\n                                let _ = result_sender.send(ResultMsg::Result(num.clone(), WorkPerformed::New));\n\n                                // åœ¨ç¼“å­˜ä¸­å­˜å‚¨â€œæ˜‚è´µâ€çš„work.\n                                let mut cache = cache.lock().unwrap();\n                                let key = CacheKey(num.clone());\n                                cache.insert(key, num);\n\n                                let _ = pool_result_sender.send(());\n                            });\n                        },\n                        Ok(WorkMsg::Exit) => {\n                            // Næ³¨æ„ï¼Œè¿™é‡Œæ¥æ”¶è¯·æ±‚å¹¶é€€å‡º\n                            // exiting = true;\n                            worker_state.set_exiting(true);\n\n                            // å¦‚æœæ²¡æœ‰æ­£åˆ™è¿›è¡Œçš„å·¥ä½œåˆ™ç«‹å³é€€å‡º\n                            if worker_state.is_nomore_work() {\n                                result_sender.send(ResultMsg::Exited);\n                                break;\n                            }\n                        },\n                        _ => panic!(\"Error receiving a WorkMsg.\"),\n                    }\n                },\n                recv(pool_result_receiver) -> _ => {\n                    if worker_state.is_nomore_work() {\n                        panic!(\"Received an unexpected pool result.\");\n                    }\n\n                    // æ³¨æ„ï¼Œä¸€ä¸ªå·¥ä½œå•å…ƒå·²ç»è¢«å®Œæˆ\n                    worker_state.set_ongoing(-1);\n\n                    // å¦‚æœæ²¡æœ‰æ­£åœ¨è¿›è¡Œçš„å·¥ä½œï¼Œå¹¶ä¸”æ¥æ”¶åˆ°äº†é€€å‡ºè¯·æ±‚ï¼Œé‚£ä¹ˆå°±é€€å‡º\n                    if worker_state.is_nomore_work() && worker_state.is_exiting() {\n                        result_sender.send(ResultMsg::Exited);\n                        break;\n                    }\n                },\n            }\n        });\n\n        let _ = work_sender.send(WorkMsg::Work(0));\n        // å‘é€ä¸¤ä¸ªç›¸åŒçš„work\n        let _ = work_sender.send(WorkMsg::Work(1));\n        let _ = work_sender.send(WorkMsg::Work(1));\n        let _ = work_sender.send(WorkMsg::Exit);\n\n        let mut counter = 0;\n\n        loop {\n            match result_receiver.recv() {\n                Ok(ResultMsg::Result(_, _cached)) => {\n                    // è®¡æ•°å½“å‰å®Œæˆçš„å·¥ä½œå•å…ƒ\n                    counter += 1;\n                }\n                Ok(ResultMsg::Exited) => {\n                    // æ–­è¨€æ£€æµ‹ï¼šæ˜¯åœ¨æ¥æ”¶åˆ°ä¸¤ä¸ªè¯·æ±‚ä»¥åé€€å‡ºçš„\n                    assert_eq!(3, counter);\n                    break;\n                }\n                _ => panic!(\"Error receiving a ResultMsg.\"),\n            }\n        }\n    }\n    ```\n\n    ç¤ºä¾‹5: ç¡®ä¿ä»ç¼“å­˜ä¸­å–å…±äº«æ•°æ®çš„è¡Œä¸ºæ˜¯ç¡®å®šçš„\n\n    ```text\n                                        +--------------+\n                                        | main thread  |      send work msg\n        +-----------------------------> |    ä¸» ç»„ ä»¶   |  +----------------------------------+\n        |           receive result msg  |              |                                     +\n        |                               +--------------+                                     work1\n        |                                                                                    |\n        |                       send result msg                                              |\n        |              +------------------------+                                            work0\n        |              |                        |                                            +\n        |              v                        |          thread                            |\n        |        result channel                 |           pool                             |\n        |            +---+            |---------+--------------------------------|           |\n        |            |   |       +--------+   wait    +------------+  wait  +---------+      |\n        |            +---+       | worker +<----------+  inproces  +------->+  worker |      |\n        |            |   |       | thread |       +----            ---+     |  thread |      |\n        |            +---+       |        |  +--->+ work cache state  +<--+ |         |      |\n        |            |   |       |        |  |    +-----+        +----+   | |         |      |\n        |            +---+       |        +--+          |  ready |        +-+         |      |\n        |            |   |       |        |      notify +----+---++  notify |         |      +\n        |            +---+       |        | <-----------+    |    +-------->+         |  work channel\n        |            |   |       |        |                  v              |         |     +---+\n        |            +---+       |        |         +--------+-----+        |         |     |   |\n        |            |   |       |        |         |  work cache  |        |         |     +---+\n        |            +-+-+       |        |         +--------------+        |         |     |   |\n        |              |         |        |     pool_res_channel            |         |     +---+\n        |              |         |   å¹¶    +---------------------------------+    å¹¶   |     |   |\n        +--------------+         |   è¡Œ        send msg when job finished         è¡Œ   |     +---+\n                                 |   ç»„    +---------------------------------+    ç»„   |     |   |\n                                 |   ä»¶    |                                 |    ä»¶   |     +---+\n                                 +----+---+                                  +-----+---+    |   |\n                                      ^                                           ^         +---+\n                                      |                                           |         |   |\n                                      +receive-work-msg+--------------------------+         +-+-+\n                                                |                                             |\n                                                |                                             |\n                                                +---------------------------------------------+\n\n    ```\n\n    ä»£ç ï¼š\n\n    ```\n    #[macro_use]\n    extern crate crossbeam_channel;\n    extern crate rayon;\n\n    use crossbeam_channel::unbounded;\n    use std::collections::HashMap;\n    use std::sync::{Arc, Condvar, Mutex};\n\n    // use parking_lot::{Condvar, Mutex};\n    // use std::sync::Arc;\n    use std::thread;\n\n    enum WorkMsg {\n        Work(u8),\n        Exit,\n    }\n\n    #[derive(Debug, Eq, PartialEq)]\n    enum CacheState {\n        Ready,\n        WorkInProgress,\n    }\n\n    enum ResultMsg {\n        Result(u8, WorkPerformed),\n        Exited,\n    }\n\n    struct WorkerState {\n        ongoing: i16,\n        exiting: bool,\n    }\n\n    impl WorkerState {\n        fn init() -> Self {\n            WorkerState{ ongoing: 0, exiting: false }\n        }\n            \n        fn set_ongoing(&mut self, count: i16) {\n            self.ongoing += count;\n        }\n            \n        fn set_exiting(&mut self, exit_state: bool) {\n            self.exiting = exit_state;\n        }\n            \n        fn is_exiting(&self) -> bool {\n            self.exiting == true\n        }\n            \n        fn is_nomore_work(&self)-> bool {\n            self.ongoing == 0\n        }\n    }\n\n    #[derive(Debug, Eq, PartialEq)]\n    enum WorkPerformed {\n        FromCache,\n        New,\n    }\n\n    #[derive(Eq, Hash, PartialEq)]\n    struct CacheKey(u8);\n\n    fn main() {\n        let (work_sender, work_receiver) = unbounded();\n        let (result_sender, result_receiver) = unbounded();\n        // æ·»åŠ ä¸€ä¸ªæ–°çš„Channelï¼ŒWorkerä½¿ç”¨å®ƒæ¥é€šçŸ¥â€œå¹¶è¡Œâ€ç»„ä»¶å·²ç»å®Œæˆäº†ä¸€ä¸ªå·¥ä½œå•å…ƒ\n        let (pool_result_sender, pool_result_receiver) = unbounded();\n        let mut worker_state = WorkerState::init();\n            \n        // ä½¿ç”¨çº¿ç¨‹æ± \n        let pool = rayon::ThreadPoolBuilder::new()\n            .num_threads(2)\n            .build()\n            .unwrap();\n                \n        // ç¼“å­˜ work ï¼Œç”± æ±  ä¸­çš„ worker å…±äº«\n        let cache: Arc<Mutex<HashMap<CacheKey, u8>>> = Arc::new(Mutex::new(HashMap::new()));\n\n        // å¢åŠ ç¼“å­˜çŠ¶æ€ï¼ŒæŒ‡ç¤ºå¯¹äºç»™å®šçš„keyï¼Œç¼“å­˜æ˜¯å¦å·²ç»å‡†å¤‡å¥½è¢«è¯»å–ã€‚\n        let cache_state: Arc<Mutex<HashMap<CacheKey, Arc<(Mutex<CacheState>, Condvar)>>>> =\n            Arc::new(Mutex::new(HashMap::new()));\n            \n        let _ = thread::spawn(move || loop {\n            // ä½¿ç”¨ corssbeam æä¾›çš„ select! å® é€‰æ‹©ä¸€ä¸ªå°±ç»ªå·¥ä½œ\n            select! {\n                recv(work_receiver) -> msg => {\n                    match msg {\n                        Ok(WorkMsg::Work(num)) => {\n                            let result_sender = result_sender.clone();\n                            let pool_result_sender = pool_result_sender.clone();\n                            // ä½¿ç”¨ç¼“å­˜\n                            let cache = cache.clone();\n                            let cache_state = cache_state.clone();\n\n                            // æ³¨æ„ï¼Œè¿™é‡Œæ­£åœ¨æ± ä¸Šå¯åŠ¨ä¸€ä¸ªæ–°çš„å·¥ä½œå•å…ƒã€‚\n                            worker_state.set_ongoing(1);\n\n                            pool.spawn(move || {\n                                let num = {\n                                    let (cache_state_lock, cvar) = {\n                                        //  `cache_state` ä¸´ç•ŒåŒºå¼€å§‹\n                                        let mut state_map = cache_state.lock().unwrap();\n                                        &*state_map\n                                            .entry(CacheKey(num.clone()))\n                                            .or_insert_with(|| {\n                                                Arc::new((\n                                                    Mutex::new(CacheState::Ready),\n                                                    Condvar::new(),\n                                                ))\n                                            })\n                                            .clone()\n                                        //  `cache_state` ä¸´ç•ŒåŒºç»“æŸ\n                                    };\n\n                                    //  `state` ä¸´ç•ŒåŒºå¼€å§‹\n                                    let mut state = cache_state_lock.lock().unwrap();\n\n                                    // æ³¨æ„ï¼šä½¿ç”¨whileå¾ªç¯æ¥é˜²æ­¢æ¡ä»¶å˜é‡çš„è™šå‡å”¤é†’\n                                    while let CacheState::WorkInProgress = *state {\n                                        // é˜»å¡ç›´åˆ°çŠ¶æ€æ˜¯ `CacheState::Ready`.\n                                        //\n                                        // å½“å”¤é†’æ—¶ä¼šè‡ªåŠ¨é‡Šæ”¾é”\n                                        let current_state = cvar\n                                            .wait(state)\n                                            .unwrap();\n                                        state = current_state;\n                                    }\n\n                                    // å¾ªç¯å¤–å¯ä»¥è®¤ä¸ºstate å·²ç»æ˜¯ Ready çš„äº†\n                                    assert_eq!(*state, CacheState::Ready);\n\n                                    let (num, result) = {\n                                        // ç¼“å­˜ä¸´ç•ŒåŒºå¼€å§‹\n                                        let cache = cache.lock().unwrap();\n                                        let key = CacheKey(num);\n                                        let result = match cache.get(&key) {\n                                            Some(result) => Some(result.clone()),\n                                            None => None,\n                                        };\n                                        (key.0, result)\n                                        // ç¼“å­˜ä¸´ç•ŒåŒºç»“æŸ\n                                    };\n\n                                    if let Some(result) = result {\n                                        // ä»ç¼“å­˜ä¸­è·å¾—ä¸€ä¸ªç»“æœï¼Œå¹¶å°†å…¶å‘é€å›å»ï¼Œ\n                                        // åŒæ—¶å¸¦æœ‰ä¸€ä¸ªæ ‡å¿—ï¼Œè¡¨æ˜æ˜¯ä»ç¼“å­˜ä¸­è·å¾—äº†å®ƒ\n                                        let _ = result_sender.send(ResultMsg::Result(result, WorkPerformed::FromCache));\n                                        let _ = pool_result_sender.send(());\n\n                                        // ä¸è¦å¿˜è®°é€šçŸ¥ç­‰å¾…çº¿ç¨‹\n                                        cvar.notify_one();\n                                        return;\n                                    } else {\n                                        // å¦‚æœç¼“å­˜é‡Œæ²¡æœ‰æ‰¾åˆ°ç»“æœï¼Œé‚£ä¹ˆåˆ‡æ¢çŠ¶æ€\n                                        *state = CacheState::WorkInProgress;\n                                        num\n                                    }\n                                    // `state` ä¸´ç•ŒåŒºç»“æŸ\n                                };\n\n                                // åœ¨ä¸´ç•ŒåŒºå¤–åšæ›´å¤šã€Œæ˜‚è´µå·¥ä½œã€\n\n                                let _ = result_sender.send(ResultMsg::Result(num.clone(), WorkPerformed::New));\n\n                                {\n                                    // ç¼“å­˜ä¸´ç•ŒåŒºå¼€å§‹\n                                    // æ’å…¥å·¥ä½œç»“æœåˆ°ç¼“å­˜ä¸­\n                                    let mut cache = cache.lock().unwrap();\n                                    let key = CacheKey(num.clone());\n                                    cache.insert(key, num);\n                                    // ç¼“å­˜ä¸´ç•ŒåŒºç»“æŸ\n                                }\n\n                                let (lock, cvar) = {\n                                    let mut state_map = cache_state.lock().unwrap();\n                                    &*state_map\n                                        .get_mut(&CacheKey(num))\n                                        .expect(\"Entry in cache state to have been previously inserted\")\n                                        .clone()\n                                };\n                                // é‡æ–°è¿›å…¥ `state` ä¸´ç•ŒåŒº\n                                let mut state = lock.lock().unwrap();\n\n                                // åœ¨è¿™é‡Œï¼Œç”±äºå·²ç»æå‰è®¾ç½®äº†stateï¼Œå¹¶ä¸”ä»»ä½•å…¶ä»–workeréƒ½å°†ç­‰å¾…çŠ¶æ€åˆ‡æ¢å›readyï¼Œå¯ä»¥ç¡®å®šè¯¥çŠ¶æ€æ˜¯â€œin-progressâ€ã€‚\n                                assert_eq!(*state, CacheState::WorkInProgress);\n\n                                // åˆ‡æ¢çŠ¶æ€ä¸º Ready\n                                *state = CacheState::Ready;\n\n                                // é€šçŸ¥ç­‰å¾…çº¿ç¨‹\n                                cvar.notify_one();\n\n                                let _ = pool_result_sender.send(());\n                            });\n                        },\n                        Ok(WorkMsg::Exit) => {\n                            // Næ³¨æ„ï¼Œè¿™é‡Œæ¥æ”¶è¯·æ±‚å¹¶é€€å‡º\n                            // exiting = true;\n                            worker_state.set_exiting(true);\n\n                            // å¦‚æœæ²¡æœ‰æ­£åˆ™è¿›è¡Œçš„å·¥ä½œåˆ™ç«‹å³é€€å‡º\n                            if worker_state.is_nomore_work() {\n                                result_sender.send(ResultMsg::Exited);\n                                break;\n                            }\n                        },\n                        _ => panic!(\"Error receiving a WorkMsg.\"),\n                    }\n                },\n                recv(pool_result_receiver) -> _ => {\n                    if worker_state.is_nomore_work() {\n                        panic!(\"Received an unexpected pool result.\");\n                    }\n\n                    // æ³¨æ„ï¼Œä¸€ä¸ªå·¥ä½œå•å…ƒå·²ç»è¢«å®Œæˆ\n                    worker_state.set_ongoing(-1);\n\n                    // å¦‚æœæ²¡æœ‰æ­£åœ¨è¿›è¡Œçš„å·¥ä½œï¼Œå¹¶ä¸”æ¥æ”¶åˆ°äº†é€€å‡ºè¯·æ±‚ï¼Œé‚£ä¹ˆå°±é€€å‡º\n                    if worker_state.is_nomore_work() && worker_state.is_exiting() {\n                        result_sender.send(ResultMsg::Exited);\n                        break;\n                    }\n                },\n            }\n        });\n\n        let _ = work_sender.send(WorkMsg::Work(0));\n        // å‘é€ä¸¤ä¸ªç›¸åŒçš„work\n        let _ = work_sender.send(WorkMsg::Work(1));\n        let _ = work_sender.send(WorkMsg::Work(1));\n        let _ = work_sender.send(WorkMsg::Exit);\n\n        let mut counter = 0;\n        \n        // å½“work æ˜¯ 1 çš„æ—¶å€™é‡æ–°è®¡æ•°\n        let mut work_one_counter = 0;\n\n        loop {\n            match result_receiver.recv() {\n                Ok(ResultMsg::Result(num, cached)) => {\n                    counter += 1;\n\n                    if num == 1 {\n                        work_one_counter += 1;\n                    }\n\n                    // ç°åœ¨æˆ‘ä»¬å¯ä»¥æ–­è¨€ï¼Œå½“æ”¶åˆ° num ä¸º 1 çš„ç¬¬äºŒä¸ªç»“æœæ—¶ï¼Œå®ƒå·²ç»æ¥è‡ªç¼“å­˜ã€‚\n                    if num == 1 && work_one_counter == 2 {\n                        assert_eq!(cached, WorkPerformed::FromCache);\n                    }\n                }\n                Ok(ResultMsg::Exited) => {\n                    assert_eq!(3, counter);\n                    break;\n                }\n                _ => panic!(\"Error receiving a ResultMsg.\"),\n            }\n        }\n    }\n    ```\n*/","span":{"file_name":"src/ch02/s3_thread_safe.rs","byte_start":42389,"byte_end":86550,"line_start":201,"line_end":1240,"column_start":1,"column_end":3}}]},{"kind":"Mod","id":{"krate":0,"index":55},"span":{"file_name":"src/ch02/s4_lockfree.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"s4_lockfree","qualname":"::ch02::s4_lockfree","value":"src/ch02/s4_lockfree.rs","parent":null,"children":[{"krate":0,"index":56}],"decl_id":null,"docs":" ç¬¬äºŒç« ï¼šRustæ ¸å¿ƒæ¦‚å¿µ\n 2.3 Lockfree\n \n","sig":null,"attributes":[{"value":"/ ç¬¬äºŒç« ï¼šRustæ ¸å¿ƒæ¦‚å¿µ","span":{"file_name":"src/ch02/s4_lockfree.rs","byte_start":86645,"byte_end":86677,"line_start":1,"line_end":1,"column_start":1,"column_end":17}},{"value":"/ 2.3 Lockfree","span":{"file_name":"src/ch02/s4_lockfree.rs","byte_start":86678,"byte_end":86694,"line_start":2,"line_end":2,"column_start":1,"column_end":17}},{"value":"/ ","span":{"file_name":"src/ch02/s4_lockfree.rs","byte_start":86695,"byte_end":86699,"line_start":3,"line_end":3,"column_start":1,"column_end":5}}]},{"kind":"Function","id":{"krate":0,"index":56},"span":{"file_name":"src/ch02/s4_lockfree.rs","byte_start":98551,"byte_end":98568,"line_start":279,"line_end":279,"column_start":8,"column_end":25},"name":"memory_reordering","qualname":"::ch02::s4_lockfree::memory_reordering","value":"pub fn memory_reordering()","parent":null,"children":[],"decl_id":null,"docs":"    ### å¹¶å‘ç¼–ç¨‹æ³¨é‡çš„ä¸‰ç‚¹ï¼š","sig":null,"attributes":[{"value":"*\n \n    ### å¹¶å‘ç¼–ç¨‹æ³¨é‡çš„ä¸‰ç‚¹ï¼š\n\n    1. åŸå­æ€§ã€‚ä¿è¯æ“ä½œæ˜¯åŸå­çš„ã€‚\n    2. å¯è§æ€§ã€‚ä¿è¯æ•°æ®æ˜¯åŒæ­¥çš„ã€‚\n    3. é¡ºåºæ€§ã€‚ä¿è¯æ“ä½œçš„é¡ºåºæ˜¯æ­£ç¡®çš„ã€‚\n\n    æ–¹æ³•ï¼š\n\n    - åŒæ­¥é”\n    - æ— é”ç¼–ç¨‹\n\n\n    ### æ€è€ƒï¼šé”å¸¦æ¥çš„é—®é¢˜ï¼Ÿ\n\n    1. æ€§èƒ½ã€‚å¼•å…¥æ— é”ç¼–ç¨‹å¯ä»¥æœ€å¤§åŒ–å‡å°‘çº¿ç¨‹ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Œçº¿ç¨‹ç­‰å¾…ã€‚\n    2. æ­»é”ã€‚å¼•å…¥æ— é”ç¼–ç¨‹å°±ä¸ä¼šäº§ç”Ÿæ­»é”ã€‚\n\n    æ— é”ç¼–ç¨‹æ€§èƒ½å¹¶ä¸æ˜¯æ€»æ˜¯ä¼˜äºé”åŒæ­¥ã€‚\n\n    æ— é”ç¼–ç¨‹ä¾èµ–äºåŸå­ç±»å‹ï¼Œä½¿ç”¨åŸå­ç±»å‹è¿˜éœ€è¦æ·±å…¥äº†è§£ä¸€äº›æ¦‚å¿µã€‚\n\n\n    ###  ç†è§£æ— é”å¹¶å‘çš„å…³é”®åœ¨äºç†è§£è®¡ç®—æœºç»„æˆ\n \n    ```text\n    +------+    +------+    +------+\n    | core |    | core |    | core |\n    +---+--+    +---+--+    +---+--+\n        |           |           |\n    +lv1+--+    +-lv1--+    +lv1---+\n    |cache |    |cache |    | cache|\n    +---+--+    +---+--+    +---+--+\n        |           |           |\n    +lv2---+    +lv2---+    +lv2---+\n    | cache|    | cache|    | cache|\n    +---+--+    +---+--+    +---+--+\n        |           |           |\n        +-----------------------+\n                    |\n    +---------------+--------------+\n    |           lv3 cache          |\n    +---------------+--------------+\n                    |\n                    |\n    +---------------+--------------+\n    |          main memory         |\n    +------------------------------+\n\n    ```\n\n    ### ç¼“å­˜ä¸€è‡´æ€§é—®é¢˜\n\n    æ€è€ƒï¼šä¸‹é¢ä»£ç æœ€ç»ˆæ‰§è¡Œå x å’Œ y çš„çŠ¶æ€ä¸Šä»€ä¹ˆï¼Ÿ\n\n    ``` text\n    // THREAD 1                       \n\n    if unsafe { *x == 1 } {\n        unsafe { *y += 1 }\n    }                   \n    \n    // THREAD 2\n    unsafe {\n        *y = 10;\n        *x = 1;\n    }\n    ```\n\n    æœ€ç»ˆç»“æœå®é™…å–å†³äºä¸‹é¢å‡ ä¸ªé—®é¢˜ï¼š\n\n    1. THREAD 1 å’Œ THREAD 2 è¿è¡Œé¡ºåºæ˜¯ä»€ä¹ˆï¼Ÿ ï¼ˆä½¿ç”¨é”åŒæ­¥å¯ä»¥ä¿è¯â€œå–‚ç»™â€ CPU çš„æŒ‡ä»¤é”æœ‰é¡ºåºæ€§çš„ï¼‰\n    2. æ¯ä¸€ä¸ª CPU ä½¿ç”¨çš„é«˜é€Ÿç¼“å­˜çš„çŠ¶æ€ ï¼ˆè¦ä¿è¯ç¼“å­˜ä¸€è‡´æ€§ï¼‰\n    3. CPU æŒ‡ä»¤é‡æ’ï¼ˆä¹±åºæ‰§è¡Œï¼Œä¸ºäº†æ›´å¥½çš„åˆ©ç”¨æµæ°´çº¿ï¼Œè¾¾åˆ°æ€§èƒ½æè‡´ï¼‰\n    4. ç¼–è¯‘å™¨æŒ‡ä»¤é‡æ’ ï¼ˆè°ƒæ•´æŒ‡ä»¤é¡ºåºï¼Œä½¿å…¶å¯¹ CPU æ›´å‹å¥½ï¼‰\n\n\n    > é«˜é€Ÿç¼“å­˜é€šè¿‡ M(Modified)E(Exclusive)S(Shared)I(Invalid) åè®®æ¥ä¿æŒåŒæ­¥ã€‚MESIçš„æœ‰è¶£ä¹‹å¤„åœ¨äºï¼Œæ¯ä¸ªé«˜é€Ÿç¼“å­˜è¡Œéƒ½åœ¨ç»´æŠ¤è‡ªå·±çš„å†…å­˜åœ°å€çŠ¶æ€æœºã€‚\n    > ä¸€ä¸ª CPU é€šè¿‡ IPC (Inter-Processor-Communication) å‘ å¦ä¸€ä¸ª CPU æ¥å‘é€æ¶ˆæ¯ï¼Œæ¯”å¦‚ï¼Œã€Œç‹¬å å†…å­˜åœ°å€ã€ã€ã€Œä¿®æ”¹å†…å­˜æ•°æ®ã€ç­‰ã€‚\n    > è¿™é‡Œè¦æ³¨æ„ï¼ŒCPU å¹¶ä¸æ˜¯åšæ¥æŸäº›æ“ä½œé©¬ä¸Šå‘å‡ºæ¶ˆæ¯æˆ–è€…æ˜¯æ”¶åˆ°æ¶ˆæ¯é©¬ä¸Šå°±æ‰§è¡Œç›¸åº”æ“ä½œçš„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼ŒCPU é€šä¿¡çš„è¿™äº›æ¶ˆæ¯éƒ½æ˜¯å¼‚æ­¥çš„ã€‚\n    > å¦‚æœ CPU å¤šæ ¸ä¹‹é—´ç”¨åŒæ­¥é€šä¿¡çš„è¯ï¼Œæ€§èƒ½ä¸Šæ— æ³•æ¥å—ã€‚æ¯”å¦‚ä¸€ä¸ª CPU è¦ç­‰å¾…å…¶ä»– CPU æ¥ç¡®è®¤ä¿¡æ¯ï¼Œæˆ–ä»å…¶ä»– CPU è·å–æœ€æ–°æ•°æ®ç­‰ã€‚\n    > æ‰€ä»¥ï¼Œä¸ºäº†è®© CPU æ ¸ä¹‹é—´å¯ä»¥é«˜æ€§èƒ½åœ°åŒæ­¥ä¿¡æ¯ï¼ˆä¿è¯cpuä¹±åºæ‰§è¡ŒæŒ‡ä»¤çš„åŒæ—¶ï¼Œè¿˜è¦ä¿è¯ç¨‹åºæ­£ç¡®æ€§ï¼‰ï¼Œå°±å¼•å…¥äº†å†…å­˜å±éšœçš„æŠ€æœ¯ã€‚\n    \n\n    ### å†…å­˜å±éšœ\n    \n    å†…å­˜å±éšœå…è®¸å¼€å‘è€…åœ¨ç¼–å†™ä»£ç ç­‰æ—¶å€™åœ¨éœ€è¦ç­‰åœ°æ–¹åŠ å…¥å®ƒã€‚\n\n    å†…å­˜å±éšœåˆ†ä¸ºï¼š\n\n    1. è¯»å±éšœï¼ˆLoad Memory Barrierï¼‰ã€‚ä»»ä½•ã€Œè¯»å±éšœã€å‰çš„ã€Œè¯»æ“ä½œã€éƒ½ä¼šå…ˆäºã€Œè¯»å±éšœã€åçš„ã€Œè¯»æ“ä½œã€å®Œæˆã€‚\n    2. å†™å±éšœï¼ˆStore Memory Barrierï¼‰ã€‚ä»»ä½•ã€Œå†™å±éšœã€å‰çš„ã€Œå†™æ“ä½œã€éƒ½ä¼šå…ˆäºã€Œå†™å±éšœã€åçš„ã€Œå†™æ“ä½œã€å®Œæˆã€‚\n    3. å…¨å±éšœã€‚åŒæ—¶åŒ…å«è¯»å±éšœå’Œå†™å±éšœçš„ä½œç”¨ã€‚\n\n    loadï¼Œä»£è¡¨ä»å†…å­˜è¯»æ•°æ®ã€‚storeï¼Œä»£è¡¨å‘å†…å­˜å†™æ•°æ®ã€‚\n\n    ç°ä»£ CPU æ¶æ„ä¸­ä¸€èˆ¬åˆ†ä¸ºå››ç§å†…å­˜å±éšœï¼š\n\n    1. Load-Load: ç­‰ä»·äºä¸Šé¢ä»‹ç»çš„ã€Œè¯»å±éšœã€ã€‚ä»»ä½•ã€Œè¯¥å±éšœã€å‰çš„ã€Œè¯»æ“ä½œã€éƒ½ä¼šå…ˆäºã€Œè¯¥å±éšœã€åçš„ã€Œè¯»æ“ä½œã€å®Œæˆã€‚\n    2. Load-Store: ä»»ä½•ã€Œè¯¥å±éšœã€å‰çš„ã€Œè¯»æ“ä½œã€éƒ½ä¼šå…ˆäºã€Œè¯¥å±éšœåã€çš„ã€Œå†™æ“ä½œã€å®Œæˆã€‚\n    3. Store-Load: ä»»ä½•ã€Œè¯¥å±éšœã€å‰çš„ã€Œå†™æ“ä½œã€éƒ½ä¼šå…ˆäºã€Œè¯¥å±éšœåã€çš„ã€Œè¯»æ“ä½œã€å®Œæˆã€‚\n    4. Store-Store: ç­‰ä»·äºä¸Šé¢ä»‹ç»çš„ã€Œå†™å±éšœã€ã€‚ä»»ä½•ã€Œè¯¥å±éšœã€å‰çš„ã€Œå†™æ“ä½œã€éƒ½ä¼šå…ˆäºã€Œè¯¥å±éšœã€åçš„ã€Œå†™æ“ä½œã€å®Œæˆã€‚\n\n\n    å¼€å‘è€…é€šè¿‡å†…å­˜å±éšœï¼Œå‘Šè¯‰ CPU/ç¼–è¯‘å™¨ å†…å­˜å±éšœå‰åæŒ‡ä»¤çš„é¡ºåºå…³ç³»ï¼Œè¿™æ · CPU/ç¼–è¯‘å™¨ å°±ä¸ä¼šé‡æ’è¿™äº›æŒ‡ä»¤ï¼Œä»è€Œä¿è¯åŸå­æŒ‡ä»¤çš„é¡ºåºæ€§ã€‚\n\n    ### å†…å­˜æ¨¡å‹\n\n    è¿™ä¹ˆå¤šå†…å­˜å±éšœï¼Œä»€ä¹ˆæ—¶å€™è¯¥ä½¿ç”¨å“ªç§ï¼Œéœ€è¦ç”±å¼€å‘è€…æ¥æŒ‡å®šã€‚è¿™é“ç†å’Œ Unsafe Rust ç±»ä¼¼ï¼Œç¼–è¯‘å™¨æ— æ³•æ£€æŸ¥çš„å®‰å…¨æ€§ï¼Œäº¤ç»™å¼€å‘è€…ã€‚\n\n    è¿™å°±æ˜¯è¯­è¨€æä¾›å†…å­˜æ¨¡å‹çš„åŸå› ã€‚Cpp å’Œ Rust è¯­è¨€éƒ½æä¾›äº†åŸå­ï¼ˆAtomicï¼‰ç±»å‹ï¼Œå¹¶ä¸”è¿™äº›åŸå­ç±»å‹éƒ½æ˜¯å¯ä»¥æŒ‡å®šå†…å­˜é¡ºåºï¼ˆå‘Šè¯‰CPUä½¿ç”¨å“ªç§å†…å­˜å±éšœï¼‰\n\n    Rust ç›®å‰å¹¶æ²¡æœ‰æ­£å¼çš„å†…å­˜é¡ºåºæ¨¡å‹ï¼Œä½†æ˜¯å®ƒåœ¨è¯­ä¹‰å’Œè¡Œä¸ºä¸Šå’Œ Cpp ä¸€è‡´ã€‚\n\n    ç”±æ­¤å¼•ç”³å‡ºå†…å­˜å±éšœéƒ½ä¸¤ç§è¯­ä¹‰ï¼š\n\n    1. acquireï¼ˆè·å–ï¼‰è¯­ä¹‰ã€‚Load ä¹‹åçš„è¯»å†™æ“ä½œæ— æ³•è¢«é‡æ’è‡³ Load ä¹‹å‰ã€‚å³ ç›¸å½“äºLoad-Loadå’ŒLoad-Storeå±éšœã€‚\n    2. releaseï¼ˆé‡Šæ”¾ï¼‰è¯­ä¹‰ã€‚Store ä¹‹å‰çš„è¯»å†™æ“ä½œæ— æ³•è¢«é‡æ’è‡³ Store ä¹‹åã€‚å³ ç›¸å½“äºLoad-Storeå’ŒStore-Storeå±éšœã€‚\n\n\n    ### åŸå­æ“ä½œ\n\n    Rust æ ‡å‡†åº“ä¸­å®šä¹‰çš„åŸå­ç±»å‹ï¼š[std::sync::atomic: https://doc.rust-lang.org/stable/std/sync/atomic/index.html](https://doc.rust-lang.org/stable/std/sync/atomic/index.html)\n    å…¶ä¸­`// std::sync::atomic::Ordering`å®šä¹‰äº† Rust æ”¯æŒçš„å†…å­˜é¡ºåºï¼Œå®˜æ–¹æ–‡æ¡£æŒ‡å‡ºï¼Œå½“å‰å’Œ Cpp20 çš„å†…å­˜é¡ºåºæ˜¯ä¸€è‡´çš„ã€‚\n    \n\n    ```rust\n    // std::sync::atomic::Ordering\n\n    pub enum Ordering {\n        Relaxed,\n        Release,\n        Acquire,\n        AcqRel,\n        SeqCst,\n    }\n    ```\n\n    æ³¨æ„ï¼ŒRust å½“å‰å¹¶æ²¡æœ‰å…¬å¼€ cpp é‡Œé¢åŒ…å«å¯¹ consume è¯­ä¹‰ã€‚\n\n    å†…å­˜é¡ºåºè¯´æ˜ï¼š\n\n    - Relaxedï¼Œè¡¨ç¤ºåŸå­ç±»å‹åªä¿è¯åŸå­æ“ä½œå³å¯ï¼Œæ²¡æœ‰å†…å­˜é¡ºåºï¼ˆä¸æŒ‡å®šå†…å­˜å±éšœï¼‰\n    - Releaseï¼Œ\n        - è¡¨ç¤ºä½¿ç”¨ Release è¯­ä¹‰ã€‚\n        - å½“å‰çº¿ç¨‹å†…çš„æ‰€æœ‰å†™æ“ä½œï¼Œå¯¹äºå…¶ä»–å¯¹è¿™ä¸ªåŸå­å˜é‡è¿›è¡Œ acquire çš„çº¿ç¨‹å¯è§\n    - Acquireï¼Œ\n        - è¡¨ç¤ºä½¿ç”¨ Acquire è¯­ä¹‰ã€‚\n        - acquire å¯ä»¥ä¿è¯è¯»åˆ°æ‰€æœ‰åœ¨ release å‰å‘ç”Ÿçš„å†™å…¥ã€‚\n    - AcqRelï¼Œ\n        - è¡¨ç¤ºå¯¹è¯»å–å’Œå†™å…¥æ–½åŠ  acquire-release è¯­ä¹‰ï¼Œæ— æ³•è¢«é‡æ’ã€‚\n        - å¯ä»¥çœ‹è§å…¶ä»–çº¿ç¨‹æ–½åŠ  release è¯­ä¹‰çš„æ‰€æœ‰å†™å…¥ï¼ŒåŒæ—¶è‡ªå·±çš„ release ç»“æŸåæ‰€æœ‰å†™å…¥å¯¹å…¶ä»–æ–½åŠ  acquire è¯­ä¹‰çš„çº¿ç¨‹å¯è§ã€‚\n    - SeqCstï¼Œ\n        - å¦‚æœæ˜¯è¯»å–å°±æ˜¯ acquire è¯­ä¹‰ï¼Œå¦‚æœæ˜¯å†™å…¥å°±æ˜¯ release è¯­ä¹‰ï¼Œå¦‚æœæ˜¯è¯»å–+å†™å…¥å°±æ˜¯ acquire-release è¯­ä¹‰ã€‚\n        - æ‰€æœ‰çº¿ç¨‹éƒ½èƒ½ä»¥ç›¸åŒçš„é¡ºåºçœ‹åˆ°æ‰€æœ‰é¡ºåºä¸€è‡´çš„æ“ä½œã€‚\n    \n    ä¸åŒå¯¹å†…å­˜é¡ºåºï¼Œå¯¹åº”ä¸åŒå¯¹å†…å­˜å±éšœï¼Œè¿›ä¸€æ­¥ï¼Œä¹Ÿä»£è¡¨äº†ä¸åŒçš„æ€§èƒ½ã€‚\n    åœ¨ç«äº‰æ¡ä»¶æ¯”è¾ƒæ¿€çƒˆçš„æƒ…å†µä¸‹ï¼ŒRelaxed æ€§èƒ½æ˜¯æœ€å¥½çš„ï¼Œå› ä¸ºå®ƒä¸éœ€è¦ä»»ä½•å†…å­˜å±éšœï¼Œè¿™å°±æ„å‘³ç€CPUä¹‹é—´ä¸éœ€è¦è¿›è¡Œä¸€è‡´æ€§åŒæ­¥ã€‚\n    ç›¸å¯¹è€Œè¨€ï¼ŒSeqCst å°±æ˜¯æ€§èƒ½æœ€å·®çš„é‚£ä¸ªäº†ï¼Œå› ä¸ºå®ƒéœ€è¦ CPU åŒæ­¥æ‰€æœ‰æŒ‡ä»¤ã€‚\n    ä½†æ˜¯ Relaxed å› ä¸ºæ²¡æœ‰å†…å­˜å±éšœï¼Œæ‰€ä»¥å¯èƒ½ä¼šæœ‰æŒ‡ä»¤é‡æ’å¸¦æ¥å¸¦é£é™©ã€‚\n    æ‰€ä»¥ï¼ŒRust æ ‡å‡†åº“ä¹Ÿæä¾›äº†` std::sync::atomic::compiler_fence`å’Œ` std::sync::atomic::fence`ä¸¤ä¸ªå‡½æ•°ï¼Œæ¥å¸®åŠ©è§£å†³åœ¨åŸå­æŒ‡ä»¤ä½¿ç”¨ Relaxed å†…å­˜é¡ºåºçš„æƒ…å†µä¸‹ç¼–è¯‘å™¨æˆ–CPUæŒ‡ä»¤é‡æ’çš„é—®é¢˜ã€‚\n\n    ç¤ºä¾‹ï¼š[https://doc.rust-lang.org/stable/std/sync/atomic/fn.compiler_fence.html](https://doc.rust-lang.org/stable/std/sync/atomic/fn.compiler_fence.html)\n\n    åŸå­ç±»å‹æä¾›çš„æ–¹æ³•ï¼ŒåŸºäºç¡¬ä»¶åŸå­æŒ‡ä»¤ (xå‡ä¸ºstd::atomic)\tï¼š\n\n    - `load`ï¼Œè¿”å›xçš„å€¼ã€‚\n    - `store`ï¼ŒæŠŠxè®¾ä¸ºnï¼Œä»€ä¹ˆéƒ½ä¸è¿”å›ã€‚\n    - `swap`ï¼ŒæŠŠxè®¾ä¸ºnï¼Œè¿”å›è®¾å®šä¹‹å‰çš„å€¼ã€‚\n    - `compare_and_swap`ï¼Œç»å…¸casæ“ä½œã€‚\n    - `compare_exchange.\n    - `compare_exchange_weak\n    - `fetch_add(n), fetch_sub(n)`ï¼ŒåŸå­åœ°åšx += n, x-= nï¼Œè¿”å›ä¿®æ”¹ä¹‹å‰çš„å€¼ã€‚\n\n   \n    ä½¿ç”¨åŸå­ç±»å‹éœ€è¦æ³¨æ„çš„æ˜¯ï¼š\n\n    - Storeæ“ä½œï¼Œå¯é€‰å†…å­˜é¡ºåºï¼šRelaxed, Release, SeqCstã€‚å¦åˆ™panicã€‚\n    - Loadæ“ä½œï¼Œå¯é€‰å†…å­˜é¡ºåºï¼šRelaxed, Acquire, SeqCstã€‚å¦åˆ™panicã€‚\n    - Read-modify-write(è¯»-æ”¹-å†™)æ“ä½œï¼Œå¯é€‰å¦‚ä¸‹é¡ºåºï¼šRelaxed, Acquire, Release, AcqRel, SeqCstã€‚\n    - æ‰€æœ‰æ“ä½œçš„é»˜è®¤é¡ºåºéƒ½æ˜¯ SeqCstã€‚\n\n     ```rust\n    // å®ç°ä¸€ä¸ªç®€å•çš„è‡ªæ—‹é”ï¼ˆspinlockï¼‰\n    \n    use std::sync::Arc;\n    use std::sync::atomic::{AtomicUsize, Ordering};\n    use std::{thread, time};\n\n    fn main() {\n        let spinlock = Arc::new(AtomicUsize::new(1));\n\n        let spinlock_clone = Arc::clone(&spinlock);\n        let thread = thread::spawn(move|| {\n            // lock\n            spinlock_clone.store(1, Ordering::SeqCst);\n            // do something\n            let t = time::Duration::from_secs(3);\n            std::thread::sleep(t);\n            // unlock\n            spinlock_clone.store(0, Ordering::SeqCst);\n        });\n\n        // Wait for the other thread to release the lock\n        while spinlock.load(Ordering::SeqCst) != 0 {}\n\n        if let Err(panic) = thread.join() {\n            println!(\"Thread had an error: {:?}\", panic);\n        }\n    }\n\n    ```\n\n    åˆ©ç”¨ AtomicBool å®ç°ä¸€ä¸ª è½»é‡çº§çš„é” ï¼š\n\n    ```rust\n    use std::sync::atomic::Ordering;\n    use core::sync::atomic::AtomicBool;\n\n    struct LightLock(AtomicBool);\n\n    impl LightLock {\n        pub fn new() -> LightLock {\n            LightLock(AtomicBool::new(false))\n        }\n\n        pub fn try_lock<'a>(&'a self) -> Option<LightGuard<'a>> {\n            let was_locked = self.0.swap(true, Ordering::Acquire);\n            if was_locked {\n                None\n            } else {\n                Some(LightGuard { lock: self })\n            }\n        }\n    }\n\n    struct LightGuard<'a> {\n        lock: &'a LightLock,\n    }\n\n    impl<'a> Drop for LightGuard<'a> {\n        fn drop(&mut self) {\n            self.lock.0.store(false, Ordering::Release);\n        }\n    }\n    ```\n\n    ### ABA é—®é¢˜ï¼š\n\n    ä»»ä½•æ—  GC çš„è¯­è¨€åœ¨æ— é”ç¼–ç¨‹çš„æ—¶å€™éƒ½è¦è€ƒè™‘æ­¤é—®é¢˜ã€‚\n\n    è¯•æƒ³ä¸€ä¸ªè¿ç»­å‹æ ˆï¼ˆpushï¼‰å’Œ å‡ºæ ˆï¼ˆpopï¼‰çš„å¹¶å‘æ“ä½œã€‚å‡è®¾è¿™ä¸¤ä¸ªæ“ä½œéƒ½æ˜¯ç”± cas åŸè¯­å®ç°çš„ã€‚\n\n    > å…·ä½“æ¥è¯´ï¼Œå‡å¦‚æœ‰ä¸¤ä¸ªçº¿ç¨‹ T1 å’Œ T2ï¼Œæ“ä½œåˆå§‹æ ˆä¸ºã€Œa->b->cã€çš„æ ˆç»“æ„ã€‚\n    > å½“ T1 æŠŠ a ä»æ ˆå†…å¼¹å‡ºï¼Œæ­¤æ—¶å‘ç”Ÿçº¿ç¨‹è°ƒåº¦ï¼Œ\n    > åˆ‡æ¢åˆ° T2 ï¼ŒT2 å¼¹å‡º a å’Œ bï¼ŒæŠŠ a å† push åˆ°æ ˆé‡Œï¼Œæ­¤æ—¶ T2 çš„æ ˆä¸º ã€Œa->cã€ã€‚\n    > ç„¶åçº¿ç¨‹åˆ‡å› T1 ï¼ŒT1 çœ‹åˆ°æ ˆé¡¶ï¼ˆaï¼‰çš„åœ°å€å’Œå®ƒä¹‹å‰è·å¾—çš„ a åœ°å€ç›¸åŒï¼Œç„¶åå°† æ ˆé¡¶è®¾ç½®ä¸º b ï¼ˆa.nextï¼‰ï¼Œç„¶è€Œ b æ—©å°±è¢«é‡Šæ”¾æ¥ã€‚\n\n    è¿™å°±æ˜¯ ABA é—®é¢˜ã€‚ABA é—®é¢˜æœ¬è´¨æ˜¯å†…å­˜å›æ”¶é—®é¢˜ã€‚å½“ b è¢«å¼¹å‡ºå½“æ—¶å€™ï¼Œè¦ä¿éšœå®ƒå½“å†…å­˜ä¸èƒ½è¢«ç«‹å³é‡ç”¨ã€‚\n    \n    è§£å†³è¯¥é—®é¢˜çš„æ€è·¯æœ‰å¤šç§ï¼šå¼•ç”¨è®¡æ•°ã€åˆ†ä»£å›æ”¶ï¼ˆEpoch Based Reclamationï¼‰å’Œ é™©è±¡æŒ‡é’ˆï¼ˆHazard pointerï¼‰ã€‚\n\n    æ³¨æ„ï¼šABA é—®é¢˜ä¸€èˆ¬æ˜¯å‘ç”Ÿåœ¨ X86 æ¶æ„ä¸Š cas åŸå­æ“ä½œçš„æ—¶å€™ã€‚ARM æ¶æ„å·²ç»ä»æ ¹æºä¸Šè§£å†³äº† ABA é—®é¢˜ã€‚\n\n    - åˆ†ä»£å›æ”¶ç¤ºä¾‹ï¼š[https://github.com/crossbeam-rs/crossbeam/blob/master/crossbeam-epoch/examples/sanitize.rs](https://github.com/crossbeam-rs/crossbeam/blob/master/crossbeam-epoch/examples/sanitize.rs)\n    - é™©è±¡æŒ‡é’ˆç¤ºä¾‹ï¼š\n        - [https://github.com/solotzg/rs-lockfree/blob/master/src/hazard_pointer.rs](https://github.com/solotzg/rs-lockfree/blob/master/src/hazard_pointer.rs)\n        -  [https://github.com/redox-os/conc/blob/master/src/sync/treiber.rs](https://github.com/redox-os/conc/blob/master/src/sync/treiber.rs)\n\n\n\n*/","span":{"file_name":"src/ch02/s4_lockfree.rs","byte_start":86702,"byte_end":98543,"line_start":6,"line_end":278,"column_start":1,"column_end":3}}]},{"kind":"Mod","id":{"krate":0,"index":57},"span":{"file_name":"src/ch02/s5_trait_and_generic.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"s5_trait_and_generic","qualname":"::ch02::s5_trait_and_generic","value":"src/ch02/s5_trait_and_generic.rs","parent":null,"children":[{"krate":0,"index":58},{"krate":0,"index":59},{"krate":0,"index":60},{"krate":0,"index":61},{"krate":0,"index":62},{"krate":0,"index":63},{"krate":0,"index":64}],"decl_id":null,"docs":" ç¬¬äºŒç« ï¼šRustæ ¸å¿ƒæ¦‚å¿µ\n 2.4 trait å’Œ æ³›å‹\n \n \n","sig":null,"attributes":[{"value":"/ ç¬¬äºŒç« ï¼šRustæ ¸å¿ƒæ¦‚å¿µ","span":{"file_name":"src/ch02/s5_trait_and_generic.rs","byte_start":98573,"byte_end":98605,"line_start":1,"line_end":1,"column_start":1,"column_end":17}},{"value":"/ 2.4 trait å’Œ æ³›å‹","span":{"file_name":"src/ch02/s5_trait_and_generic.rs","byte_start":98606,"byte_end":98630,"line_start":2,"line_end":2,"column_start":1,"column_end":19}},{"value":"/ ","span":{"file_name":"src/ch02/s5_trait_and_generic.rs","byte_start":98631,"byte_end":98635,"line_start":3,"line_end":3,"column_start":1,"column_end":5}},{"value":"/ ","span":{"file_name":"src/ch02/s5_trait_and_generic.rs","byte_start":98636,"byte_end":98640,"line_start":4,"line_end":4,"column_start":1,"column_end":5}}]},{"kind":"Function","id":{"krate":0,"index":58},"span":{"file_name":"src/ch02/s5_trait_and_generic.rs","byte_start":100481,"byte_end":100494,"line_start":108,"line_end":108,"column_start":8,"column_end":21},"name":"trait_concept","qualname":"::ch02::s5_trait_and_generic::trait_concept","value":"pub fn trait_concept()","parent":null,"children":[],"decl_id":null,"docs":"    # æ¦‚å¿µä»‹ç»\n    \n    ### trait å››ç§ä½œç”¨","sig":null,"attributes":[{"value":"*\n\n    # æ¦‚å¿µä»‹ç»\n    \n    ### trait å››ç§ä½œç”¨\n\n    - æ¥å£ (interface)\n    - ç±»å‹æ ‡è®°ï¼ˆMark)\n    - æ³›å‹é™å®šï¼ˆtrait boundï¼‰\n    - æŠ½è±¡ç±»å‹ï¼ˆtrait objectï¼‰\n\n\n   ### é™æ€åˆ†å‘ï¼ˆå•æ€åŒ– - Monomorphizedï¼‰\n\n    ```rust\n    use std::string::ToString;\n\n    fn print<T: ToString>(v: T) {\n        println!(\"{}\", v.to_string());\n    }\n    ```\n\n    æˆ– `impl Trait`è¯­æ³•\n\n    ```rust\n    use std::string::ToString;\n\n    #[inline(never)]\n    fn print(v: &impl ToString) {\n        println!(\"{}\", v.to_string());\n    }\n    ```\n\n    ä½¿ç”¨ `impl Trait` è§£å†³é—®é¢˜ï¼š\n\n\n    ```rust\n    // error codesï¼š\n\n    use std::fmt::Display;\n\n    fn main() {\n        println!(\"{}\", make_value(0));\n        println!(\"{}\", make_value(1));\n    }\n\n    fn make_value<T: Display>(index: usize) -> T {\n        match index {\n            0 => \"Hello, World\",\n            1 => \"Hello, World (1)\",\n            _ => panic!(),\n        }\n    }\n\n    ```\n\n    ä¿®æ­£ï¼š\n\n    ```\n    use std::fmt::Display;\n\n    fn make_value(index: usize) -> impl Display {\n        match index {\n            0 => \"Hello, World\",\n            1 => \"Hello, World (1)\",\n            _ => panic!(),\n        }\n    }\n\n    ```\n\n    `impl Trait` ç”Ÿå‘½å‘¨æœŸç›¸å…³ï¼š\n\n    ```rust\n\n    // error\n    fn make_debug<T>(_: T) -> impl std::fmt::Debug + 'static{\n        42u8\n    }\n\n    // fn make_debug<'a, T: 'static>(_: &'a T) -> impl std::fmt::Debug + 'static{\n    //     42u8\n    // }\n\n    fn test() -> impl std::fmt::Debug {\n        let value = \"value\".to_string();\n        make_debug(&value)\n    }\n    ```\n\n   å®é™…æ¡ˆä¾‹ - æ¨¡ç‰ˆæ¨¡å¼ï¼š[https://github.com/actix/actix-extras/tree/master/actix-web-httpauth](https://github.com/actix/actix-extras/tree/master/actix-web-httpauth)\n\n\n   # trait ä¸€è‡´æ€§\n\n    trait å’Œ ç±»å‹ å¿…é¡»æœ‰ä¸€ä¸ªåœ¨æœ¬åœ°ã€‚\n\n\n\n */","span":{"file_name":"src/ch02/s5_trait_and_generic.rs","byte_start":98644,"byte_end":100473,"line_start":8,"line_end":107,"column_start":1,"column_end":4}}]},{"kind":"Function","id":{"krate":0,"index":59},"span":{"file_name":"src/ch02/s5_trait_and_generic.rs","byte_start":102170,"byte_end":102188,"line_start":186,"line_end":186,"column_start":8,"column_end":26},"name":"trait_dyn_dispatch","qualname":"::ch02::s5_trait_and_generic::trait_dyn_dispatch","value":"pub fn trait_dyn_dispatch()","parent":null,"children":[],"decl_id":null,"docs":"# åŠ¨æ€åˆ†å‘    ","sig":null,"attributes":[{"value":"*\n \n\n# åŠ¨æ€åˆ†å‘    \n\n    ### trait å¯¹è±¡\n\n    ç”¨æ³›å‹æ¨¡æ‹Ÿ Class\n\n    ```rust\n\n    #![allow(unused)]\n\n    use core::any::{Any,TypeId};\n    use std::sync::Arc;\n\n    /// Class definition\n    struct Class {\n        /// The name of the class\n        name: String,\n        /// The corresponding Rust type\n        type_id: TypeId,\n    }\n\n    impl Class {\n        /// Create a new class definition for the type `T`\n        fn new<T: 'static>() -> Self {\n            Self {\n                name: std::any::type_name::<T>().to_string(),\n                type_id: TypeId::of::<T>(),\n            }\n        }\n    }\n\n    /// An instance of a class\n    struct Instance {\n        inner: Arc<dyn Any>, // `Arc` because we don't need/want mutability\n    }\n\n    impl Instance {\n        /// Construct a new `Instance` from a type that\n        /// implements `Any` (i.e. any sized type).\n        fn new(obj: impl Any) -> Self {\n            Self {\n                inner: Arc::new(obj)\n            }\n        }\n    }\n\n    impl Instance {\n        /// Check whether this is an instance of the provided class\n        fn instance_of(&self, class: &Class) -> bool {\n            // self.inner.type_id() == class.type_id\n            self.inner.as_ref().type_id() == class.type_id\n        }\n    }\n\n    struct Foo {}\n    struct Bar {}\n\n    fn main(){\n        \n\n        let foo_class: Class = Class::new::<Foo>();\n        let bar_class: Class = Class::new::<Bar>();\n        let foo_instance: Instance = Instance::new(Foo {});\n\n        assert!(foo_instance.instance_of(&foo_class));\n        assert!(!foo_instance.instance_of(&bar_class));\n    }\n    ```\n\n*/","span":{"file_name":"src/ch02/s5_trait_and_generic.rs","byte_start":100531,"byte_end":102162,"line_start":113,"line_end":185,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":60},"span":{"file_name":"src/ch02/s5_trait_and_generic.rs","byte_start":108905,"byte_end":108917,"line_start":370,"line_end":370,"column_start":8,"column_end":20},"name":"trait_object","qualname":"::ch02::s5_trait_and_generic::trait_object","value":"pub fn trait_object()","parent":null,"children":[],"decl_id":null,"docs":"# trait å¯¹è±¡æœ¬è´¨","sig":null,"attributes":[{"value":"*\n   \n# trait å¯¹è±¡æœ¬è´¨\n\n\nç¤ºä¾‹ 1:\n\n```rust\n    struct CloningLab {\n        subjects: Vec<Box<Mammal>>,\n        // subjects: Vec<Box<Mammal + Clone>>,\n    }\n\n    trait Mammal {\n        fn walk(&self);\n        fn run(&self);\n    }\n\n    #[derive(Clone)]\n    struct Cat {\n        meow_factor: u8,\n        purr_factor: u8\n    }\n\n    impl Mammal for Cat {\n        fn walk(&self) {\n            println!(\"Cat::walk\");\n        }\n        fn run(&self) {\n            println!(\"Cat::run\")\n        }\n    }\n\n\n```\n\nç¤ºä¾‹2:\n\n```rust\n\n    #![allow(unused)]\n    #![feature(raw)]\n\n    use std::{mem, raw};\n\n    // an example trait\n    trait Foo {\n        fn bar(&self) -> i32;\n    }\n\n    impl Foo for i32 {\n        fn bar(&self) -> i32 {\n            *self + 1\n        }\n    }\n\n    fn main() {\n        let value: i32 = 123;\n\n        // let the compiler make a trait object\n        let object: &dyn Foo = &value;\n\n        // look at the raw representation\n        let raw_object: raw::TraitObject = unsafe { mem::transmute(object) };\n\n        // the data pointer is the address of `value`\n        assert_eq!(raw_object.data as *const i32, &value as *const _);\n\n        let other_value: i32 = 456;\n\n        // construct a new object, pointing to a different `i32`, being\n        // careful to use the `i32` vtable from `object`\n        let synthesized: &dyn Foo = unsafe {\n            mem::transmute(raw::TraitObject {\n                data: &other_value as *const _ as *mut (),\n                vtable: raw_object.vtable,\n            })\n        };\n\n        // it should work just as if we had constructed a trait object out of\n        // `other_value` directly\n        assert_eq!(synthesized.bar(), 457);\n    }\n\n```\n\næ­£å¸¸ trait Object å¸ƒå±€å›¾ï¼š\n\n```text\n\n                                                           cat's vtable\nCat Layout                     Trait Object\n+------------+              +--------------+             +---------------+\n|            |              |              |             |               |\n|            |              |              |     +-----> | drop pointer  |\n| meow_factor|              |              |     |       |    size       |\n|            +<--------------+data pointer |     |       |    align      |\n| purr_factor|              |              |     |       |               |\n|            |              | vtable pointer-----+       | run fn pointer|\n|            |              |              |             |walk fn pointer|\n|            |              |              |             |               |\n+------------+              +--------------+             |               |\n                                                         |               |\n                                                         |               |\n                                                         |               |\n                                                         +---------------+\n\n```\n    \nå‡è®¾ï¼štrait Mammal + Clone å¸ƒå±€å›¾ï¼š\n    \næ³¨æ„ï¼šéæ³•\n\n```text\n\n                                                                  Mammal\n                                                           cat's vtable\nCat Layout                     Trait Object\n+------------+              +--------------+             +---------------+\n|            |              |              |             |               |\n|            |              |              |     +-----> | drop pointer  |\n| meow_factor|              |              |     |       |    size       |\n|            +<--------------+data pointer |     |       |    align      |\n| purr_factor|              |              |     |       |               |\n|            |              | vtable pointer-----+       | run fn pointer|\n|            |              |              |             |walk fn pointer|\n|            |              |              +-----+       |               |\n+------------+              +--------------+     |       |               |\n                                                 |       |               |\n                                                 |       |               |\n                                                 |       |               |\n                                                 |       +---------------+\n                                                 |\n                                                 |\n                                                 |           Clone Vtable\n                                                 |\n                                                 +-----> +--------------+\n                                                         |              |\n                                                         | drop pointe  |\n                                                         |              |\n                                                         | size         |\n                                                         | align        |\n                                                         |              |\n                                                         |  clone       |\n                                                         |  fn pointer  |\n                                                         |              |\n                                                         +--------------+\n\n\n```\n\n    å‡è®¾ï¼štrait ç»§æ‰¿(`trait MammalClone: Mammal+Clone`)å¸ƒå±€å›¾ï¼š \n\n    æ³¨æ„ï¼šéæ³•\n  \n```text\n\n                                                            MammalClone\n                                                           cat's vtable\nCat Layout                     Trait Object\n+------------+              +--------------+             +-----------------+\n|            |              |              |             |                 |\n|            |              |              |     +-----> | drop pointer    |\n| meow_factor|              |              |     |       |    size         |\n|            +<--------------+data pointer |     |       |    align        |\n| purr_factor|              |              |     |       |                 |\n|            |              | vtable pointer-----+       | run fn pointer  |\n|            |              |              |             |walk fn pointer  |\n|            |              |              |             |                 |\n+------------+              +--------------+             |clone fn pointer |\n                                                         |                 |\n                                                         |                 |\n                                                         |                 |\n                                                         +-----------------+\n\n ```\n\n\n*/","span":{"file_name":"src/ch02/s5_trait_and_generic.rs","byte_start":102232,"byte_end":108897,"line_start":191,"line_end":369,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":61},"span":{"file_name":"src/ch02/s5_trait_and_generic.rs","byte_start":113515,"byte_end":113528,"line_start":478,"line_end":478,"column_start":8,"column_end":21},"name":"object_safety","qualname":"::ch02::s5_trait_and_generic::object_safety","value":"pub fn object_safety()","parent":null,"children":[],"decl_id":null,"docs":"#  å¯¹è±¡å®‰å…¨","sig":null,"attributes":[{"value":"*\n\n#  å¯¹è±¡å®‰å…¨\n\n\n\n### å¯¹è±¡å®‰å…¨\n    \n    ä¸€ä¸ª trait å¦‚æœèƒ½å®ç°è‡ªå·±ï¼Œå°±è®¤ä¸ºå®ƒæ˜¯å¯¹è±¡å®‰å…¨çš„\n\nä¸ºä»€ä¹ˆå¿…é¡»æ˜¯å¯¹è±¡å®‰å…¨å‘¢ï¼Ÿ\n    \ntraitå¯¹è±¡ï¼Œåœ¨è¿è¡Œæ—¶å·²ç»æ“¦é™¤äº†ç±»å‹ä¿¡æ¯ï¼Œè¦é€šè¿‡è™šè¡¨è°ƒç”¨ç›¸åº”çš„æ–¹æ³•ã€‚ä¸åƒé™æ€åˆ†å‘é‚£æ ·ï¼Œtraitå¯¹è±¡ä¸æ˜¯ä¸ºæ¯ä¸ªç±»å‹éƒ½å®ç°traitçš„æ–¹æ³•ï¼Œè€Œæ˜¯åªå®ç°ä¸€ä¸ªå‰¯æœ¬ï¼ˆè‡ªåŠ¨ä¸ºå…¶å®ç°è‡ªèº«ï¼‰ï¼Œç»“åˆè™šå‡½æ•°å»è°ƒç”¨ã€‚\n\nç°åœ¨æƒ³ä¸€ä¸ªé—®é¢˜ï¼š å‡å¦‚é‚£ä¸ªç±»å‹æ²¡æœ‰å®ç°è¿™ä¸ªæ–¹æ³•æ€ä¹ˆåŠï¼Ÿ\nå®é™…ä¸Šï¼Œä¼šæœ‰å¾ˆå¤šç§æƒ…å†µä¸‹ï¼Œä¼šå‡ºç°è¿™ä¸ªé—®é¢˜ã€‚è¿è¡Œæ—¶ç¡®å®šçš„ç±»å‹å’Œæ–¹æ³•åº”è¯¥åˆæ³•çš„ï¼Œä¿è¯traitå¯¹è±¡åœ¨è¿è¡Œæ—¶å¯ä»¥å®‰å…¨åœ°è°ƒç”¨ç›¸å…³çš„æ–¹æ³•ã€‚\n\næ¯”å¦‚traité‡Œæœ‰æ³›å‹å‡½æ•°ã€‚è¿™å°±æçš„å¾ˆå¤æ‚äº†ï¼Œå¯èƒ½è¿è¡Œæ—¶æ— æ³•ç¡®å®šè¯¥è°ƒç”¨å“ªä¸ªå‡½æ•°ã€‚åæ­£æ˜¯å„ç§æƒ…å†µå§ã€‚æ‰€ä»¥ï¼Œä¸ºäº†é¿å…å‡ºç°è¿™ç§é—®é¢˜ï¼Œå®˜æ–¹å¼•å…¥äº†å¯¹è±¡å®‰å…¨çš„æ¦‚å¿µã€‚\nå®é™…ä¸Šå°±æ˜¯å¼•å…¥äº†ä¸€ç³»åˆ—çš„è§„åˆ™ï¼Œä¹Ÿå°±æ˜¯ä¸Šé¢åˆ—å‡ºçš„é‚£äº›ã€‚ç¼–è¯‘å™¨æ ¹æ®è¿™äº›è§„åˆ™ï¼Œåœ¨ç¼–è¯‘æœŸåˆ¤æ–­ä¸€ä¸ªä½ å†™çš„traitå¯¹è±¡ï¼Œæ˜¯ä¸æ˜¯åˆæ³•çš„ã€‚\n\næ¯”å¦‚ï¼štraitå¯¹è±¡å…¶å®åœ¨å†…éƒ¨ç»´æŠ¤ä¸¤ä¸ªè¡¨ï¼šsafe_vtableå’Œnonself_vtableï¼Œæ ‡è®°æœ‰where Self: Sizedçš„ä¼šè¢«å½’ç±»åˆ°nonself_vtableï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œä¸ä¼šè¢«traitå¯¹è±¡è°ƒç”¨ã€‚\nè¿™æ ·çš„è¯ï¼Œæ–¹æ³•æ ‡è®°æœ‰where Self: Sizedçš„traitå¯¹è±¡è‡ªç„¶æ˜¯å®‰å…¨çš„ï¼Œå› ä¸ºè¿™è¡¨ç¤º è¿™ä¸ªæ–¹æ³• åªèƒ½ä¸º Self: Sized éƒ½ç±»å‹å®ç°ï¼Œæ˜¯æœ‰æ¡ä»¶çš„ï¼Œæ‰€ä»¥åœ¨è¿è¡Œæ—¶æœ‰å¯èƒ½å­˜åœ¨æ— æ•ˆï¼ˆä¸‡ä¸€æœ‰ä¸æ˜¯Sizedçš„ç±»å‹è°ƒç”¨ï¼Œå°±æ²¡æœ‰è¯¥æ–¹æ³•ï¼‰è°ƒç”¨ã€‚\n\nå¦‚æœæ˜¯åˆæ³•çš„ï¼Œåˆ™ä»£è¡¨äº†ï¼Œè¿™ä¸ªtraitå¯¹è±¡åœ¨è¿è¡Œæ—¶è°ƒç”¨æ–¹æ³•åº”è¯¥æ˜¯æ²¡é—®é¢˜çš„ã€‚\nä¸ä¼šå‡ºç°æ²¡æœ‰å®ç°ï¼Œæˆ–è€…ä¸çŸ¥é“è¯¥è°ƒç”¨å“ªä¸ªçš„æƒ…å†µã€‚\nè¿™å°±æ˜¯å¯¹è±¡å®‰å…¨çš„æ¦‚å¿µã€‚å®ƒå’Œå†…å­˜å®‰å…¨å¹¶æ— ç›´æ¥å…³ç³»ã€‚\næ‰€ä»¥ï¼Œå¯¹è±¡å®‰å…¨çš„æœ¬è´¨å°±æ˜¯ä¸ºäº†è®©traitå¯¹è±¡å¯ä»¥å®‰å…¨åœ°è°ƒç”¨ç›¸åº”çš„æ–¹æ³•ã€‚\n\nå¦‚æœæ²¡æœ‰Sizedçš„é™å®šï¼Œé‚£ä¹ˆå°±ä¼šå¾ˆå®¹æ˜“å†™å‡ºæ— ç”¨çš„ç±»å‹ã€‚æ¯”å¦‚ Boxï¼Œå®ƒç”¨åštraitå¯¹è±¡å³ä¾¿ä¼šç¼–è¯‘ï¼Œä½†æ˜¯ä¸èƒ½ç”¨å®ƒåšä»»ä½•äº‹æƒ…ï¼ˆåé¢æœ‰æ¼”ç¤ºä»£ç ï¼‰ã€‚\nå¯¹äºæ›´å¤æ‚çš„traitï¼Œå¾€å¾€å°±æ²¡æœ‰è¿™ä¹ˆæ˜æ˜¾äº†ï¼Œåªæœ‰åœ¨åšäº†å¤§é‡ç¹é‡çš„å·¥ä½œä¹‹åå¯èƒ½ä¼šçªç„¶å‘ç°æŸä¸ªtraitå¯¹è±¡æ— æ³•æ­£å¸¸è°ƒç”¨æ–¹æ³•ã€‚\næ‰€ä»¥ï¼Œä¸ºtraitå¢åŠ Sizedé™å®šï¼Œç„¶åç¼–è¯‘å™¨è‡ªåŠ¨ä¸ºè¯¥traitå®ç°è‡ªèº«ï¼Œå°±å¯ä»¥åœ¨ç¼–è¯‘æœŸå‡†ç¡®æ’é™¤æ— æ•ˆçš„traitå¯¹è±¡ã€‚\nè¿™å°±æ˜¯å¯¹è±¡å®‰å…¨ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¯¹è±¡å®‰å…¨å’Œå†…å­˜å®‰å…¨å¹¶æ— ç›´æ¥çš„å…³è”ï¼Œå®ƒåªæ˜¯ä¿è¯traitå¯¹è±¡åœ¨è¿è¡Œæ—¶å¯ä»¥å®‰å…¨å‡†ç¡®åœ°è°ƒç”¨ç›¸å…³çš„æ–¹æ³•ã€‚\n\n```rust\n    trait StarkFamily {\n        fn last_name(&self)  -> &'static str;\n        fn totem(&self) -> &'static str;\n    }\n\n    trait TullyFamily {\n        fn territory(&self) -> &'static str;\n    }\n\n    trait Children {\n        fn new(first_name: &'static str) -> Self where Self: Sized;\n        fn first_name(&self) -> &'static str;\n    }\n\n    impl StarkFamily for Children {\n        fn last_name(&self)  -> &'static str{\n            \"Stark\"\n        }\n        \n        fn totem(&self)  -> &'static str{\n            \"Wolf\"\n        }\n    }\n\n    impl TullyFamily for Children {\n        fn territory(&self)  -> &'static str{\n            \"Riverrun City\" \n        }\n    }\n\n    struct People{\n        first_name: &'static str\n    }\n\n    impl Children for People {\n        fn new(first_name: &'static str) -> Self where Self: Sized{\n            println!(\"hello : {} Stark \", first_name);\n            People{first_name: first_name}\n        }\n        \n        fn first_name(&self) -> &'static str{\n            self.first_name\n        }\n    }\n\n    fn full_name(person: Box<dyn Children>) {\n        println!(\" --- Winter is coming, the lone {:?} dies, the pack lives ---\", person.totem());\n        let full = format!(\"{} {}\", person.first_name(), person.last_name() );\n        println!(\"I'm {:?}\", full );\n        println!(\"My Mother come from {:?}\", person.territory());\n    }\n\n    fn main() {\n        let sansa = People::new(\"Sansa\");\n        let aray = People::new(\"Aray\");\n        \n        let starks: Box<dyn Children> = Box::new(sansa);\n        full_name(starks);\n        \n        let starks: Box<dyn Children> = Box::new(aray);\n        full_name(starks);\n    }\n\n```\n    \n    \nå¯¹è±¡å®‰å…¨è§„åˆ™ Rust æºç ï¼š[https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/compiler/rustc_middle/src/traits/mod.rs#L643](https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/compiler/rustc_middle/src/traits/mod.rs#L643)\n\n\n*/","span":{"file_name":"src/ch02/s5_trait_and_generic.rs","byte_start":108960,"byte_end":113507,"line_start":374,"line_end":477,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":62},"span":{"file_name":"src/ch02/s5_trait_and_generic.rs","byte_start":116940,"byte_end":116960,"line_start":629,"line_end":629,"column_start":8,"column_end":28},"name":"trait_object_to_enum","qualname":"::ch02::s5_trait_and_generic::trait_object_to_enum","value":"pub fn trait_object_to_enum()","parent":null,"children":[],"decl_id":null,"docs":"# å½“ä¸èƒ½å®ç° trait å¯¹è±¡å½“æ—¶å€™è¯¥å¦‚ä½•ï¼Ÿ","sig":null,"attributes":[{"value":"*\n\n# å½“ä¸èƒ½å®ç° trait å¯¹è±¡å½“æ—¶å€™è¯¥å¦‚ä½•ï¼Ÿ\n\n1. å°†å…¶è½¬åŒ–ä¸º Enum \n\ntrait å¯¹è±¡ä»£ç ï¼š\n\n```rust\n    trait KnobControl {\n        fn set_position(&mut self, value: f64);\n        fn get_value(&self) -> f64;\n    }\n\n    struct LinearKnob {\n        position: f64,\n    }\n\n    struct LogarithmicKnob {\n        position: f64,\n    }\n\n    impl KnobControl for LinearKnob {\n        fn set_position(&mut self, value: f64) {\n            self.position = value;\n        }\n\n        fn get_value(&self) -> f64 {\n            self.position\n        }\n    }\n\n    impl KnobControl for LogarithmicKnob {\n        fn set_position(&mut self, value: f64) {\n            self.position = value;\n        }\n\n        fn get_value(&self) -> f64 {\n            (self.position + 1.).log2()\n        }\n    }\n\n    fn main() {\n        let v: Vec<Box<dyn KnobControl>> = vec![\n            //set the knobs\n        ];\n\n        //use the knobs\n    }\n```\n\nè½¬ä¸º enumï¼š\n\n```rust\n    enum Knob {\n        Linear(LinearKnob),\n        Logarithmic(LogarithmicKnob),\n    }\n\n    impl KnobControl for Knob {\n        fn set_position(&mut self, value: f64) {\n            match self {\n                Knob::Linear(inner_knob) => inner_knob.set_position(value),\n                Knob::Logarithmic(inner_knob) => inner_knob.set_position(value),\n            }\n        }\n\n        fn get_value(&self) -> f64 {\n            match self {\n                Knob::Linear(inner_knob) => inner_knob.get_value(),\n                Knob::Logarithmic(inner_knob) => inner_knob.get_value(),\n            }\n        }\n    }\n```\n\nå½“ trait ä¸æ»¡è¶³å¯¹è±¡å®‰å…¨è§„åˆ™çš„æ—¶å€™ï¼Œä¹Ÿå¯ä»¥ç”¨ Enum ä»£æ›¿ã€‚\n\n```rust\n#![allow(unused)]\n\nuse core::ops::Add;\n\ntrait KnobControl<T: Add + Add<Output = T> + Copy> {\n    fn set_position(&mut self, value: T);\n    fn get_value(&self, p: T) -> T;\n}\n\nstruct LinearKnob<T: Add+ Add<Output = T> + Copy> {\n    position: T,\n}\n\nstruct LogarithmicKnob<T: Add+ Add<Output = T> + Copy>  {\n    position: T,\n}\n\nimpl<T: Add+ Add<Output = T> + Copy> KnobControl<T> for LinearKnob<T> {\n    fn set_position(&mut self, value: T) {\n        self.position = value;\n    }\n\n    fn get_value(&self, p: T) -> T {\n        self.position + p\n    }\n}\n\nimpl<T: Add+ Add<Output = T> + Copy> KnobControl<T> for LogarithmicKnob<T> {\n    fn set_position(&mut self, value: T) {\n        self.position = value;\n    }\n\n    fn get_value(&self, p: T) -> T {\n        (self.position + p)\n    }\n}\n\nfn main() {\n    enum Knob<T: Add+ Add<Output = T> + Copy> {\n        Linear(LinearKnob<T>),\n        Logarithmic(LogarithmicKnob<T>),\n    }\n\n    impl<T: Add+ Add<Output = T> + Copy> KnobControl<T> for Knob<T> {\n        fn set_position(&mut self, value: T) {\n            match self {\n                Knob::Linear(inner_knob) => inner_knob.set_position(value),\n                Knob::Logarithmic(inner_knob) => inner_knob.set_position(value),\n            }\n        }\n\n        fn get_value(&self, p: T) -> T {\n            match self {\n                Knob::Linear(inner_knob) => inner_knob.get_value(p),\n                Knob::Logarithmic(inner_knob) => inner_knob.get_value(p),\n            }\n        }\n    }\n}\n\n\n```\n\n\n2. åˆ©ç”¨ â€œé­”æ³•â€ ï¼Œç›¸å½“äºåŠ ä¸€å±‚ä»£ç† ï¼š å‚è€ƒï¼š[https://github.com/dtolnay/erased-serde/blob/master/explanation/main.rs](https://github.com/dtolnay/erased-serde/blob/master/explanation/main.rs)\n\n*/","span":{"file_name":"src/ch02/s5_trait_and_generic.rs","byte_start":113572,"byte_end":116932,"line_start":483,"line_end":628,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":63},"span":{"file_name":"src/ch02/s5_trait_and_generic.rs","byte_start":118994,"byte_end":119007,"line_start":738,"line_end":738,"column_start":8,"column_end":21},"name":"blanket_impls","qualname":"::ch02::s5_trait_and_generic::blanket_impls","value":"pub fn blanket_impls()","parent":null,"children":[],"decl_id":null,"docs":"# Overlapping blanket impls","sig":null,"attributes":[{"value":"*\n\n# Overlapping blanket impls\n\nå½“å‰ Rust ä¸æ”¯æŒ  `trait `ä¸º åŒä¸€ä¸ªç±»å‹è¦†ç›–å®ç°ï¼š\n\n```rust\n    trait Blanket {\n        fn blanket(&self) -> &'static str;\n    }\n\n    impl Blanket for u8 {\n        fn blanket(&self) -> &'static str {\n            \"impl1\"\n        }\n    }\n\n    // Compilation fails at that point\n    impl Blanket for u8 {\n        fn blanket(&self) -> &'static str {\n            \"impl2\"\n        }\n    }\n\n    fn main() {\n        // If compilation succeeded, what would be printed?\n        println!(\"{}\", 0u8.blanket());\n    }\n\n```\n\nå†æ¯”å¦‚æ³›å‹ï¼š\n\n```rust\n    impl <T: ToString> Blanket for T { ... }\n\n    // Compilation fails at that point\n    impl <T: Clone> Blanket for T { ...}\n\n```\n\nä»¥ä¸Šæ˜¯ Rust ä¸å…è®¸çš„ã€‚\n\nè™½ç„¶ç‰¹åŒ–åŠŸèƒ½ä¹Ÿé€æ¸å¼€å§‹æ”¯æŒï¼Œä½†ä¸è¶³ä»¥è§£å†³ä¸Šé¢è¿™ç§å­˜åœ¨`trait`å®ç°â€œç«äº‰â€çš„æƒ…å†µã€‚\n\nä¸€ä¸ªè§£å†³æ–¹æ¡ˆæ˜¯ï¼š\n\n```rust\n    trait Blanket<I> {\n        fn blanket(&self) -> &'static str;\n    }\n\n    impl Blanket<u8> for u8 {\n        fn blanket(&self) -> &'static str {\n            \"u8\"\n        }\n    }\n\n    impl<T: ToString> Blanket<&ToString> for T {\n        fn blanket(&self) -> &'static str {\n            \"ToString\"\n        }\n    }\n\n    trait CloneBlanket {}\n\n    impl<T: Clone> Blanket<&CloneBlanket> for T {\n        fn blanket(&self) -> &'static str {\n            \"Clone\"\n        }\n    }\n\n    trait TryIntoBlanket<T> {\n        type Error;\n    }\n\n    impl<T, E, U> Blanket<&TryIntoBlanket<T, Error = E>> for U\n    where\n        U: TryInto<T, Error = E>,\n    {\n        fn blanket(&self) -> &'static str {\n            \"try_into\"\n        }\n    }\n\n    impl<T: ToString> Blanket<&ToString> for T {\n        fn blanket(&self) -> &'static str {\n            \"to_string\"\n        }\n    }\n\n    impl<T: AsRef<U>, U: ?Sized> Blanket<&AsRef<U>> for T {\n        fn blanket(&self) -> &'static str {\n            \"as_ref\"\n        }\n    }\n\n```\n\næ–¹æ¡ˆå‚è€ƒï¼šhttps://codesandwich.github.io/overlapping_blanket_impls/\n\n\n\n*/","span":{"file_name":"src/ch02/s5_trait_and_generic.rs","byte_start":116999,"byte_end":118986,"line_start":634,"line_end":737,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":64},"span":{"file_name":"src/ch02/s5_trait_and_generic.rs","byte_start":121143,"byte_end":121165,"line_start":854,"line_end":854,"column_start":8,"column_end":30},"name":"trait_self_sized_bound","qualname":"::ch02::s5_trait_and_generic::trait_self_sized_bound","value":"pub fn trait_self_sized_bound()","parent":null,"children":[],"decl_id":null,"docs":"    ### å¯¹è±¡å®‰å…¨è§„åˆ™é‡Œï¼Œä¸ºä»€ä¹ˆéœ€è¦ `Self: Sized` ","sig":null,"attributes":[{"value":"*\n\n    ### å¯¹è±¡å®‰å…¨è§„åˆ™é‡Œï¼Œä¸ºä»€ä¹ˆéœ€è¦ `Self: Sized` \n\n    æ€è€ƒï¼šä»€ä¹ˆæƒ…å†µä¸‹éœ€è¦ `Self: Sized` ï¼Ÿ\n\n    ```rust\n\n    trait WithConstructor {\n        fn build(param: usize) -> Self where Self: Sized;\n\n        fn new() -> Self where Self: Sized {\n            Self::build(0)\n        }\n        \n\n        fn t(&self){\n            println!(\"T\");\n        }\n        \n        fn p(&self){\n            self.t();\n            println!(\"hello\");\n        }\n    }\n\n    struct A;\n\n    impl WithConstructor for A {\n        fn build(param: usize) -> Self{\n            A\n        }\n        \n    }\n\n    fn main(){\n        let a : &WithConstructor = &A ;\n    }\n    ```\n\n    ç¤ºä¾‹ 2:\n\n    ```rust\n\n    trait Test {\n        fn foo(self);\n        \n        fn works(self: Box<Self>){\n            println!(\"hello Trait\");\n        }\n        \n        fn fails(self: Box<Self>)\n        where Self: Sized\n        {\n            self.foo()    \n        }\n    }\n\n    struct Concrete;\n\n    impl Concrete {\n        fn hello(&self){\n            println!(\"hello\");\n        }\n    }\n\n    struct Bar;\n\n    impl Bar {\n        fn hello(&self){\n            println!(\"hello Bar\");\n        }\n    }\n\n    impl Test for Bar {\n        fn foo(self) { () }\n        fn works(self: Box<Self>) { self.hello()}\n    }\n\n    impl Test for Concrete {\n        fn foo(self) { () }\n        fn works(self: Box<Self>) { self.hello()}\n    }\n\n    fn main() {\n        let concrete: Box<dyn Test> = Box::new(Concrete);\n        concrete.works();\n        let concrete: Box<dyn Test> = Box::new(Bar);\n        concrete.works();\n        // concrete.fails(); // compilation error\n    }\n\n    ```\n\n    ç»“è®ºï¼š \n    1. `Self: Sized` ä¸ºäº†ä¿è¯ trait é»˜è®¤å®ç°å†…éƒ¨çš„ Self è°ƒç”¨éƒ½æ˜¯åˆæ³•çš„ã€‚\n    2. é˜²æ­¢ å‡½æ•°ä½“å†…åŒ…å«äº† Self çš„é»˜è®¤å®ç°æ··å…¥è™šè¡¨ã€‚å› ä¸ºè™šè¡¨å†… Self æ— æ³•ç¡®å®šã€‚\n\n    ### Sized  vs  ?Sized \n\n    ```rust\n    trait WithConstructor {\n        fn build(param: usize) -> Self where Self: ?Sized;\n\n        fn new() -> Self where Self: ?Sized {\n            Self::build(0)\n        }\n    } \n    ```\n\n*/","span":{"file_name":"src/ch02/s5_trait_and_generic.rs","byte_start":119046,"byte_end":121135,"line_start":743,"line_end":853,"column_start":1,"column_end":3}}]},{"kind":"Mod","id":{"krate":0,"index":65},"span":{"file_name":"src/ch02/s6_paradigms.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"s6_paradigms","qualname":"::ch02::s6_paradigms","value":"src/ch02/s6_paradigms.rs","parent":null,"children":[{"krate":0,"index":66}],"decl_id":null,"docs":" ç¬¬äºŒç« ï¼šRustæ ¸å¿ƒæ¦‚å¿µ\n 2.5 ç¼–ç¨‹èŒƒå¼ï¼šé¢å‘ç¼–è¯‘å™¨ç¼–ç¨‹\n \n è®¨è®ºï¼š\n \n 1. Rust æ˜¯ FP è¯­è¨€å—ï¼Ÿ\n 2. Rust æ˜¯ OOP è¯­è¨€å—ï¼Ÿ\n 3. å¦‚æœéƒ½ä¸æ˜¯ï¼Œé‚£ Rust æ˜¯é¢å‘å•¥çš„è¯­è¨€ ï¼Ÿ é¢å‘ç¼–è¯‘å™¨ã€‚\n \n \n","sig":null,"attributes":[{"value":"/ ç¬¬äºŒç« ï¼šRustæ ¸å¿ƒæ¦‚å¿µ","span":{"file_name":"src/ch02/s6_paradigms.rs","byte_start":121216,"byte_end":121248,"line_start":1,"line_end":1,"column_start":1,"column_end":17}},{"value":"/ 2.5 ç¼–ç¨‹èŒƒå¼ï¼šé¢å‘ç¼–è¯‘å™¨ç¼–ç¨‹","span":{"file_name":"src/ch02/s6_paradigms.rs","byte_start":121249,"byte_end":121293,"line_start":2,"line_end":2,"column_start":1,"column_end":21}},{"value":"/ ","span":{"file_name":"src/ch02/s6_paradigms.rs","byte_start":121294,"byte_end":121298,"line_start":3,"line_end":3,"column_start":1,"column_end":5}},{"value":"/ è®¨è®ºï¼š","span":{"file_name":"src/ch02/s6_paradigms.rs","byte_start":121299,"byte_end":121312,"line_start":4,"line_end":4,"column_start":1,"column_end":8}},{"value":"/ ","span":{"file_name":"src/ch02/s6_paradigms.rs","byte_start":121313,"byte_end":121317,"line_start":5,"line_end":5,"column_start":1,"column_end":5}},{"value":"/ 1. Rust æ˜¯ FP è¯­è¨€å—ï¼Ÿ","span":{"file_name":"src/ch02/s6_paradigms.rs","byte_start":121318,"byte_end":121349,"line_start":6,"line_end":6,"column_start":1,"column_end":22}},{"value":"/ 2. Rust æ˜¯ OOP è¯­è¨€å—ï¼Ÿ","span":{"file_name":"src/ch02/s6_paradigms.rs","byte_start":121350,"byte_end":121382,"line_start":7,"line_end":7,"column_start":1,"column_end":23}},{"value":"/ 3. å¦‚æœéƒ½ä¸æ˜¯ï¼Œé‚£ Rust æ˜¯é¢å‘å•¥çš„è¯­è¨€ ï¼Ÿ é¢å‘ç¼–è¯‘å™¨ã€‚","span":{"file_name":"src/ch02/s6_paradigms.rs","byte_start":121383,"byte_end":121461,"line_start":8,"line_end":8,"column_start":1,"column_end":37}},{"value":"/ ","span":{"file_name":"src/ch02/s6_paradigms.rs","byte_start":121462,"byte_end":121466,"line_start":9,"line_end":9,"column_start":1,"column_end":5}},{"value":"/ ","span":{"file_name":"src/ch02/s6_paradigms.rs","byte_start":121467,"byte_end":121471,"line_start":10,"line_end":10,"column_start":1,"column_end":5}}]},{"kind":"Function","id":{"krate":0,"index":66},"span":{"file_name":"src/ch02/s6_paradigms.rs","byte_start":126312,"byte_end":126341,"line_start":193,"line_end":193,"column_start":8,"column_end":37},"name":"compiler_oriented_programming","qualname":"::ch02::s6_paradigms::compiler_oriented_programming","value":"pub fn compiler_oriented_programming()","parent":null,"children":[],"decl_id":null,"docs":"    ### Rust æ˜¯é¢å‘å¯¹è±¡è¯­è¨€å—ï¼Ÿ","sig":null,"attributes":[{"value":"*\n\n    ### Rust æ˜¯é¢å‘å¯¹è±¡è¯­è¨€å—ï¼Ÿ\n\n    OOP style:\n\n    1. æ”¯æŒé¢å‘æ¥å£ç¼–ç¨‹\n    2. æ”¯æŒå°è£…\n    3. ä¸æ”¯æŒç»§æ‰¿(ä½†å¯ä»¥æ¨¡æ‹Ÿ)\n\n    ```\n    interface Foo {}\n    class Bar: Foo {\n        //Implement Foo here\n    }\n    ```\n\n    ```rust\n    trait Foo {}\n    struct Bar;\n    impl Bar;\n    impl Foo for Bar {}\n    ```\n\n    ### Rust æ˜¯å‡½æ•°å¼è¯­è¨€å—ï¼Ÿ\n\n    å‡½æ•°å¼styleï¼š\n    1. é»˜è®¤ä¸å¯å˜ï¼ˆä½†ä¹Ÿæ”¯æŒå¯å˜ï¼‰\n    2. æ”¯æŒé€’å½’ï¼ˆä½†ä¸æ”¯æŒå°¾é€’å½’ä¼˜åŒ–ï¼‰\n    3. å‡½æ•°æ˜¯ä¸€ç­‰å…¬æ°‘ï¼Œé«˜é˜¶å‡½æ•°æ”¯æŒï¼ˆæœ‰é™ï¼‰\n    4. å’Œç±»å‹/ ç§¯ç±»å‹ (Option/Result)\n\n    ```rust\n    fn get_sum(mut total: u32, mut i: u32) -> u32 {\n        if i > 10000000 {\n            return total;\n        }\n\n        total = total.wrapping_add(i);\n        i += 1;\n        get_sum(total, i)\n    }\n    fn main() {\n        let total = 0;\n        let total = get_sum(total, 1);\n        println!(\"{}\", total);\n    }\n\n    ```\n\n    curring:\n\n    ```\n    #[derive(Debug)]\n    struct States<'a> {\n        a: &'a i32,\n        b: &'a i32,\n    }\n\n    trait Currying {\n        type ReturnType: Fn(i32) -> i32;\n        fn add(self) -> Self::ReturnType;\n    }\n\n    impl Currying for States<'static>{\n        type ReturnType = Box<dyn Fn(i32) -> i32>;\n\n        fn add(self) -> Self::ReturnType {\n            Box::new(move|x| {\n                x * self.a\n            })\n        }\n    }\n\n    let r_value: States = States {\n        a: &100,\n        b: &100\n    };\n\n    let r1 = r_value.add();\n    let r2 = r1(5);\n\n    assert_eq!(500, r2);\n    ```\n\n    ### Rust æ˜¯ é¢å‘ç¼–è¯‘å™¨ ç¼–ç¨‹çš„è¯­è¨€\n\n    ```text\n    +----------------------------------------------------+\n    |                crate                               |\n    |                                                    |\n    |      +-----------------------------------+         |\n    |      |           std                     |         |\n    |      |                                   |         |\n    |      |       +---------------------+     |         |\n    |      |       |                     |     |         |\n    |      |       |     core            |     |         |\n    |      |       |    +----------+     |     |         |\n    |      |       |    | compiler |     |     |         |\n    |      |       |    +----------+     |     |         |\n    |      |       |                     |     |         |\n    |      |       +---------------------+     |         |\n    |      |                                   |         |\n    |      |                                   |         |\n    |      +-----------------------------------+         |\n    |                                                    |\n    |                                                    |\n    +----------------------------------------------------+\n\n    ```\n\n    æŸ¥çœ‹ Rust æºç ç»„ç»‡ç»“æ„ï¼š [https://github.com/rust-lang/rust](https://github.com/rust-lang/rust)\n\n    æ´‹è‘±æ¨¡å‹ï¼š\n\n    1. æœ€å°å†…æ ¸æ‰€è°“æ‰€æœ‰æƒå’Œå€Ÿç”¨è§„åˆ™ï¼Œå°±æ˜¯ç¼–è¯‘å™¨ç‰¹æ€§\n    2. åŸºäºæœ€å°å†…æ ¸å¼€å§‹æ„é€ äº† core\n    3. åŸºäºcore æ„é€ äº† std\n    4. åŸºäº std æ„é€ ç”Ÿæ€ crate\n    5. å‘½ä»¤å¼ç¼–ç¨‹ä¸ºä¸»ï¼ˆç±» Cï¼‰ï¼ŒOOP å’Œ FP Style è¾…åŠ©\n\n    å…¸å‹çš„å®ç°ï¼š[std::cell::Cell](https://github.com/rust-lang/rust/blob/master/library/core/src/cell.rs)\n    \n    Cell çš„è¯­ä¹‰ï¼š\n\n    1. åœ¨ä¸å¯å˜å¼•ç”¨çš„åŸºç¡€ä¸Šæ„é€ ä¸€ä¸ªå®‰å…¨çš„å†…éƒ¨å¯å˜æ€§\n    2. åªé’ˆå¯¹å®ç° Copy çš„ç±»å‹æä¾› get æ–¹æ³•\n    3. å¯¹äº é Copy çš„ç±»å‹ï¼Œæä¾› move out çš„æ–¹æ³•\n\n    ```rust\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[repr(transparent)]\n    pub struct Cell<T: ?Sized> {\n        value: UnsafeCell<T>,\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    unsafe impl<T: ?Sized> Send for Cell<T> where T: Send {}\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<T: ?Sized> !Sync for Cell<T> {}\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<T: Copy> Clone for Cell<T> {\n        #[inline]\n        fn clone(&self) -> Cell<T> {\n            Cell::new(self.get())\n        }\n    }\n\n    impl<T: Eq + Copy> Eq for Cell<T> {}\n\n    impl<T> Cell<T> {\n\n        pub const fn new(value: T) -> Cell<T> {\n            Cell { value: UnsafeCell::new(value) }\n        }\n\n        pub fn set(&self, val: T) {\n            let old = self.replace(val);\n            drop(old);\n        }\n    }\n\n    impl<T: Copy> Cell<T> {\n        pub fn get(&self) -> T {\n            // SAFETY: This can cause data races if called from a separate thread,\n            // but `Cell` is `!Sync` so this won't happen.\n            unsafe { *self.value.get() }\n        }\n    }\n\n    impl<T: Default> Cell<T> {\n        #[stable(feature = \"move_cell\", since = \"1.17.0\")]\n        pub fn take(&self) -> T {\n            self.replace(Default::default())\n        }\n    }\n    ```\n*/","span":{"file_name":"src/ch02/s6_paradigms.rs","byte_start":121473,"byte_end":126304,"line_start":12,"line_end":192,"column_start":1,"column_end":3}}]},{"kind":"Mod","id":{"krate":0,"index":67},"span":{"file_name":"src/ch02/s7_error_handle.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"s7_error_handle","qualname":"::ch02::s7_error_handle","value":"src/ch02/s7_error_handle.rs","parent":null,"children":[{"krate":0,"index":68},{"krate":0,"index":69},{"krate":0,"index":70}],"decl_id":null,"docs":" ç¬¬äºŒç« ï¼šRustæ ¸å¿ƒæ¦‚å¿µ\n 2.6 é”™è¯¯å¤„ç†\n \n 1. ç±»å‹ç³»ç»Ÿä¿è¯å‡½æ•°å¥‘çº¦\n 2. æ–­è¨€ç”¨äºé˜²å¾¡\n 3. Option<T> æ¶ˆé™¤ç©ºæŒ‡é’ˆå¤±è´¥\n 4. Result<T, E> ä¼ æ’­é”™è¯¯\n 5. Panic ææ…Œå´©æºƒ\n \n","sig":null,"attributes":[{"value":"/ ç¬¬äºŒç« ï¼šRustæ ¸å¿ƒæ¦‚å¿µ","span":{"file_name":"src/ch02/s7_error_handle.rs","byte_start":126393,"byte_end":126425,"line_start":1,"line_end":1,"column_start":1,"column_end":17}},{"value":"/ 2.6 é”™è¯¯å¤„ç†","span":{"file_name":"src/ch02/s7_error_handle.rs","byte_start":126426,"byte_end":126446,"line_start":2,"line_end":2,"column_start":1,"column_end":13}},{"value":"/ ","span":{"file_name":"src/ch02/s7_error_handle.rs","byte_start":126447,"byte_end":126451,"line_start":3,"line_end":3,"column_start":1,"column_end":5}},{"value":"/ 1. ç±»å‹ç³»ç»Ÿä¿è¯å‡½æ•°å¥‘çº¦","span":{"file_name":"src/ch02/s7_error_handle.rs","byte_start":126452,"byte_end":126489,"line_start":4,"line_end":4,"column_start":1,"column_end":18}},{"value":"/ 2. æ–­è¨€ç”¨äºé˜²å¾¡","span":{"file_name":"src/ch02/s7_error_handle.rs","byte_start":126490,"byte_end":126515,"line_start":5,"line_end":5,"column_start":1,"column_end":14}},{"value":"/ 3. Option<T> æ¶ˆé™¤ç©ºæŒ‡é’ˆå¤±è´¥","span":{"file_name":"src/ch02/s7_error_handle.rs","byte_start":126516,"byte_end":126554,"line_start":6,"line_end":6,"column_start":1,"column_end":25}},{"value":"/ 4. Result<T, E> ä¼ æ’­é”™è¯¯","span":{"file_name":"src/ch02/s7_error_handle.rs","byte_start":126555,"byte_end":126587,"line_start":7,"line_end":7,"column_start":1,"column_end":25}},{"value":"/ 5. Panic ææ…Œå´©æºƒ","span":{"file_name":"src/ch02/s7_error_handle.rs","byte_start":126588,"byte_end":126613,"line_start":8,"line_end":8,"column_start":1,"column_end":18}},{"value":"/ ","span":{"file_name":"src/ch02/s7_error_handle.rs","byte_start":126614,"byte_end":126618,"line_start":9,"line_end":9,"column_start":1,"column_end":5}}]},{"kind":"Function","id":{"krate":0,"index":68},"span":{"file_name":"src/ch02/s7_error_handle.rs","byte_start":127070,"byte_end":127082,"line_start":43,"line_end":43,"column_start":8,"column_end":20},"name":"elim_failure","qualname":"::ch02::s7_error_handle::elim_failure","value":"pub fn elim_failure()","parent":null,"children":[],"decl_id":null,"docs":"# æ¶ˆé™¤å¤±è´¥","sig":null,"attributes":[{"value":"*\n\n\n# æ¶ˆé™¤å¤±è´¥\n\n1. ç±»å‹ç³»ç»Ÿä¿è¯å‡½æ•°å¥‘çº¦\n\n```rust\nfn sum(a: i32, b: i32) -> i32 {\n    a + b\n}\nfn main() {\n    sum(1u32, 2u32); // è¿åå¥‘çº¦ï¼ŒæŠ¥é”™\n}\n```\n\n2. æ–­è¨€ç”¨äºé˜²å¾¡\n\n```rust\n\nfn extend_vec(v: &mut Vec<i32>, i: i32) {\n    assert!(v.len() == 5);\n    v.push(i);\n}\nfn main() {\n    let mut vec = vec![1, 2, 3];\n    extend_vec(&mut vec, 4);\n    extend_vec(&mut vec, 5);\n    extend_vec(&mut vec, 6); // panic!\n}\n```\n*/","span":{"file_name":"src/ch02/s7_error_handle.rs","byte_start":126620,"byte_end":127062,"line_start":11,"line_end":42,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":69},"span":{"file_name":"src/ch02/s7_error_handle.rs","byte_start":129847,"byte_end":129859,"line_start":167,"line_end":167,"column_start":8,"column_end":20},"name":"error_handle","qualname":"::ch02::s7_error_handle::error_handle","value":"pub fn error_handle()","parent":null,"children":[],"decl_id":null,"docs":"# åˆ†å±‚é”™è¯¯å¤„ç†","sig":null,"attributes":[{"value":"*\n\n# åˆ†å±‚é”™è¯¯å¤„ç†\n\né”™è¯¯å¤„ç†ï¼šé¡¾åæ€ä¹‰ï¼Œå¤„ç†é”™è¯¯ã€‚æ—¢ç„¶è¦å¤„ç†é”™è¯¯ï¼Œé‚£è‚¯å®šæ˜¯æŒ‡å¼€å‘è€…å¯ä»¥å¤„ç†çš„æƒ…å†µã€‚\n\n-  Option: ã€Œæœ‰ã€ä¸ã€Œæ— ã€\n-  Result:ã€Œå¯¹ã€ä¸ã€Œé”™ã€\n\n### Option\n\n```rust\nfn get_shortest(names: Vec<&str>) -> Option<&str> {\n    if names.len() > 0 {\n        let mut shortest = names[0];\n        for name in names.iter() {\n            if name.len() < shortest.len() {\n                shortest = *name;\n            }\n        }\n        Some(shortest)\n   } else {\n       None\n   }\n}\nfn show_shortest(names: Vec<&str>) -> &str {\n   match get_shortest(names) {\n       Some(shortest) => shortest,\n       None             => \"Not Found\",\n   }\n}\nfn main(){\n   assert_eq!(show_shortest(vec![\"Uku\", \"Felipe\"]), \"Uku\");\n   assert_eq!(show_shortest(Vec::new()), \"Not Found\");\n}\n```\n\nä½¿ç”¨ Match åœ¨ ã€Œç›’å†…ã€å¤„ç† Option\n\n```rust\nfn get_shortest_length(names: Vec<&str>) -> Option<usize> {\n    match get_shortest(names) {\n        Some(shortest) => Some(shortest.len()),\n        None             => None,\n    }\n}\nfn main(){\n    assert_eq!(get_shortest_length(vec![\"Uku\",\"Felipe\"]),Some(3));\n    assert_eq!(get_shortest_length(Vec::new()), None);\n}\n```\n\nä½¿ç”¨æ ‡å‡†åº“å†…å»ºç»„åˆå­å¤„ç†ï¼š\n\n```rust\nfn double(value: f64) -> f64 {\n    value * 2.\n}\nfn square(value: f64) -> f64 {\n    value.powi(2 as i32)\n}\nfn inverse(value: f64) -> f64 {\n    value * -1.\n}\nfn log(value: f64) -> Option<f64> {\n   match value.log2() {\n       x if x.is_normal() => Some(x),\n       _                      => None\n   }\n}\nfn sqrt(value: f64) -> Option<f64> {\n   match value.sqrt() {\n       x if x.is_normal() => Some(x),\n       _                      => None\n   }\n}\nfn main () {\n   let number: f64 = 20.;\n   let result = Option::from(number)\n       .map(inverse).map(double).map(inverse)\n       .and_then(log).map(square).and_then(sqrt);\n   match result {\n       Some(x) => println!(\"Result was {}.\", x),\n       None    => println!(\"This failed.\")\n   }\n}\n```\n\n\n### Result\n\n- Error trait:[https://doc.rust-lang.org/stable/std/error/trait.Error.html](https://doc.rust-lang.org/stable/std/error/trait.Error.html)\n- Result Error Handle : [read-sum crate]\n- `?` and [std::ops::Try](https://doc.rust-lang.org/stable/std/ops/trait.Try.html)\n\n\n\n\n```rust\nuse std::num::ParseIntError;\n// fn square(number_str: &str) -> Result<i32, ParseIntError>\n// {\n//    number_str.parse::<i32>().map(|n| n.pow(2))\n// }\ntype ParseResult<T> = Result<T, ParseIntError>;\nfn square(number_str: &str) -> ParseResult<i32>\n{\n    number_str.parse::<i32>().map(|n| n.pow(2))\n}\nfn main() {\n    match square(\"10\") {\n        Ok(n) => assert_eq!(n, 100),\n        Err(err) => println!(\"Error: {:?}\", err),\n    }\n}\n```\n\n\n*/","span":{"file_name":"src/ch02/s7_error_handle.rs","byte_start":127126,"byte_end":129839,"line_start":48,"line_end":166,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":70},"span":{"file_name":"src/ch02/s7_error_handle.rs","byte_start":132450,"byte_end":132467,"line_start":242,"line_end":242,"column_start":8,"column_end":25},"name":"panic_cant_handle","qualname":"::ch02::s7_error_handle::panic_cant_handle","value":"pub fn panic_cant_handle()","parent":null,"children":[],"decl_id":null,"docs":"### panic çš„ä¸¤ç§ç±»å‹ï¼š","sig":null,"attributes":[{"value":"*\n\n### panic çš„ä¸¤ç§ç±»å‹ï¼š\n\n- Unwindingï¼ˆæ ˆå±•å¼€ï¼‰ã€‚\n- Abortingï¼ˆä¸­æ­¢ï¼‰ã€‚\n\nUnwinding å¯ä»¥ä½¿åº”ç”¨ç¨‹åºçº¿ç¨‹ä»¥ç›¸å¯¹å¹²å‡€çš„æ–¹å¼å…³é—­ã€‚ \nå›æ”¶æ‰€æœ‰åˆ†é…çš„ç³»ç»Ÿèµ„æºï¼Œæ­£ç¡®åˆ é™¤æ‰€æœ‰åº”ç”¨ç¨‹åºå¯¹è±¡ï¼Œä¾æ­¤ç±»æ¨ã€‚ \næ­¤å¤–ï¼Œææ…Œåœæ­¢åœ¨æœ‰é—®é¢˜çš„çº¿ç¨‹çš„è¾¹ç•Œï¼Œè€Œä¸æ˜¯æ€æ­»æ•´ä¸ªåº”ç”¨ç¨‹åºè¿‡ç¨‹ã€‚ \næ‰€æœ‰è¿™ä¸€åˆ‡æ„å‘³ç€ï¼Œå¦‚æœæ‰€æœ‰å¯¹è±¡éƒ½å…·æœ‰æ˜æ™ºçš„ææ„å‡½æ•°ï¼Œåˆ™å°½ç®¡æœ‰å›°éš¾ï¼Œä½†ä»å¯ä»¥ä»ç´§æ€¥æƒ…å†µä¸­æ¢å¤åº”ç”¨ç¨‹åºã€‚\n\nå¦‚æœä½ åº”ç”¨ç¨‹åºæ˜¯ä¸ºæ­¤ç›®çš„è€Œè®¾è®¡çš„ï¼Œåˆ™å¯ä»¥æ£€æµ‹åˆ°çº¿ç¨‹ç´§æ€¥æƒ…å†µå¹¶é‡æ–°å¯åŠ¨æœ‰é—®é¢˜çš„çº¿ç¨‹ï¼Œå¸Œæœ›è¯¥æ“ä½œèƒ½å¤Ÿæ­£ç¡®æ¢å¤ã€‚ \nåœ¨æ— æ³•å…³é—­åº”ç”¨ç¨‹åºçš„æƒ…å†µä¸‹ï¼Œä¾‹å¦‚åœ¨å…³é”®ç³»ç»Ÿä¸­ï¼Œç±»ä¼¼äºErlangçš„å®¹é”™æ–¹æ³•å¯èƒ½æ˜¯æœ‰æ„ä¹‰çš„ã€‚\n\nå¯¹äºAbortingï¼Œä¸å­˜åœ¨åº”ç”¨ç¨‹åºæ¢å¤çš„å¯èƒ½æ€§ã€‚ä¸€æ—¦æŸäº›ä»£ç ä¸­æ­¢ï¼Œåº”ç”¨ç¨‹åºè¿›ç¨‹å°†ç«‹å³ç»ˆæ­¢ï¼Œè¿™æ„å‘³ç€è¦å®ç°å®¹é”™åŠŸèƒ½ï¼Œå°±éœ€è¦è¿›è¡Œæ›´åŠ å¤æ‚çš„å¤šè¿›ç¨‹è®¾è®¡ã€‚ \nå¦å¤–ï¼Œç”±äºæœªè¿è¡Œèµ„æºææ„å‡½æ•°ï¼Œå› æ­¤æ•´ä¸ªç³»ç»Ÿå¯èƒ½å¤„äºä¸ä¸€è‡´çŠ¶æ€ï¼Œè¿™æ„å‘³ç€é‡æ–°å¯åŠ¨åº”ç”¨ç¨‹åºå¯èƒ½éå¸¸ä¸å®¹æ˜“ã€‚\n\næ€»è€Œè¨€ä¹‹ï¼Œä»…åº”åœ¨ç¡®å®ä¸å…³å¿ƒåº”ç”¨ç¨‹åºç«‹å³å´©æºƒå¹¶å¯èƒ½ç ´ååœ¨å´©æºƒè¿‡ç¨‹ä¸­æ“ä½œçš„ä»»ä½•ç¡¬ä»¶/æ“ä½œç³»ç»ŸçŠ¶æ€çš„æƒ…å†µä¸‹å¯ç”¨Abortingææ…Œã€‚\n\néœ€è¦äº†è§£ä¸€ä¸ªäº‹å®ï¼ŒRust ç›®å‰å¯¹ OOM(out of memory)å¯¹å¤„ç†æ˜¯ç›´æ¥ Aborting ï¼Œæ— è®ºä½ å¦‚ä½•è®¾ç½®Panicç±»å‹ã€‚\n\n### ææ…Œå®‰å…¨ï¼š \n\n[Rust Magazine #01 security](https://rustmagazine.github.io/rust_magazine_2021/chapter_1/rust_security_part1.html)\n- catch_unwind\n\n\n```rust\n\nuse std::panic;\nfn sum(a: i32, b: i32) -> i32{\n    a + b\n}\nfn main() {\n    let result = panic::catch_unwind(|| { println!(\"hello!\"); });\n    assert!(result.is_ok());\n    let result = panic::catch_unwind(|| { panic!(\"oh no!\"); });\n    assert!(result.is_err());\n   println!(\"{}\", sum(1, 2));\n}\n```\n\nä½¿ç”¨ set_hook\n\n```rust\nuse std::panic;\nfn sum(a: i32, b: i32) -> i32{\n    a + b\n}\nfn main() {\n    let result = panic::catch_unwind(|| { println!(\"hello!\"); });\n    assert!(result.is_ok());\n    panic::set_hook(Box::new(|panic_info| {\n        if let Some(location) = panic_info.location() {\n            println!(\"panic occurred '{}' at {}\",\n                location.file(), location.line()\n            );\n       } else {\n            println!(\"can't get location information...\");\n       }\n   }));\n   let result = panic::catch_unwind(|| { panic!(\"oh no!\"); });\n   assert!(result.is_err());\n   println!(\"{}\", sum(1, 2));\n}\n```\n\n\n*/","span":{"file_name":"src/ch02/s7_error_handle.rs","byte_start":129897,"byte_end":132442,"line_start":172,"line_end":241,"column_start":1,"column_end":3}}]},{"kind":"Mod","id":{"krate":0,"index":71},"span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"s8_metaprogramming","qualname":"::ch02::s8_metaprogramming","value":"src/ch02/s8_metaprogramming.rs","parent":null,"children":[{"krate":0,"index":72},{"krate":0,"index":73},{"krate":0,"index":74},{"krate":0,"index":75}],"decl_id":null,"docs":" ç¬¬äºŒç« ï¼šRustæ ¸å¿ƒæ¦‚å¿µ\n 2.7 å…ƒç¼–ç¨‹\n \n å†…å®¹åŒ…æ‹¬ï¼š\n  - åå°„\n  - å®\n     - Rust ç¼–è¯‘è¿‡ç¨‹å†è§£æ\n     - å£°æ˜å®\n         - æ ‡å‡†åº“å†…ç½®å®\n         - è‡ªå®šä¹‰å®\n     - è¿‡ç¨‹å®\n         - bang å®\n         - derive å®\n         - å±æ€§å®\n     - è¿‡ç¨‹å®å®é™…é¡¹ç›®çš„åº”ç”¨\n         - dervie_more\n         - metric\n         - reflect\n \n \n","sig":null,"attributes":[{"value":"/ ç¬¬äºŒç« ï¼šRustæ ¸å¿ƒæ¦‚å¿µ","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132508,"byte_end":132540,"line_start":1,"line_end":1,"column_start":1,"column_end":17}},{"value":"/ 2.7 å…ƒç¼–ç¨‹","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132541,"byte_end":132558,"line_start":2,"line_end":2,"column_start":1,"column_end":12}},{"value":"/ ","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132559,"byte_end":132563,"line_start":3,"line_end":3,"column_start":1,"column_end":5}},{"value":"/ å†…å®¹åŒ…æ‹¬ï¼š","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132564,"byte_end":132583,"line_start":4,"line_end":4,"column_start":1,"column_end":10}},{"value":"/  - åå°„","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132584,"byte_end":132597,"line_start":5,"line_end":5,"column_start":1,"column_end":10}},{"value":"/  - å®","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132598,"byte_end":132608,"line_start":6,"line_end":6,"column_start":1,"column_end":9}},{"value":"/     - Rust ç¼–è¯‘è¿‡ç¨‹å†è§£æ","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132609,"byte_end":132645,"line_start":7,"line_end":7,"column_start":1,"column_end":23}},{"value":"/     - å£°æ˜å®","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132646,"byte_end":132665,"line_start":8,"line_end":8,"column_start":1,"column_end":14}},{"value":"/         - æ ‡å‡†åº“å†…ç½®å®","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132666,"byte_end":132698,"line_start":9,"line_end":9,"column_start":1,"column_end":21}},{"value":"/         - è‡ªå®šä¹‰å®","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132699,"byte_end":132725,"line_start":10,"line_end":10,"column_start":1,"column_end":19}},{"value":"/     - è¿‡ç¨‹å®","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132726,"byte_end":132745,"line_start":11,"line_end":11,"column_start":1,"column_end":14}},{"value":"/         - bang å®","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132746,"byte_end":132768,"line_start":12,"line_end":12,"column_start":1,"column_end":21}},{"value":"/         - derive å®","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132769,"byte_end":132793,"line_start":13,"line_end":13,"column_start":1,"column_end":23}},{"value":"/         - å±æ€§å®","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132794,"byte_end":132817,"line_start":14,"line_end":14,"column_start":1,"column_end":18}},{"value":"/     - è¿‡ç¨‹å®å®é™…é¡¹ç›®çš„åº”ç”¨","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132818,"byte_end":132858,"line_start":15,"line_end":15,"column_start":1,"column_end":21}},{"value":"/         - dervie_more","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132859,"byte_end":132884,"line_start":16,"line_end":16,"column_start":1,"column_end":26}},{"value":"/         - metric","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132885,"byte_end":132905,"line_start":17,"line_end":17,"column_start":1,"column_end":21}},{"value":"/         - reflect","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132906,"byte_end":132927,"line_start":18,"line_end":18,"column_start":1,"column_end":22}},{"value":"/ ","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132928,"byte_end":132932,"line_start":19,"line_end":19,"column_start":1,"column_end":5}},{"value":"/ ","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132933,"byte_end":132937,"line_start":20,"line_end":20,"column_start":1,"column_end":5}}]},{"kind":"Function","id":{"krate":0,"index":72},"span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":134847,"byte_end":134860,"line_start":115,"line_end":115,"column_start":8,"column_end":21},"name":"any_refection","qualname":"::ch02::s8_metaprogramming::any_refection","value":"pub fn any_refection()","parent":null,"children":[],"decl_id":null,"docs":"   # åŠ¨æ€è‡ªçœ","sig":null,"attributes":[{"value":"*\n   \n   # åŠ¨æ€è‡ªçœ\n\n   ç¤ºä¾‹1:\n\n   [https://doc.rust-lang.org/std/any/index.html](https://doc.rust-lang.org/std/any/index.html)\n\n    ç¤ºä¾‹2:\n\n    ```rust\n\n    use std::any::Any;\n\n    trait Foo: Any {\n        fn as_any(&self) -> &Any;\n    }\n\n    impl<T: Any> Foo for T {\n        fn as_any(&self) -> &Any {\n            self\n        }\n    }\n\n    struct Bar {}\n\n    struct Baz {}\n\n    impl PartialEq for Foo {\n        fn eq(&self, other: &Foo) -> bool {\n            let me = self.as_any();\n            let you = other.as_any();\n            if me.is::<Bar>() && you.is::<Bar>() {\n                true\n            } else if me.is::<Baz>() && you.is::<Baz>() {\n                true\n            } else {\n                false\n            }\n        }\n    }\n\n    fn main() {\n        let bar: Bar = Bar {};\n        let baz: Baz = Baz {};\n        let foo1: &Foo = &bar;\n        let foo2: &Foo = &baz;\n        println!(\"{:?}\", foo1 == foo2);\n    }\n\n    ```\n\n    ç¤ºä¾‹ 3:\n\n    ```rust\n        use std::any::Any;\n        struct UnStatic<'a> { x: &'a i32 }\n        fn main() {\n            let a = 42;\n            let v = UnStatic { x: &a };\n            let mut any: &Any;\n            //any = &v;  // Compile Error!\n        }\n    ```\n    \n    ä¿®æ­£ï¼š\n\n    ```rust\n    use std::any::Any;\n    struct UnStatic<'a> { x: &'a i32 }\n    static ANSWER: i32 = 42;\n    fn main() {\n        let v = UnStatic { x: &ANSWER };\n        let mut a: &Any;\n        a = &v;\n        assert!(a.is::<UnStatic>());\n    }\n    ```\n\n    ç¤ºä¾‹4:\n\n    oso åº“åº”ç”¨\n\n    [https://github.com/osohq/oso/blob/main/languages/rust/oso/src/host/class.rs](https://github.com/osohq/oso/blob/main/languages/rust/oso/src/host/class.rs)\n\n    ç¤ºä¾‹ 5:\n\n    bevy_reflect åº“åº”ç”¨\n\n    [https://github.com/bevyengine/bevy/blob/main/crates/bevy_reflect/src/lib.rs](https://github.com/bevyengine/bevy/blob/main/crates/bevy_reflect/src/lib.rs)\n\n */","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132940,"byte_end":134839,"line_start":23,"line_end":114,"column_start":1,"column_end":4}}]},{"kind":"Function","id":{"krate":0,"index":73},"span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":139027,"byte_end":139045,"line_start":312,"line_end":312,"column_start":8,"column_end":26},"name":"declarative_macros","qualname":"::ch02::s8_metaprogramming::declarative_macros","value":"pub fn declarative_macros()","parent":null,"children":[],"decl_id":null,"docs":"  # å£°æ˜å®","sig":null,"attributes":[{"value":"*\n  # å£°æ˜å®\n\n  å®å±•å¼€å‘½ä»¤ï¼š cargo rustc -- -Z unstable-options --pretty=expanded\n\n  ç¤ºä¾‹1:\n\n  ```rust\n    macro_rules! unless {\n        ($arg:expr, $branch:expr) => ( if !$arg { $branch };); \n    } \n    fn cmp(a: i32, b: i32) {\n        unless!( a > b, {\n            println!(\"{} < {}\", a, b);\n        });\n    }\n    fn main() {\n        let (a, b) = (1, 2);\n        cmp(a, b);\n    }\n  ```\n\n  æ”¯æŒ token ç±»å‹ï¼š\n\n  ```text\n        item â€” an item, like a function, struct, module, etc.\n        block â€” a block (i.e. a block of statements and/or an expression, surrounded by braces)\n        stmt â€” a statement\n        pat â€” a pattern\n        expr â€” an expression\n        ty â€” a type\n        ident â€” an identifier\n        path â€” a path (e.g., foo, ::std::mem::replace, transmute::<_, int>, â€¦)\n        meta â€” a meta item; the things that go inside #[...] and #![...] attributes\n        tt â€” a single token tree\n        vis â€” a possibly empty Visibility qualifier\n  ```\n\n\n  ç¤ºä¾‹2:\n\n  ```rust\n\n    macro_rules! hashmap {\n        ($($key:expr => $value:expr),* ) => {\n            {\n                let mut _map = ::std::collections::HashMap::new();\n                $(  \n                    _map.insert($key, $value); \n                )*\n                _map\n            }\n        };\n    }\n    fn main(){\n        let map = hashmap!{\n            \"a\" => 1,\n            \"b\" => 2\n        //  \"c\" => 3, // V1.0ä¸æ”¯æŒç»“å°¾æœ‰é€—å·\n        };\n        assert_eq!(map[\"a\"], 1);\n    }\n\n  ```\n\n  ç¤ºä¾‹3:\n\n  ```rust\n    macro_rules! hashmap {\n        ($($key:expr => $value:expr,)*) =>\n            {  hashmap!($($key => $value),*) };\n        ($($key:expr => $value:expr),* ) => {\n            {\n                let mut _map = ::std::collections::HashMap::new();\n                $(\n                    _map.insert($key, $value);\n                )*\n            _map\n        }\n    };\n    }\n    fn main(){\n        let map = hashmap!{\n            \"a\" => 1,\n            \"b\" => 2,\n            \"c\" => 3, \n        };\n        assert_eq!(map[\"a\"], 1);\n    }\n  ```\n\n  ç¤ºä¾‹4:\n\n  ```rust\n    macro_rules! hashmap {\n        ($($key:expr => $value:expr),* $(,)*) => {\n            {\n                let mut _map = ::std::collections::HashMap::new();\n                $(\n                    _map.insert($key, $value);\n                )*\n                _map\n            }\n    };\n    }\n    fn main(){\n        let map = hashmap!{\n            \"a\" => 1,\n            \"b\" => 2,\n            \"c\" => 3, \n        };\n        assert_eq!(map[\"a\"], 1);\n    }\n\n  ```\n\n  ç¤ºä¾‹5:\n\n  ```rust\n    macro_rules! unit {\n        ($($x:tt)*) => (());\n    }\n    macro_rules! count {\n        ($($key:expr),*) => (<[()]>::len(&[$(unit!($key)),*]));\n    }\n    macro_rules! hashmap {\n        ($($key:expr => $value:expr),* $(,)*) => {\n            {\n            let _cap = count!($($key),*);\n            let mut _map \n                = ::std::collections::HashMap::with_capacity(_cap);\n            $(\n                _map.insert($key, $value);\n            )*\n            _map\n        }\n    };\n    }\n    fn main(){\n        let map = hashmap!{\n            \"a\" => 1,\n            \"b\" => 2,\n            \"c\" => 3, \n        };\n        assert_eq!(map[\"a\"], 1);\n    }\n\n  ```\n\n  ç¤ºä¾‹6: \n\n  ```rust\n    macro_rules! hashmap {\n        (@unit $($x:tt)*) => (());\n        (@count $($rest:expr),*) => \n            (<[()]>::len(&[$(hashmap!(@unit $rest)),*]));\n        ($($key:expr => $value:expr),* $(,)*) => {\n            {\n                let _cap = hashmap!(@count $($key),*);\n                let mut _map = \n                    ::std::collections::HashMap::with_capacity(_cap);\n            $(\n                _map.insert($key, $value);\n            )*\n            _map\n        }\n    };\n    }\n    fn main(){\n    let map = hashmap!{\n        \"a\" => 1,\n        \"b\" => 2,\n        \"c\" => 3, \n    };\n    assert_eq!(map[\"a\"], 1);\n    }\n  ```\n\n  ç¤ºä¾‹7:\n\n  ```rust\n    macro_rules! sum {\n        ($e:expr) => ({\n            let a = 2;\n            $e + a\n        })\n    }\n    fn main(){\n        // error[E0425]: cannot find value `a` in this scope\n        let four = sum!(a);\n    }\n  ```\n*/","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":134868,"byte_end":139019,"line_start":119,"line_end":311,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":74},"span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":142063,"byte_end":142081,"line_start":425,"line_end":425,"column_start":8,"column_end":26},"name":"derive_proc_macros","qualname":"::ch02::s8_metaprogramming::derive_proc_macros","value":"pub fn derive_proc_macros()","parent":null,"children":[],"decl_id":null,"docs":"ä»‹ç»ï¼š[serde.rs](https://serde.rs/)","sig":null,"attributes":[{"value":"*\n\nä»‹ç»ï¼š[serde.rs](https://serde.rs/)\n\nå‚é˜… :  [https://github.com/ZhangHanDong/proc_codegen](https://github.com/ZhangHanDong/proc_codegen)\n\nè¿‡ç¨‹å®ä¸‰ä»¶å¥—ï¼š\n\n- [syn](https://github.com/dtolnay/syn)\n- [quote](https://github.com/dtolnay/quote)\n- [proc-macro2](https://github.com/alexcrichton/proc-macro2)\n\nç¤ºä¾‹ï¼šå°è£… Diesel æ–¹ä¾¿ crud\n\n```rust\n\n    // find_by_or!{ Person -> people::[name:String || company_name:String]   }\n\n    use super::*;\n\n    pub struct DbOpByOrBy {\n        pub model: Type,\n        pub table: Ident,\n        pub bracket_token: token::Bracket,\n        pub content: FieldContentOr,\n    }\n\n    pub struct FieldContentOr {\n        pub name1: Ident,\n        pub ty1: Type,\n        pub name2: Ident,\n        pub ty2: Type,\n    }\n\n    impl Parse for DbOpByOrBy {\n        fn parse(input: ParseStream) -> Result<Self> {\n            let content;\n            let model: Type = input.parse()?;\n            input.parse::<Token![->]>()?;\n            let table: Ident = input.parse()?;\n            input.parse::<Token![::]>()?;\n            let bracket_token = bracketed!(content in input);\n            let content = content.parse()?;\n            Ok(DbOpByOrBy {\n                model,\n                table,\n                bracket_token,\n                content,\n            })\n        }\n    }\n\n    impl Parse for FieldContentOr {\n        fn parse(input: ParseStream) -> Result<Self> {\n            let name1: Ident = input.parse()?;\n            input.parse::<Token![:]>()?;\n            let ty1: Type = input.parse()?;\n            input.parse::<Token![||]>()?;\n            let name2: Ident = input.parse()?;\n            input.parse::<Token![:]>()?;\n            let ty2: Type = input.parse()?;\n            Ok(FieldContentOr {\n                name1,\n                ty1,\n                name2,\n                ty2,\n            })\n        }\n    }\n\n    // in lib.rs\n\n    // find_by_or!{ Person -> people::[name:String || company_name:String]   }\n\n    #[proc_macro]\n    pub fn find_by_or(input: TokenStream) -> TokenStream {\n        let DbOpByOrBy {\n            model,\n            table,\n            bracket_token,\n            content,\n        } = parse_macro_input!(input as DbOpByOrBy);\n        let (name1, name2) = (content.name1, content.name2);\n        let (ty1, ty2) = (content.ty1, content.ty2);\n        let fn_name = format!(\"find_by_{}_or_{}\", name1, name2);\n        let fn_name = Ident::new(&fn_name, proc_macro2::Span::call_site());\n\n        let expanded = quote! {\n            impl #model {\n                pub fn #fn_name(conn: &PgConnection, #name1: #ty1, #name2: #ty2) -> QueryResult<#model> {\n                    #table::table\n                    .filter(#table::dsl::#name1.eq(#name1))\n                    .or_filter(#table::dsl::#name2.eq(#name2))\n                    .get_result(conn)\n                }\n            }\n        };\n        TokenStream::from(expanded)\n    }\n\n\n```\n\næœ‰ç”¨çš„ç¬¬ä¸‰æ–¹åº“ï¼š\n\n- [derive_more](https://github.com/JelteF/derive_more)\n\n*/","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":139054,"byte_end":142055,"line_start":317,"line_end":424,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":75},"span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":142353,"byte_end":142375,"line_start":441,"line_end":441,"column_start":8,"column_end":30},"name":"attributes_proc_macros","qualname":"::ch02::s8_metaprogramming::attributes_proc_macros","value":"pub fn attributes_proc_macros()","parent":null,"children":[],"decl_id":null,"docs":"    # å±æ€§å®","sig":null,"attributes":[{"value":"*\n\n    # å±æ€§å®\n\n    æ¡ˆä¾‹ï¼š[magnet/metered-rs](https://github.com/magnet/metered-rs)\n\n    æœ‰ç”¨çš„ç¬¬ä¸‰æ–¹åº“ä»‹ç»ï¼š[darling](https://github.com/TedDriggs/darling)\n\n    æ¡ˆä¾‹ï¼š [elichai/log-derive](https://github.com/elichai/log-derive)\n \n\n*/","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":142089,"byte_end":142345,"line_start":429,"line_end":440,"column_start":1,"column_end":3}}]},{"kind":"Mod","id":{"krate":0,"index":76},"span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"s9_unsafe_rust","qualname":"::ch02::s9_unsafe_rust","value":"src/ch02/s9_unsafe_rust.rs","parent":null,"children":[{"krate":0,"index":77},{"krate":0,"index":78},{"krate":0,"index":79}],"decl_id":null,"docs":" ç¬¬äºŒç« ï¼šRustæ ¸å¿ƒæ¦‚å¿µ\n 2.8 Unsafe Rust\n \n å†…å®¹åŒ…æ‹¬ï¼š\n \n - ä»€ä¹ˆæ˜¯ Unsafe Rust ï¼Ÿ\n     \n - Unsafe Rust å®‰å…¨æŠ½è±¡\n     - drop æ£€æŸ¥\n     - Unbound Lifetime\n     - å‹å˜\n \n - æ ‡å‡†åº“ [LinkedList æºç ](https://doc.rust-lang.org/stable/src/alloc/collections/linked_list.rs.html#38-43)å¯¼è¯»","sig":null,"attributes":[{"value":"/ ç¬¬äºŒç« ï¼šRustæ ¸å¿ƒæ¦‚å¿µ","span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":142380,"byte_end":142412,"line_start":1,"line_end":1,"column_start":1,"column_end":17}},{"value":"/ 2.8 Unsafe Rust","span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":142413,"byte_end":142432,"line_start":2,"line_end":2,"column_start":1,"column_end":20}},{"value":"/ ","span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":142433,"byte_end":142437,"line_start":3,"line_end":3,"column_start":1,"column_end":5}},{"value":"/ å†…å®¹åŒ…æ‹¬ï¼š","span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":142438,"byte_end":142457,"line_start":4,"line_end":4,"column_start":1,"column_end":10}},{"value":"/ ","span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":142458,"byte_end":142462,"line_start":5,"line_end":5,"column_start":1,"column_end":5}},{"value":"/ - ä»€ä¹ˆæ˜¯ Unsafe Rust ï¼Ÿ","span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":142463,"byte_end":142494,"line_start":6,"line_end":6,"column_start":1,"column_end":24}},{"value":"/     ","span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":142495,"byte_end":142503,"line_start":7,"line_end":7,"column_start":1,"column_end":9}},{"value":"/ - Unsafe Rust å®‰å…¨æŠ½è±¡","span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":142504,"byte_end":142534,"line_start":8,"line_end":8,"column_start":1,"column_end":23}},{"value":"/     - drop æ£€æŸ¥","span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":142535,"byte_end":142556,"line_start":9,"line_end":9,"column_start":1,"column_end":18}},{"value":"/     - Unbound Lifetime","span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":142557,"byte_end":142583,"line_start":10,"line_end":10,"column_start":1,"column_end":27}},{"value":"/     - å‹å˜","span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":142584,"byte_end":142600,"line_start":11,"line_end":11,"column_start":1,"column_end":13}},{"value":"/ ","span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":142601,"byte_end":142605,"line_start":12,"line_end":12,"column_start":1,"column_end":5}},{"value":"/ - æ ‡å‡†åº“ [LinkedList æºç ](https://doc.rust-lang.org/stable/src/alloc/collections/linked_list.rs.html#38-43)å¯¼è¯»","span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":142606,"byte_end":142729,"line_start":13,"line_end":13,"column_start":1,"column_end":110}},{"value":"/","span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":142730,"byte_end":142733,"line_start":14,"line_end":14,"column_start":1,"column_end":4}},{"value":"/  - Unsafe å·¥å…·é›†ä»‹ç»","span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":142734,"byte_end":142763,"line_start":15,"line_end":15,"column_start":1,"column_end":20}}]},{"kind":"Function","id":{"krate":0,"index":77},"span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":145117,"byte_end":145129,"line_start":86,"line_end":86,"column_start":8,"column_end":20},"name":"unsafe_intro","qualname":"::ch02::s9_unsafe_rust::unsafe_intro","value":"pub fn unsafe_intro()","parent":null,"children":[],"decl_id":null,"docs":"    # Unsafe Rust ä»‹ç»","sig":null,"attributes":[{"value":"*\n\n    # Unsafe Rust ä»‹ç»\n\n    ç¤ºä¾‹1: Unsafe Rust æ˜¯ Safe Rust çš„è¶…é›†\n\n    ```rust\n        fn main(){\n            unsafe {\n                let mut a = \"hello\";\n                let b = &a;\n                let c = &mut a;\n            }\n        }\n    ```\n\n  Unsafe Rustæ˜¯æŒ‡ï¼Œåœ¨è¿›è¡Œä»¥ä¸‹äº”ç§æ“ä½œçš„æ—¶å€™ï¼Œå¹¶ä¸ä¼šæä¾›ä»»ä½•å®‰å…¨æ£€æŸ¥ï¼š\n\n    - è§£å¼•ç”¨è£¸æŒ‡é’ˆã€‚\n    - è°ƒç”¨unsafeçš„å‡½æ•°æˆ–æ–¹æ³•ã€‚\n    - è®¿é—®æˆ–ä¿®æ”¹å¯å˜é™æ€å˜é‡ã€‚\n    - å®ç°unsafe traitã€‚\n    - è¯»å†™Unionè”åˆä½“ä¸­çš„å­—æ®µã€‚\n\n    è§£å¼•ç”¨è£¸æŒ‡é’ˆ\n\n    - Rustæä¾›äº†*const Tï¼ˆä¸å˜ï¼‰å’Œ*mut Tï¼ˆå¯å˜ï¼‰ä¸¤ç§æŒ‡é’ˆç±»å‹ã€‚å› ä¸ºè¿™ä¸¤ç§æŒ‡é’ˆå’ŒCè¯­è¨€ä¸­çš„æŒ‡é’ˆååˆ†ç›¸è¿‘ï¼Œæ‰€ä»¥å«å…¶åŸç”ŸæŒ‡é’ˆï¼ˆRaw Pointerï¼‰ã€‚\n    \n    åŸç”ŸæŒ‡é’ˆå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š\n    - å¹¶ä¸ä¿è¯æŒ‡å‘åˆæ³•çš„å†…å­˜ã€‚æ¯”å¦‚å¾ˆå¯èƒ½æ˜¯ä¸€ä¸ªç©ºæŒ‡é’ˆã€‚\n    - ä¸èƒ½åƒæ™ºèƒ½æŒ‡é’ˆé‚£æ ·è‡ªåŠ¨æ¸…ç†å†…å­˜ã€‚éœ€è¦åƒCè¯­è¨€é‚£æ ·æ‰‹åŠ¨ç®¡ç†å†…å­˜ã€‚\n    - æ²¡æœ‰ç”Ÿå‘½å‘¨æœŸçš„æ¦‚å¿µï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œç¼–è¯‘å™¨ä¸ä¼šå¯¹å…¶æä¾›å€Ÿç”¨æ£€æŸ¥ã€‚\n    - ä¸èƒ½ä¿è¯çº¿ç¨‹å®‰å…¨ã€‚\n\n     å¯è§ï¼ŒåŸç”ŸæŒ‡é’ˆå¹¶ä¸å—Safe Rustæä¾›çš„é‚£ä¸€å±‚â€œå®‰å…¨å¤–è¡£â€ä¿æŠ¤ï¼Œæ‰€ä»¥ä¹Ÿè¢«ç§°ä¸ºâ€œè£¸æŒ‡é’ˆâ€ã€‚æ‰€ä»¥ï¼Œåœ¨å¯¹è£¸æŒ‡é’ˆè¿›è¡Œè§£å¼•ç”¨æ“ä½œçš„æ—¶å€™ï¼Œå±äºä¸å®‰å…¨è¡Œä¸ºã€‚\n\n\n    Unsafeè¯­æ³•  \n\n    é€šè¿‡unsafeå…³é”®å­—å’Œunsafeå—å°±å¯ä»¥ä½¿ç”¨Unsafe Rustï¼Œå®ƒä»¬çš„ä½œç”¨å¦‚ä¸‹ï¼š\n\n    - unsafeå…³é”®å­—ï¼Œç”¨äºæ ‡è®°ï¼ˆæˆ–è€…è¯´å£°æ˜ï¼‰å‡½æ•°ã€æ–¹æ³•å’Œtraitã€‚\n    - unsafeå—ï¼Œç”¨äºæ‰§è¡ŒUnsafe Rustå…è®¸çš„äº”ç§æ“ä½œã€‚\n\n    æŸ¥çœ‹æ ‡å‡†åº“Stringä¸­çš„ unsafe å‡½æ•°[from_utf8_unchecked](https://doc.rust-lang.org/stable/std/str/fn.from_utf8_unchecked.html)ï¼Œçœ‹çœ‹ä¸ºä»€ä¹ˆæ˜¯Unsafeçš„ã€‚\n\n    è¿™é‡Œæœ€å¤§çš„é£é™©åœ¨äºï¼Œå¦‚æœä¸€ä¸ªå‡½æ•°å­˜åœ¨è¿åâ€œå¥‘çº¦â€çš„é£é™©ï¼Œè€Œå¼€å‘è€…å¹¶æ²¡æœ‰ä½¿ç”¨unsafeå…³é”®å­—å°†å…¶æ ‡è®°ï¼Œé‚£è¯¥å‡½æ•°å°±å¾ˆå¯èƒ½ä¼šæˆä¸ºBugçš„æ¸©åºŠã€‚\n    è¢«unsafeå…³é”®å­—æ ‡è®°çš„ä¸å®‰å…¨å‡½æ•°æˆ–æ–¹æ³•ï¼Œåªèƒ½åœ¨unsafeå—ä¸­è¢«è°ƒç”¨ã€‚\n\n    \n\n    ç¤ºä¾‹2:\n\n    ```rust\n    static mut COUNTER: u32 = 0;\n    fn main() {\n        let inc = 3;\n        unsafe {\n            COUNTER += inc;\n            println!(\"COUNTER: {}\", COUNTER);\n        }\n    }\n    ```\n\n    Safe Rust æ˜¯åŸºäºå¾ˆå¤š Unsafe Rust å®ç°çš„ï¼Œé‚£ä¹ˆ Safe Rust å‡­ä»€ä¹ˆ Safe ï¼Ÿ\n\n*/","span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":142767,"byte_end":145109,"line_start":19,"line_end":85,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":78},"span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":157331,"byte_end":157348,"line_start":584,"line_end":584,"column_start":8,"column_end":25},"name":"security_abstract","qualname":"::ch02::s9_unsafe_rust::security_abstract","value":"pub fn security_abstract()","parent":null,"children":[],"decl_id":null,"docs":"    # å®‰å…¨æŠ½è±¡","sig":null,"attributes":[{"value":"*\n\n    # å®‰å…¨æŠ½è±¡\n\n    ä»€ä¹ˆå«å®‰å…¨æŠ½è±¡ï¼Ÿ æœ€ç®€å•çš„ç¤ºä¾‹ï¼š\n\n    ```rust\n    fn unbound_lifetime_foo<'a>(input: *const u32) -> &'a u32 {\n        unsafe {\n            return &*input\n        }\n    }\n\n    fn normal_foo<'a>(input: &'a u32) -> &'a u32 {\n        &input\n        \n    }\n\n    fn main() {\n        let x;\n        { // -----------------------------------------------------------------------------------  `y` lifetime start\n            // unbound lifetime broken lifetime\n            let y = 7;\n            x = unbound_lifetime_foo(&y);\n            \n            // normal lifetime will error: error[E0597]: `y` does not live long enough\n            // let y = 8;\n            // x = normal_foo(&y);\n        } // ----------------------------------------------------------------------------------- `y` lifetime end\n        println!(\"hello: {}\", x);\n    }\n    ```\n\n    ç¤ºä¾‹2:\n\n    ```rust\n    pub fn insert(&mut self, index: usize, element: T) {\n        let len = self.len();\n        // é€šè¿‡è¯¥æ–­è¨€ä¿è¯äº†æ•°ç»„ä¸èƒ½è¶Šç•Œ\n        assert!(index <= len);\n        // é€šè¿‡åˆ¤æ–­é•¿åº¦æ˜¯å¦è¾¾åˆ°å®¹é‡æé™æ¥å†³å®šæ˜¯å¦è¿›è¡Œæ‰©å®¹\n        if len == self.buf.cap() {\n            self.reserve(1);\n        }\n        unsafe {\n            {\n                let p = self.as_mut_ptr().offset(index as isize);\n                ptr::copy(p, p.offset(1), len - index);\n                ptr::write(p, element);\n            }\n            self.set_len(len + 1);\n        }\n    }\n    ```\n\n\n    ### Drop check \n    \n    ç¤ºä¾‹1ï¼šæ­£å¸¸çš„drop check\n\n    ```rust\n    #![allow(unused)]\n    #![allow(unused)]\n    #![feature(alloc_layout_extra)]\n    #![feature(dropck_eyepatch)]\n    use std::alloc::{GlobalAlloc, Layout, System};\n    use std::fmt;\n    use std::marker::PhantomData;\n    use std::mem;\n    use std::ptr;\n\n    #[derive(Copy, Clone, Debug)]\n\n    enum State {\n        InValid,\n        Valid,\n    }\n\n    #[derive(Debug)]\n    struct Hello<T: fmt::Debug>(&'static str, T, State);\n    impl<T: fmt::Debug> Hello<T> {\n        fn new(name: &'static str, t: T) -> Self {\n            Hello(name, t, State::Valid)\n        }\n    }\n    impl<T: fmt::Debug> Drop for Hello<T> {\n        fn drop(&mut self) {\n            println!(\"drop Hello({}, {:?}, {:?})\", self.0, self.1, self.2);\n            self.2 = State::InValid;\n        }\n    }\n    struct WrapBox<T> {\n        v: Box<T>,\n    }\n    impl<T> WrapBox<T> {\n        fn new(t: T) -> Self {\n            WrapBox { v: Box::new(t) }\n        }\n    }\n    fn f1() {\n        let x;\n        let y;\n        x = Hello::new(\"x\", 13);\n        y = WrapBox::new(Hello::new(\"y\", &x));\n    }\n\n    struct MyBox<T> {\n        v: *const T,\n    }\n    impl<T> MyBox<T> {\n        fn new(t: T) -> Self {\n            unsafe {\n                let p = System.alloc(Layout::array::<T>(1).unwrap());\n                let p = p as *mut T;\n                ptr::write(p, t);\n                MyBox {\n                    v: p, \n                }\n            }\n        }\n    }\n\n\n    impl< T> Drop for MyBox<T> {\n        fn drop(&mut self) {\n            unsafe {\n                let p = self.v as *mut _;\n                System.dealloc(p, Layout::array::<T>(mem::align_of::<T>()).unwrap());\n            }\n        }\n    }\n\n\n    fn f2() {\n        {\n            let (x1, y1);\n            x1 = Hello::new(\"x1\", 13);\n            y1 = MyBox::new(Hello::new(\"y1\", &x1));\n        }\n        {\n            let (y2,x2 ); // æ­¤å¤„äº¤æ¢ï¼Œä¼šæŠ¥é”™ï¼Œæ³¨æ„ç¼–è¯‘é”™è¯¯\n            x2 = Hello::new(\"x2\", 13);\n            y2 = MyBox::new(Hello::new(\"y2\", &x2));\n        }\n    }\n\n    fn main() {\n        f1();\n        f2();\n    }\n\n    ```\n\n    ä½¿ç”¨ æ”¹è¿›ï¼š\n\n    ```rust\n    #![allow(unused)]\n    #![allow(unused)]\n    #![feature(alloc_layout_extra)]\n    #![feature(dropck_eyepatch)]\n    use std::alloc::{GlobalAlloc, Layout, System};\n    use std::fmt;\n    use std::marker::PhantomData;\n    use std::mem;\n    use std::ptr;\n\n    #[derive(Copy, Clone, Debug)]\n\n    enum State {\n        InValid,\n        Valid,\n    }\n\n    #[derive(Debug)]\n    struct Hello<T: fmt::Debug>(&'static str, T, State);\n    impl<T: fmt::Debug> Hello<T> {\n        fn new(name: &'static str, t: T) -> Self {\n            Hello(name, t, State::Valid)\n        }\n    }\n    impl<T: fmt::Debug> Drop for Hello<T> {\n        fn drop(&mut self) {\n            println!(\"drop Hello({}, {:?}, {:?})\", self.0, self.1, self.2);\n            self.2 = State::InValid;\n        }\n    }\n    struct WrapBox<T> {\n        v: Box<T>,\n    }\n    impl<T> WrapBox<T> {\n        fn new(t: T) -> Self {\n            WrapBox { v: Box::new(t) }\n        }\n    }\n    fn f1() {\n        let x;\n        let y;\n        x = Hello::new(\"x\", 13);\n        y = WrapBox::new(Hello::new(\"y\", &x));\n    }\n\n    struct MyBox<T> {\n        v: *const T,\n    }\n    impl<T> MyBox<T> {\n        fn new(t: T) -> Self {\n            unsafe {\n                let p = System.alloc(Layout::array::<T>(1).unwrap());\n                let p = p as *mut T;\n                ptr::write(p, t);\n                MyBox {\n                    v: p, \n                }\n            }\n        }\n    }\n\n\n    unsafe impl<#[may_dangle] T> Drop for MyBox<T> {\n        fn drop(&mut self) {\n            unsafe {\n                let p = self.v as *mut _;\n                System.dealloc(p, Layout::array::<T>(mem::align_of::<T>()).unwrap());\n            }\n        }\n    }\n\n    fn f2() {\n        {\n            let (x1, y1);\n            x1 = Hello::new(\"x1\", 13);\n            y1 = MyBox::new(Hello::new(\"y1\", &x1));\n        }\n        {\n            let (y2,x2 ); // æ­¤å¤„æ”¹å˜\n            x2 = Hello::new(\"x2\", 13);\n            y2 = MyBox::new(Hello::new(\"y2\", &x2));\n        }\n    }\n\n    fn main() {\n        f1();\n        f2();\n    }\n\n    ```\n\n    ä½¿ç”¨ PhantomData é˜²æ­¢å‡ºç° UB:\n\n    ```rust\n    #![allow(unused)]\n    #![allow(unused)]\n    #![feature(alloc_layout_extra)]\n    #![feature(dropck_eyepatch)]\n    use std::alloc::{GlobalAlloc, Layout, System};\n    use std::fmt;\n    use std::marker::PhantomData;\n    use std::mem;\n    use std::ptr;\n\n    #[derive(Copy, Clone, Debug)]\n\n    enum State {\n        InValid,\n        Valid,\n    }\n\n    #[derive(Debug)]\n    struct Hello<T: fmt::Debug>(&'static str, T, State);\n    impl<T: fmt::Debug> Hello<T> {\n        fn new(name: &'static str, t: T) -> Self {\n            Hello(name, t, State::Valid)\n        }\n    }\n    impl<T: fmt::Debug> Drop for Hello<T> {\n        fn drop(&mut self) {\n            println!(\"drop Hello({}, {:?}, {:?})\", self.0, self.1, self.2);\n            self.2 = State::InValid;\n        }\n    }\n    struct WrapBox<T> {\n        v: Box<T>,\n    }\n    impl<T> WrapBox<T> {\n        fn new(t: T) -> Self {\n            WrapBox { v: Box::new(t) }\n        }\n    }\n    fn f1() {\n        let x;\n        let y;\n        x = Hello::new(\"x\", 13);\n        y = WrapBox::new(Hello::new(\"y\", &x));\n    }\n\n    struct MyBox<T> {\n        v: *const T,\n        // _pd: PhantomData<T>,\n    }\n    impl<T> MyBox<T> {\n        fn new(t: T) -> Self {\n            unsafe {\n                let p = System.alloc(Layout::array::<T>(1).unwrap());\n                let p = p as *mut T;\n                ptr::write(p, t);\n                MyBox {\n                    v: p, \n                    // _pd: Default::default()\n                }\n            }\n        }\n    }\n\n\n    unsafe impl<#[may_dangle] T> Drop for MyBox<T> {\n        fn drop(&mut self) {\n            unsafe {\n                ptr::read(self.v); // æ­¤å¤„æ–°å¢ï¼Œå‡ºç°UB (use after free,UAF)\n                let p = self.v as *mut _;\n                System.dealloc(p, Layout::array::<T>(mem::align_of::<T>()).unwrap());\n            }\n        }\n    }\n\n    fn f2() {\n        {\n            let (x1, y1);\n            x1 = Hello::new(\"x1\", 13);\n            y1 = MyBox::new(Hello::new(\"y1\", &x1));\n        }\n        {\n            let (y2,x2 ); // æ­¤å¤„æ”¹å˜\n            x2 = Hello::new(\"x2\", 13);\n            y2 = MyBox::new(Hello::new(\"y2\", &x2));\n        }\n    }\n\n    fn main() {\n        f1();\n        f2();\n    }\n\n    ```\n\n\n\n    ç¤ºä¾‹ï¼šå‹å˜\n\n    åœ¨ä¸€é—¨ç¨‹åºè®¾è®¡è¯­è¨€çš„ç±»å‹ç³»ç»Ÿä¸­ï¼Œä¸€ä¸ªç±»å‹è§„åˆ™æˆ–è€…ç±»å‹æ„é€ å™¨æ˜¯ï¼š\n\n    - åå˜ï¼ˆcovariantï¼‰ï¼Œå¦‚æœå®ƒä¿æŒäº†å­ç±»å‹åºå…³ç³»â‰¦ã€‚è¯¥åºå…³ç³»æ˜¯ï¼šå­ç±»å‹â‰¦åŸºç±»å‹ã€‚\n    - é€†å˜ï¼ˆcontravariantï¼‰ï¼Œå¦‚æœå®ƒé€†è½¬äº†å­ç±»å‹åºå…³ç³»ã€‚\n    - ä¸å˜ï¼ˆinvariantï¼‰ï¼Œå¦‚æœä¸Šè¿°ä¸¤ç§å‡ä¸é€‚ç”¨ã€‚\n\n    Rust é‡Œå”¯ä¸€çš„ç±»å‹çˆ¶å­å…³ç³»æ˜¯ç”Ÿå‘½å‘¨æœŸï¼š`'a: 'b` ã€‚æ¯”å¦‚ï¼Œ`'static: 'a` ï¼Œå¹¶ä¸”é»˜è®¤éƒ½æ˜¯åå˜ï¼Œå”¯ä¸€é€†å˜çš„åœ°æ–¹åœ¨ `fn(T)`\n\n    `'static: 'a` å¯¹åº”ï¼š `å­ç±»å‹: çˆ¶ç±»å‹`ã€‚\n\n    - åå˜ï¼š èƒ½ç”¨ 'a çš„åœ°æ–¹ï¼Œä¹Ÿå¯ä»¥ç”¨ 'staticã€‚\n    - é€†å˜ï¼š èƒ½ç”¨ 'static çš„åœ°æ–¹ï¼Œå¯ä»¥å¯ä»¥ç”¨ 'aã€‚\n\n    è§„åˆ™ï¼š\n\n    PhantomDataè§„åˆ™ï¼š\n\n    - PhantomDataï¼Œåœ¨Tä¸Šæ˜¯åå˜ã€‚ \n    - PhantomData<&'a T>ï¼Œåœ¨'a å’ŒTä¸Šæ˜¯åå˜ã€‚ \n    - PhantomData<&'a mut T>ï¼Œåœ¨'aä¸Šæ˜¯åå˜ï¼Œåœ¨Tä¸Šæ˜¯ä¸å˜ã€‚ \n    - PhantomData<*const T>ï¼Œåœ¨Tä¸Šæ˜¯åå˜ã€‚ \n    - PhantomData<*mut T>ï¼Œåœ¨Tä¸Šä¸å˜ã€‚ \n    - PhantomData<fn(T)>ï¼Œåœ¨Tä¸Šæ˜¯é€†å˜ï¼Œå¦‚æœä»¥åè¯­æ³•ä¿®æ”¹çš„è¯ï¼Œä¼šæˆä¸ºä¸å˜ã€‚ \n    - PhantomData<fn() -> T>ï¼Œåœ¨Tä¸Šæ˜¯åå˜ã€‚ \n    - PhantomData<fn(T) -> T>ï¼Œåœ¨Tä¸Šæ˜¯ä¸å˜ã€‚ \n    - PhantomData<Cell<&'a ()>>ï¼Œåœ¨'aä¸Šæ˜¯ä¸å˜ã€‚\n\n    ```rust\n    // åå˜ç±»å‹\n    struct MyCell<T> {\n        value: T,\n    }\n    impl<T: Copy> MyCell<T> {\n        fn new(x: T) -> MyCell<T> {\n            MyCell { value: x }\n        }\n        fn get(&self) -> T {\n            self.value\n    }\n    fn set(&self, value: T) {\n        use std::ptr;\n        unsafe {\n            ptr::write(&self.value as *const _ as *mut _, value);\n        }\n    }\n    }\n\n    fn step1<'a>(r_c1: &MyCell<&'a i32>) {\n        let val: i32 = 13;\n        step2(&val, r_c1); // step2å‡½æ•°æ‰§è¡Œå®Œå†å›åˆ°step1\n        println!(\"step1 value: {}\", r_c1.value);\n    } // step1è°ƒç”¨å®Œï¼Œæ ˆå¸§å°†è¢«æ¸…ç†ï¼Œvalå°†ä¸å¤å­˜åœ¨ï¼Œ&valå°†æˆä¸ºæ‚¬å‚æŒ‡é’ˆ\n\n    fn step2<'b>(r_val: &'b i32, r_c2: &MyCell<&'b i32>) {\n        r_c2.set(r_val);\n    }\n    static X: i32 = 10;\n    fn main() {\n    let cell = MyCell::new(&X);\n    step1(&cell);\n    println!(\"  end value: {}\", cell.value); //æ­¤å¤„ cell.valueçš„å€¼å°†æ— æ³•é¢„æœŸï¼ŒUBé£é™©\n    }\n\n    ```\n\n    Basic usage: ä¿®æ”¹MyCell ç±»å‹ä¸ºä¸å˜\n\n    è§£å†³ä¸Šé¢ç¤ºä¾‹UBçš„é—®é¢˜ï¼Œç¼–è¯‘å°†æŠ¥é”™ï¼Œå› ä¸ºå®‰å…¨æ£€æŸ¥ç”Ÿæ•ˆäº†ï¼ŒæˆåŠŸé˜»æ­¢äº†UBé£é™©\n\n    ```rust\n    use std::marker::PhantomData;\n    struct MyCell<T> {\n        value: T,\n        mark: PhantomData<fn(T)> , //é€šè¿‡PhantomData<fn(T)>å°†MyCell<T>æ”¹ä¸ºé€†å˜ç±»å‹\n    }\n    impl<T: Copy> MyCell<T> {\n        fn new(x: T) -> MyCell<T> {\n            MyCell { value: x , mark: PhantomData}\n        }\n    fn get(&self) -> T {\n        self.value\n    }\n    fn set(&self, value: T) {\n        use std::ptr;\n        unsafe {\n            ptr::write(&self.value as *const _ as *mut _, value);\n        }\n    }\n    }\n    fn step1<'a>(r_c1: &MyCell<&'a i32>) {\n        let val: i32 = 13;\n        step2(&val, r_c1); // error[E0597]: `val` does not live long enough\n        println!(\"step1 value: {}\", r_c1.value);\n    } // step1è°ƒç”¨å®Œï¼Œæ ˆå¸§å°†è¢«æ¸…ç†ï¼Œvalå°†ä¸å¤å­˜åœ¨ï¼Œ&valå°†æˆä¸ºæ‚¬å‚æŒ‡é’ˆ\n\n    fn step2<'b>(r_val: &'b i32, r_c2: &MyCell<&'b i32>) {\n        r_c2.set(r_val);\n    }\n    static X: i32 = 10;\n    fn main() {\n        let cell = MyCell::new(&X);\n        step1(&cell);\n        println!(\"  end value: {}\", cell.value);\n    }\n    ```\n    \n    ç¤ºä¾‹ï¼šé€†å˜\n\n    ```rust\n    #![allow(unused)]\n    trait A {\n        fn foo(&self, s: &'static str);\n    }\n    struct B;\n    impl A for B {\n        fn foo(&self, s: &str){\n            println!(\"{:?}\", s);\n        }\n    }\n    impl B{\n    fn foo2(&self, s: &'static str){\n        println!(\"{:?}\", s);\n    }\n    }\n    fn main() {\n        B.foo(\"hello\");\n        let s = \"hello\".to_string();\n        B.foo2(&s)\n    }\n\n    ```\n\n    ç¤ºä¾‹2:\n\n    ```rust\n    fn foo(input: &str)  {\n        println!(\"{:?}\", input);               \n    }\n    fn bar(f: fn(&'static str), v: &'static str) {\n        (f)(v);\n    }\n    fn main(){\n        let v : &'static str = \"hello\";\n        bar(foo, v);\n    }\n    ```\n\n*/","span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":145135,"byte_end":157323,"line_start":88,"line_end":583,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":79},"span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":157962,"byte_end":157969,"line_start":598,"line_end":598,"column_start":8,"column_end":15},"name":"nonnull","qualname":"::ch02::s9_unsafe_rust::nonnull","value":"pub fn nonnull()","parent":null,"children":[],"decl_id":null,"docs":"    # å…¶ä»–ä»‹ç»","sig":null,"attributes":[{"value":"*\n\n    # å…¶ä»–ä»‹ç»\n\n    - [NonNull](https://doc.rust-lang.org/nightly/std/ptr/struct.NonNull.html)\n    - [Play](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2015&gist=d95a1c5ec1a8c4279f366bb044ad6202)\n    - [LinkedList](https://doc.rust-lang.org/nightly/src/alloc/collections/linked_list.rs.html#39-44)\n    - [MaybeUninit](https://doc.rust-lang.org/std/mem/union.MaybeUninit.html)\n    - æ¨èé˜…è¯»ï¼š[Unsafe Rust: How and when (not) to use it](https://blog.logrocket.com/unsafe-rust-how-and-when-not-to-use-it/)\n    - [rustsec advisories](https://rustsec.org/advisories/)\n*/","span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":157355,"byte_end":157954,"line_start":587,"line_end":597,"column_start":1,"column_end":3}}]},{"kind":"Mod","id":{"krate":0,"index":80},"span":{"file_name":"src/ch03/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"ch03","qualname":"::ch03","value":"src/ch03/mod.rs","parent":null,"children":[{"krate":0,"index":81},{"krate":0,"index":87},{"krate":0,"index":90}],"decl_id":null,"docs":" ç¬¬ä¸‰ç« ï¼šRust å¼‚æ­¥ç¼–ç¨‹æ¦‚å¿µ","sig":null,"attributes":[{"value":"/ ç¬¬ä¸‰ç« ï¼šRust å¼‚æ­¥ç¼–ç¨‹æ¦‚å¿µ","span":{"file_name":"src/ch03/mod.rs","byte_start":157974,"byte_end":158013,"line_start":1,"line_end":1,"column_start":1,"column_end":20}},{"value":"/","span":{"file_name":"src/ch03/mod.rs","byte_start":158014,"byte_end":158017,"line_start":2,"line_end":2,"column_start":1,"column_end":4}},{"value":"/ æœ¬ç« è‡³ä¸‹è€Œä¸Šçš„æ–¹å¼æ¥å¸¦é¢†å¤§å®¶ç†è§£å¼‚æ­¥ç¼–ç¨‹:","span":{"file_name":"src/ch03/mod.rs","byte_start":158018,"byte_end":158083,"line_start":3,"line_end":3,"column_start":1,"column_end":26}},{"value":"/ ","span":{"file_name":"src/ch03/mod.rs","byte_start":158084,"byte_end":158088,"line_start":4,"line_end":4,"column_start":1,"column_end":5}},{"value":"/ 1. å¼‚æ­¥ I/O æ¨¡å‹","span":{"file_name":"src/ch03/mod.rs","byte_start":158089,"byte_end":158113,"line_start":5,"line_end":5,"column_start":1,"column_end":17}},{"value":"/ 2. å¼‚æ­¥ç¼–ç¨‹æ¨¡å‹ï¼š","span":{"file_name":"src/ch03/mod.rs","byte_start":158114,"byte_end":158142,"line_start":6,"line_end":6,"column_start":1,"column_end":15}},{"value":"/     - äº‹ä»¶é©±åŠ¨æ¨¡å‹","span":{"file_name":"src/ch03/mod.rs","byte_start":158143,"byte_end":158171,"line_start":7,"line_end":7,"column_start":1,"column_end":17}},{"value":"/     - Futures","span":{"file_name":"src/ch03/mod.rs","byte_start":158172,"byte_end":158189,"line_start":8,"line_end":8,"column_start":1,"column_end":18}},{"value":"/     - ç”Ÿæˆå™¨ ä¸ Pin","span":{"file_name":"src/ch03/mod.rs","byte_start":158190,"byte_end":158217,"line_start":9,"line_end":9,"column_start":1,"column_end":20}},{"value":"/     - async/await","span":{"file_name":"src/ch03/mod.rs","byte_start":158218,"byte_end":158239,"line_start":10,"line_end":10,"column_start":1,"column_end":22}},{"value":"/     - å¼‚æ­¥è¿è¡Œæ—¶ä»‹ç»ï¼šasync-stdã€tokioã€bastionã€smol","span":{"file_name":"src/ch03/mod.rs","byte_start":158240,"byte_end":158308,"line_start":11,"line_end":11,"column_start":1,"column_end":47}},{"value":"/ ","span":{"file_name":"src/ch03/mod.rs","byte_start":158309,"byte_end":158313,"line_start":12,"line_end":12,"column_start":1,"column_end":5}}]},{"kind":"Mod","id":{"krate":0,"index":81},"span":{"file_name":"src/ch03/s1_io_model.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"s1_io_model","qualname":"::ch03::s1_io_model","value":"src/ch03/s1_io_model.rs","parent":null,"children":[{"krate":0,"index":82},{"krate":0,"index":83},{"krate":0,"index":84},{"krate":0,"index":85},{"krate":0,"index":86}],"decl_id":null,"docs":" ç¬¬ä¸‰ç« ï¼šRust å¼‚æ­¥ç¼–ç¨‹æ¦‚å¿µ","sig":null,"attributes":[{"value":"/ ç¬¬ä¸‰ç« ï¼šRust å¼‚æ­¥ç¼–ç¨‹æ¦‚å¿µ","span":{"file_name":"src/ch03/s1_io_model.rs","byte_start":158429,"byte_end":158468,"line_start":1,"line_end":1,"column_start":1,"column_end":20}},{"value":"/","span":{"file_name":"src/ch03/s1_io_model.rs","byte_start":158469,"byte_end":158472,"line_start":2,"line_end":2,"column_start":1,"column_end":4}},{"value":"/ # 3.1 å¼‚æ­¥ I/O æ¨¡å‹","span":{"file_name":"src/ch03/s1_io_model.rs","byte_start":158473,"byte_end":158500,"line_start":3,"line_end":3,"column_start":1,"column_end":20}},{"value":"/ ","span":{"file_name":"src/ch03/s1_io_model.rs","byte_start":158501,"byte_end":158505,"line_start":4,"line_end":4,"column_start":1,"column_end":5}},{"value":"/ - åŸºæœ¬æ¦‚å¿µï¼š åŒæ­¥/å¼‚æ­¥ã€é˜»å¡/éé˜»å¡IOã€å¤šè·¯å¤ç”¨ã€epoll/io_uring","span":{"file_name":"src/ch03/s1_io_model.rs","byte_start":158506,"byte_end":158594,"line_start":5,"line_end":5,"column_start":1,"column_end":47}},{"value":"/ - Reactor/Preactoræ¨¡å‹ ä¸ äº‹ä»¶æŠ½è±¡","span":{"file_name":"src/ch03/s1_io_model.rs","byte_start":158595,"byte_end":158640,"line_start":6,"line_end":6,"column_start":1,"column_end":32}},{"value":"/ - minimio/mio","span":{"file_name":"src/ch03/s1_io_model.rs","byte_start":158641,"byte_end":158658,"line_start":7,"line_end":7,"column_start":1,"column_end":18}}]},{"kind":"Function","id":{"krate":0,"index":82},"span":{"file_name":"src/ch03/s1_io_model.rs","byte_start":161871,"byte_end":161884,"line_start":93,"line_end":93,"column_start":8,"column_end":21},"name":"basic_concept","qualname":"::ch03::s1_io_model::basic_concept","value":"pub fn basic_concept()","parent":null,"children":[],"decl_id":null,"docs":"    # å¼‚æ­¥ I/O æ¨¡å‹","sig":null,"attributes":[{"value":"*\n\n    # å¼‚æ­¥ I/O æ¨¡å‹\n\n    ## åŸºæœ¬æ¦‚å¿µ\n\n    - åŒæ­¥å’Œå¼‚æ­¥ï¼Œå…³æ³¨çš„æ˜¯æ¶ˆæ¯é€šä¿¡æœºåˆ¶ã€‚ï¼ˆè°ƒç”¨è€…è§†è§’ï¼‰\n        - åŒæ­¥ï¼Œå‘å‡ºä¸€ä¸ªè°ƒç”¨ï¼Œåœ¨æ²¡æœ‰å¾—åˆ°ç»“æœä¹‹å‰ä¸è¿”å›ã€‚\n        - å¼‚æ­¥ï¼Œå‘å‡ºä¸€ä¸ªè°ƒç”¨ï¼Œåœ¨æ²¡æœ‰å¾—åˆ°ç»“æœä¹‹å‰è¿”å›ã€‚\n    - é˜»å¡å’Œéé˜»å¡ï¼Œå…³æ³¨çš„æ˜¯ç¨‹åºç­‰å¾…è°ƒç”¨ç»“æœçš„çŠ¶æ€ã€‚ï¼ˆè¢«è°ƒç”¨è€…è§†è§’ï¼‰\n        - é˜»å¡ï¼Œåœ¨è°ƒç”¨ç»“æœè¿”å›ä¹‹å‰ï¼Œçº¿ç¨‹è¢«æŒ‚èµ·ã€‚\n        - éé˜»å¡ï¼Œåœ¨è°ƒç”¨ç»“æœè¿”å›ä¹‹å‰ï¼Œçº¿ç¨‹ä¸ä¼šè¢«æŒ‚èµ·ã€‚\n    \n    é˜»å¡ï¼Œä¸ç³»ç»Ÿè°ƒç”¨æœ‰å…³ã€‚\n\n\n    ### I/O æ¨¡å‹\n\n    ```text\n                                     +-+ é˜» å¡ I/O (BIO)\n                                     |\n                                     +-+ é é˜» å¡ I/O (NIO)\n                                     |\n                  +----+ åŒ æ­¥ I/O +--+\n                  |                  |\n                  |                  +-+ I/O å¤š è·¯ å¤ ç”¨\n                  |                  |\n                  |                  +-+ ä¿¡ å· é©± åŠ¨ I/O\n    I/O æ¨¡ å‹  +---+\n                  |\n                  |\n                  |                  +-+ Linux (AIO)\n                  |                  |         (io_uring)\n                  +----+ å¼‚ æ­¥ I/O +--+\n                                     |\n                                     +-+ windows (IOCP)\n\n    ```\n\n    ### åŒæ­¥é˜»å¡I/O (blocking I/O)\n\n    ```text\n    Application               kernel\n    +---------+            +-----------+  +---+\n    |         |   syscall  | no        |      |\n    |   Read  | +--------> | datagram  |      |\n    | recvfrom|            | ready     |      |\n    |         |            |    +      |      +-+ wait for\n    |         |            |    |      |      +-+ data\n    |         |            |    v      |      |\n    |         |            | datagram  |      |\n    |         |            | ready     |  +---+\n    |         |            |           |\n    |         |            | copy      |  +---+\n    |         |            | datagram  |      |\n    |process  |            |    +      |      +-+ copy data\n    |datagram |   return   |    |      |      +-+ from kernel to user\n    |         | <--------+ |    v      |      |\n    |         |            |  copy     |  +---+\n    |         |            |  complete |\n    +---------+            +-----------+\n    ```\n\n    è¾“å…¥æ“ä½œä¸¤ä¸ªé˜¶æ®µï¼š\n\n    1. è¿›ç¨‹ç­‰å¾…å†…æ ¸æŠŠæ•°æ®å‡†å¤‡å¥½ï¼›è¿™ä¸ªé˜¶æ®µå¯ä»¥é˜»å¡ä¹Ÿå¯éé˜»å¡ï¼Œè®¾ç½®socketå±æ€§ã€‚\n        - é˜»å¡ï¼š recvfrom é˜»å¡çº¿ç¨‹ç›´åˆ°è¿”å›æ•°æ®å°±ç»ªçš„ç»“æœã€‚\n        - éé˜»å¡ï¼šç«‹å³è¿”å›ä¸€ä¸ªé”™è¯¯ï¼Œè½®è¯¢ç›´åˆ°æ•°æ®å°±ç»ªã€‚\n    2. ä»å†…æ ¸ç¼“å†²åŒºå‘è¿›ç¨‹ç¼“å†²åŒºå¤åˆ¶æ•°æ®ã€‚ï¼ˆä¸€ç›´é˜»å¡ï¼‰\n\n    å¼‚æ­¥I/Oï¼Œrecvfromæ€»æ˜¯ç«‹å³è¿”å›ï¼Œä¸¤ä¸ªé˜¶æ®µéƒ½ç”±å†…æ ¸å®Œæˆã€‚\n\n    ### I/O å¤šè·¯å¤ç”¨ï¼ˆI/O Multiplexing )\n\n    IOå¤šè·¯å¤ç”¨æ˜¯ä¸€ç§åŒæ­¥IOæ¨¡å‹ï¼Œå®ç°ä¸€ä¸ªçº¿ç¨‹å¯ä»¥ç›‘è§†å¤šä¸ªæ–‡ä»¶å¥æŸ„ã€‚\n\n    æ”¯æŒI/Oå¤šè·¯å¤ç”¨çš„ç³»ç»Ÿè°ƒç”¨æœ‰ select/pselect/poll/epollï¼Œæœ¬è´¨éƒ½æ˜¯ åŒæ­¥ I/Oï¼Œå› ä¸ºæ•°æ®æ‹·è´éƒ½æ˜¯é˜»å¡çš„ã€‚\n    é€šè¿‡ select/epoll æ¥åˆ¤æ–­æ•°æ®æŠ¥æ˜¯å¦å‡†å¤‡å¥½ï¼Œå³åˆ¤æ–­å¯è¯»å¯å†™çŠ¶æ€ã€‚\n\n\n    \n\n */","span":{"file_name":"src/ch03/s1_io_model.rs","byte_start":158661,"byte_end":161863,"line_start":10,"line_end":92,"column_start":1,"column_end":4}}]},{"kind":"Function","id":{"krate":0,"index":83},"span":{"file_name":"src/ch03/s1_io_model.rs","byte_start":165075,"byte_end":165080,"line_start":142,"line_end":142,"column_start":8,"column_end":13},"name":"epoll","qualname":"::ch03::s1_io_model::epoll","value":"pub fn epoll()","parent":null,"children":[],"decl_id":null,"docs":"    ## epoll","sig":null,"attributes":[{"value":"*\n\n    ## epoll\n\n    ```text\n                            +--------------------------------+     +-------------------------+\n                            | epoll_ctl                      |     | epoll_wait              |\n                            |                                |     |                         |\n                            |                                |     |         +----+          |\n                            |                 +---+          |     |         |    |          |\n                            |                 |   |          |     |         |    |          |\n                            |               +-+---+--+       |     |         +--+-+          |\n                            |               |        |       |     |            |            |\n                            |            +--++     +-++      |     |            |            |\n    epoll_create  +---->    |            |   |     |  |      |     |         +--+-+          |\n                            |            +-+-+     +--+      +---->+         |    |          |\n                            |              |                 |event|         |    |          |\n                            |         +----+--+              |     |         +--+-+          |\n                            |         |       |              |     |            |            |\n                            |         ++      |              |     |            |            |\n                            |        +--+   +-+-+            |     |         +--+-+          |\n                            |        |  |   |   |            |     |         |    |          |\n                            |        +--+   +---+            |     |         |    |          |\n                            |                                |     |         +----+          |\n                            |                    çº¢ é»‘ æ ‘     |     |                 é“¾ è¡¨    |\n                            +--------------------------------+     +-------------------------+\n\n\n    ```\n\n    - epoll_create(int size) : å†…æ ¸äº§ç”Ÿä¸€ä¸ªepollå®ä¾‹æ•°æ®ç»“æ„ï¼Œå¹¶è¿”å›ä¸€ä¸ªepfd\n    - epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)ï¼šå°†è¢«ç›‘å¬çš„æè¿°ç¬¦æ·»åŠ åˆ°çº¢é»‘æ ‘æˆ–ä»çº¢é»‘æ ‘ä¸­åˆ é™¤æˆ–è€…å¯¹ç›‘å¬äº‹ä»¶è¿›è¡Œä¿®æ”¹ã€‚\n    - epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout): é˜»å¡ç­‰å¾…æ³¨å†Œçš„äº‹ä»¶å‘ç”Ÿï¼Œè¿”å›äº‹ä»¶çš„æ•°ç›®ï¼Œå¹¶å°†è§¦å‘çš„äº‹ä»¶å†™å…¥eventsæ•°ç»„ä¸­\n\n\n    epoll ä¸¤ç§è§¦å‘æœºåˆ¶ï¼š\n\n    - æ°´å¹³è§¦å‘æœºåˆ¶ï¼ˆLT)ã€‚ç¼“å†²åŒºåªè¦æœ‰æ•°æ®å°±è§¦å‘è¯»å†™ã€‚epoll é»˜è®¤å·¥ä½œæ–¹å¼ã€‚select/pollåªæ”¯æŒè¯¥æ–¹å¼ã€‚\n    - è¾¹ç¼˜è§¦å‘æœºåˆ¶ï¼ˆET)ã€‚ç¼“å†²åŒºç©ºæˆ–æ»¡çš„çŠ¶æ€æ‰è§¦å‘è¯»å†™ã€‚nginx ä½¿ç”¨è¯¥æ–¹å¼ï¼Œé¿å…é¢‘ç¹è¯»å†™ã€‚\n\n    æƒŠç¾¤é—®é¢˜ï¼š\n\n    å½“å¤šä¸ªè¿›ç¨‹/çº¿ç¨‹è°ƒç”¨epoll_waitæ—¶ä¼šé˜»å¡ç­‰å¾…ï¼Œå½“å†…æ ¸è§¦å‘å¯è¯»å†™äº‹ä»¶ï¼Œæ‰€æœ‰è¿›ç¨‹/çº¿ç¨‹éƒ½ä¼šè¿›è¡Œå“åº”ï¼Œä½†æ˜¯å®é™…ä¸Šåªæœ‰ä¸€ä¸ªè¿›ç¨‹/çº¿ç¨‹çœŸå®å¤„ç†è¿™äº›äº‹ä»¶ã€‚\n    Liux 4.5 é€šè¿‡å¼•å…¥ EPOLLEXCLUSIVE æ ‡è¯†æ¥ä¿è¯ä¸€ä¸ªäº‹ä»¶å‘ç”Ÿæ—¶å€™åªæœ‰ä¸€ä¸ªçº¿ç¨‹ä¼šè¢«å”¤é†’ï¼Œä»¥é¿å…å¤šä¾¦å¬ä¸‹çš„æƒŠç¾¤é—®é¢˜ã€‚\n*/","span":{"file_name":"src/ch03/s1_io_model.rs","byte_start":161892,"byte_end":165067,"line_start":97,"line_end":141,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":84},"span":{"file_name":"src/ch03/s1_io_model.rs","byte_start":167138,"byte_end":167146,"line_start":190,"line_end":190,"column_start":8,"column_end":16},"name":"io_uring","qualname":"::ch03::s1_io_model::io_uring","value":"pub fn io_uring()","parent":null,"children":[],"decl_id":null,"docs":"    ## io_uring å¼‚æ­¥ I/O æ¨¡å‹","sig":null,"attributes":[{"value":"*\n    ## io_uring å¼‚æ­¥ I/O æ¨¡å‹\n\n    Linux AIO å®ç°çš„å¹¶ä¸ç†æƒ³ï¼Œæ‰€ä»¥å¼•å…¥äº†æ–°çš„å¼‚æ­¥I/Oæ¥å£ io_uringã€‚\n\n    ```text\n    +----+ Head  +---------+               +----------+ Head\n    |            |         |               |          |\n    |            |         |               |          |\n    |            +---------+               +----------+\n    |            |         |               |          |\n    |            |         |               |          |\n    |            +---------+               +----------+\n    |            |         |               |          |\n    |            |         |               |          |\n    |            +---------+               +----------+\n    |            |         |               |          |\n    |      Tail  +---------+               +----------+ Tail <--+\n    |        +--------------------------------------------+     |\n    |        | Kernel                                     |     |\n    |        |                                            |     |\n    |        |        +-------+              +-------+    |     |\n    |        |        |       |              |       |    |     |\n    +---------------> | SQ    |              |  CQ   | +--------+\n             |        |       |              |       |    |\n             |        +-------+              +-------+    |\n             |                                            |\n             +--------------------------------------------+\n\n    ```\n\n    io_uringæ¥å£é€šè¿‡ä¸¤ä¸ªä¸»è¦æ•°æ®ç»“æ„å·¥ä½œï¼š\n    \n    - æäº¤é˜Ÿåˆ—æ¡ç›®ï¼ˆsqeï¼‰\n    - å®Œæˆé˜Ÿåˆ—æ¡ç›®ï¼ˆcqeï¼‰\n    \n    è¿™äº›ç»“æ„çš„å®ä¾‹ä½äºå†…æ ¸å’Œåº”ç”¨ç¨‹åºä¹‹é—´çš„**å…±äº«å†…å­˜**å•ç”Ÿäº§è€…å•æ¶ˆè´¹è€…ç¯å½¢ç¼“å†²åŒºä¸­ã€‚\n\n    å‚è€ƒï¼š\n    \n    [https://thenewstack.io/how-io_uring-and-ebpf-will-revolutionize-programming-in-linux/](https://thenewstack.io/how-io_uring-and-ebpf-will-revolutionize-programming-in-linux/)\n\n    [https://cor3ntin.github.io/posts/iouring/#io_uring](https://cor3ntin.github.io/posts/iouring/#io_uring)\n\n*/","span":{"file_name":"src/ch03/s1_io_model.rs","byte_start":165087,"byte_end":167130,"line_start":145,"line_end":189,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":85},"span":{"file_name":"src/ch03/s1_io_model.rs","byte_start":170129,"byte_end":170141,"line_start":247,"line_end":247,"column_start":8,"column_end":20},"name":"event_driven","qualname":"::ch03::s1_io_model::event_driven","value":"pub fn event_driven()","parent":null,"children":[],"decl_id":null,"docs":"    ## äº‹ä»¶é©±åŠ¨ç¼–ç¨‹æ¨¡å‹","sig":null,"attributes":[{"value":"*\n\n    ## äº‹ä»¶é©±åŠ¨ç¼–ç¨‹æ¨¡å‹\n\n    å› ä¸ºå¤„ç† I/O å¤ç”¨çš„ç¼–ç¨‹æ¨¡å‹ç›¸å½“å¤æ‚ï¼Œä¸ºäº†ç®€åŒ–ç¼–ç¨‹ï¼Œå¼•å…¥äº†ä¸‹é¢ä¸¤ç§æ¨¡å‹ã€‚\n\n    - Reactorï¼ˆååº”å™¨ï¼‰ æ¨¡å¼ï¼Œå¯¹åº”åŒæ­¥I/Oï¼Œè¢«åŠ¨çš„äº‹ä»¶åˆ†ç¦»å’Œåˆ†å‘æ¨¡å‹ã€‚æœåŠ¡ç­‰å¾…è¯·æ±‚äº‹ä»¶çš„åˆ°æ¥ï¼Œå†é€šè¿‡ä¸å—é—´æ–­çš„åŒæ­¥å¤„ç†äº‹ä»¶ï¼Œä»è€Œåšå‡ºååº”ã€‚\n    - Preactorï¼ˆä¸»åŠ¨å™¨ï¼‰ æ¨¡å¼ï¼Œå¯¹åº”å¼‚æ­¥I/Oï¼Œä¸»åŠ¨çš„äº‹ä»¶åˆ†ç¦»å’Œåˆ†å‘æ¨¡å‹ã€‚è¿™ç§è®¾è®¡å…è®¸å¤šä¸ªä»»åŠ¡å¹¶å‘çš„æ‰§è¡Œï¼Œä»è€Œæé«˜ååé‡ï¼›å¹¶å¯æ‰§è¡Œè€—æ—¶é•¿çš„ä»»åŠ¡ï¼ˆå„ä¸ªä»»åŠ¡é—´äº’ä¸å½±å“ï¼‰ã€‚\n\n    Reactor Model: \n\n    ```text\n                                                         +----------------+\n    req                                        Dispatch  |                |\n    +------+                                  +--------> | req handler    |\n    |      |                                  |          +----------------+\n    |      | +----+                           |\n    +------+      | event    +------------+   |\n                  |          |            |   |\n                  +--------> |  Service   |   |Dispatch  +----------------+\n                             |  Handler   +------------> |                |\n    req          +---------> |            |   |          | req handler    |\n    +------+     |           +------------+   |          +----------------+\n    |      |     | event                      |\n    |      +----+                             |\n    +------+                                  | Dispatch +----------------+\n                                              +--------->+                |\n                                                         | req handler    |\n                                                         +----------------+\n\n    ```\n\n    ä¸‰ç§å®ç°æ–¹å¼ï¼š\n\n    - å•çº¿ç¨‹æ¨¡å¼ã€‚ accept()ã€read()ã€write()ä»¥åŠconnect()æ“ä½œ éƒ½åœ¨åŒä¸€çº¿ç¨‹ã€‚\n    - å·¥ä½œè€…çº¿ç¨‹æ± æ¨¡å¼ã€‚é I/O æ“ä½œäº¤ç»™çº¿ç¨‹æ± å¤„ç†\n    - å¤šçº¿ç¨‹æ¨¡å¼ã€‚ä¸»Reactor (master) ï¼Œè´Ÿè´£ç½‘ç»œç›‘å¬ ï¼Œ å­Reactor(worker) è¯»å†™ç½‘ç»œæ•°æ®ã€‚\n\n    è¯»å†™æ“ä½œæµç¨‹ï¼š\n\n    1. åº”ç”¨æ³¨å†Œè¯»å†™å°±ç»ªäº‹ä»¶å’Œç›¸å…³è”çš„äº‹ä»¶å¤„ç†å™¨\n    2. äº‹ä»¶åˆ†ç¦»å™¨ç­‰å¾…äº‹ä»¶å‘ç”Ÿ\n    3. å½“å‘ç”Ÿè¯»å†™å°±ç»ªäº‹ä»¶ï¼Œäº‹ä»¶åˆ†ç¦»å™¨è°ƒç”¨å·²æ³¨å†Œçš„äº‹ä»¶å¤„ç†å™¨\n    4. äº‹ä»¶å¤„ç†å™¨æ‰§è¡Œè¯»å†™æ“ä½œ\n\n    å‚ä¸è€…ï¼š\n    1. æè¿°ç¬¦ï¼ˆhandleï¼‰ï¼šæ“ä½œç³»ç»Ÿæä¾›çš„èµ„æºï¼Œè¯†åˆ« socketç­‰ã€‚\n    2. åŒæ­¥äº‹ä»¶å¤šè·¯åˆ†ç¦»å™¨ã€‚å¼€å¯äº‹ä»¶å¾ªç¯ï¼Œç­‰å¾…äº‹ä»¶çš„å‘ç”Ÿã€‚å°è£…äº† å¤šè·¯å¤ç”¨å‡½æ•° select/poll/epollç­‰ã€‚\n    3. äº‹ä»¶å¤„ç†å™¨ã€‚æä¾›å›è°ƒå‡½æ•°ï¼Œç”¨äºæè¿°ä¸åº”ç”¨ç¨‹åºç›¸å…³çš„æŸä¸ªäº‹ä»¶çš„æ“ä½œã€‚\n    4. å…·ä½“çš„äº‹ä»¶å¤„ç†å™¨ã€‚äº‹ä»¶å¤„ç†å™¨æ¥å£çš„å…·ä½“å®ç°ã€‚ä½¿ç”¨æè¿°ç¬¦æ¥è¯†åˆ«äº‹ä»¶å’Œç¨‹åºæä¾›çš„æœåŠ¡ã€‚\n    5. Reactor ç®¡ç†å™¨ã€‚äº‹ä»¶å¤„ç†å™¨çš„è°ƒåº¦æ ¸å¿ƒã€‚åˆ†ç¦»æ¯ä¸ªäº‹ä»¶ï¼Œè°ƒåº¦äº‹ä»¶ç®¡ç†å™¨ï¼Œè°ƒç”¨å…·ä½“çš„å‡½æ•°å¤„ç†æŸä¸ªäº‹ä»¶ã€‚\n\n*/","span":{"file_name":"src/ch03/s1_io_model.rs","byte_start":167154,"byte_end":170121,"line_start":194,"line_end":246,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":86},"span":{"file_name":"src/ch03/s1_io_model.rs","byte_start":170597,"byte_end":170609,"line_start":263,"line_end":263,"column_start":8,"column_end":20},"name":"epoll_server","qualname":"::ch03::s1_io_model::epoll_server","value":"pub fn epoll_server()","parent":null,"children":[],"decl_id":null,"docs":"    ## Rust å®ç° epoll server ç¤ºä¾‹è®²è§£","sig":null,"attributes":[{"value":"*\n\n    ## Rust å®ç° epoll server ç¤ºä¾‹è®²è§£\n\n    1. [https://github.com/zupzup/rust-epoll-example/blob/main/src/main.rs](https://github.com/zupzup/rust-epoll-example/blob/main/src/main.rs)\n    2. [Reactor executor Example](https://github.com/zupzup/rust-reactor-executor-example)\n\n    ## å®ç°è·¨å¹³å° \n\n    1. [minimio](https://github.com/cfsamson/examples-minimio)\n    2. [mio](https://github.com/tokio-rs/mio) and mio-examples\n\n*/","span":{"file_name":"src/ch03/s1_io_model.rs","byte_start":170148,"byte_end":170589,"line_start":250,"line_end":262,"column_start":1,"column_end":3}}]},{"kind":"Mod","id":{"krate":0,"index":87},"span":{"file_name":"src/ch03/s2_async_await.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"s2_async_await","qualname":"::ch03::s2_async_await","value":"src/ch03/s2_async_await.rs","parent":null,"children":[{"krate":0,"index":88},{"krate":0,"index":89}],"decl_id":null,"docs":" ç¬¬ä¸‰ç« ï¼šRust å¼‚æ­¥ç¼–ç¨‹æ¦‚å¿µ","sig":null,"attributes":[{"value":"/ ç¬¬ä¸‰ç« ï¼šRust å¼‚æ­¥ç¼–ç¨‹æ¦‚å¿µ","span":{"file_name":"src/ch03/s2_async_await.rs","byte_start":170614,"byte_end":170653,"line_start":1,"line_end":1,"column_start":1,"column_end":20}},{"value":"/","span":{"file_name":"src/ch03/s2_async_await.rs","byte_start":170654,"byte_end":170657,"line_start":2,"line_end":2,"column_start":1,"column_end":4}},{"value":"/ # 3.2 å¼‚æ­¥ ç¼–ç¨‹ æ¨¡å‹","span":{"file_name":"src/ch03/s2_async_await.rs","byte_start":170658,"byte_end":170688,"line_start":3,"line_end":3,"column_start":1,"column_end":19}},{"value":"/ ","span":{"file_name":"src/ch03/s2_async_await.rs","byte_start":170689,"byte_end":170693,"line_start":4,"line_end":4,"column_start":1,"column_end":5}},{"value":"/ - Future ","span":{"file_name":"src/ch03/s2_async_await.rs","byte_start":170694,"byte_end":170707,"line_start":5,"line_end":5,"column_start":1,"column_end":14}},{"value":"/ - ç”Ÿæˆå™¨ ä¸ åç¨‹","span":{"file_name":"src/ch03/s2_async_await.rs","byte_start":170708,"byte_end":170734,"line_start":6,"line_end":6,"column_start":1,"column_end":15}},{"value":"/ - Pin ä¸ UnPin","span":{"file_name":"src/ch03/s2_async_await.rs","byte_start":170735,"byte_end":170754,"line_start":7,"line_end":7,"column_start":1,"column_end":18}},{"value":"/ - Async/Await","span":{"file_name":"src/ch03/s2_async_await.rs","byte_start":170755,"byte_end":170772,"line_start":8,"line_end":8,"column_start":1,"column_end":18}},{"value":"/ ","span":{"file_name":"src/ch03/s2_async_await.rs","byte_start":170773,"byte_end":170777,"line_start":9,"line_end":9,"column_start":1,"column_end":5}},{"value":"/ ","span":{"file_name":"src/ch03/s2_async_await.rs","byte_start":170778,"byte_end":170782,"line_start":10,"line_end":10,"column_start":1,"column_end":5}}]},{"kind":"Function","id":{"krate":0,"index":88},"span":{"file_name":"src/ch03/s2_async_await.rs","byte_start":171909,"byte_end":171916,"line_start":49,"line_end":49,"column_start":8,"column_end":15},"name":"futures","qualname":"::ch03::s2_async_await::futures","value":"pub fn futures()","parent":null,"children":[],"decl_id":null,"docs":"    # Future å’Œ Futures-rs\n    \n    - [Future](https://doc.rust-lang.org/std/future/index.html) and [task](https://doc.rust-lang.org/std/task/index.html)\n    - [futures-rs](https://github.com/rust-lang/futures-rs)","sig":null,"attributes":[{"value":"*\n\n    # Future å’Œ Futures-rs\n    \n    - [Future](https://doc.rust-lang.org/std/future/index.html) and [task](https://doc.rust-lang.org/std/task/index.html)\n    - [futures-rs](https://github.com/rust-lang/futures-rs)\n\n    ç¤ºä¾‹ï¼š\n\n    ```rust\n    pub struct SocketRead<'a> {\n        socket: &'a Socket,\n    }\n\n    impl SimpleFuture for SocketRead<'_> {\n        type Output = Vec<u8>;\n\n        fn poll(&mut self, wake: fn()) -> Poll<Self::Output> {\n            if self.socket.has_data_to_read() {\n                // The socket has data-- read it into a buffer and return it.\n                Poll::Ready(self.socket.read_buf())\n            } else {\n                // The socket does not yet have data.\n                //\n                // Arrange for `wake` to be called once data is available.\n                // When data becomes available, `wake` will be called, and the\n                // user of this `Future` will know to call `poll` again and\n                // receive data.\n                self.socket.set_readable_callback(wake);\n                Poll::Pending\n            }\n        }\n    }\n    ```\n\n*/","span":{"file_name":"src/ch03/s2_async_await.rs","byte_start":170784,"byte_end":171900,"line_start":12,"line_end":47,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":89},"span":{"file_name":"src/ch03/s2_async_await.rs","byte_start":172180,"byte_end":172189,"line_start":72,"line_end":72,"column_start":8,"column_end":17},"name":"generator","qualname":"::ch03::s2_async_await::generator","value":"pub fn generator()","parent":null,"children":[],"decl_id":null,"docs":"    # ç”Ÿæˆå™¨ ä¸ åç¨‹","sig":null,"attributes":[{"value":"*\n\n    # ç”Ÿæˆå™¨ ä¸ åç¨‹\n\n    ## å†å²\n\n    å¤„ç†å¼‚æ­¥äº‹ä»¶çš„ä¸‰ç§æ–¹å¼ï¼š\n    - Callback\n    - Promise\n    - async/await \n\n    async/await æ˜¯ç›®å‰ä½“éªŒæœ€å¥½çš„æ–¹å¼ï¼ŒRust è¦æ”¯æŒå®ƒå¹¶ä¸å®¹æ˜“ã€‚\n\n    ## ç”Ÿæˆå™¨\n\n    \n\n*/","span":{"file_name":"src/ch03/s2_async_await.rs","byte_start":171925,"byte_end":172172,"line_start":54,"line_end":71,"column_start":1,"column_end":3}}]},{"kind":"Mod","id":{"krate":0,"index":90},"span":{"file_name":"src/ch03/s3_async_runtime.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"s3_async_runtime","qualname":"::ch03::s3_async_runtime","value":"src/ch03/s3_async_runtime.rs","parent":null,"children":[],"decl_id":null,"docs":" ç¬¬ä¸‰ç« ï¼šRust å¼‚æ­¥ç¼–ç¨‹æ¦‚å¿µ","sig":null,"attributes":[{"value":"/ ç¬¬ä¸‰ç« ï¼šRust å¼‚æ­¥ç¼–ç¨‹æ¦‚å¿µ","span":{"file_name":"src/ch03/s3_async_runtime.rs","byte_start":172194,"byte_end":172233,"line_start":1,"line_end":1,"column_start":1,"column_end":20}},{"value":"/","span":{"file_name":"src/ch03/s3_async_runtime.rs","byte_start":172234,"byte_end":172237,"line_start":2,"line_end":2,"column_start":1,"column_end":4}},{"value":"/ # 3.3 å¼‚æ­¥ è¿è¡Œæ—¶","span":{"file_name":"src/ch03/s3_async_runtime.rs","byte_start":172238,"byte_end":172264,"line_start":3,"line_end":3,"column_start":1,"column_end":17}},{"value":"/ ","span":{"file_name":"src/ch03/s3_async_runtime.rs","byte_start":172265,"byte_end":172269,"line_start":4,"line_end":4,"column_start":1,"column_end":5}},{"value":"/ - [tokio](https://github.com/tokio-rs/tokio)","span":{"file_name":"src/ch03/s3_async_runtime.rs","byte_start":172270,"byte_end":172318,"line_start":5,"line_end":5,"column_start":1,"column_end":49}},{"value":"/ - [async-std](https://github.com/async-rs/async-std)","span":{"file_name":"src/ch03/s3_async_runtime.rs","byte_start":172319,"byte_end":172375,"line_start":6,"line_end":6,"column_start":1,"column_end":57}},{"value":"/ - [smol](https://github.com/smol-rs/smol)","span":{"file_name":"src/ch03/s3_async_runtime.rs","byte_start":172376,"byte_end":172421,"line_start":7,"line_end":7,"column_start":1,"column_end":46}},{"value":"/ - [bastion](https://github.com/bastion-rs/bastion)","span":{"file_name":"src/ch03/s3_async_runtime.rs","byte_start":172422,"byte_end":172476,"line_start":8,"line_end":8,"column_start":1,"column_end":55}},{"value":"/ - [glommio](https://github.com/DataDog/glommio)","span":{"file_name":"src/ch03/s3_async_runtime.rs","byte_start":172477,"byte_end":172528,"line_start":9,"line_end":9,"column_start":1,"column_end":52}},{"value":"/ ","span":{"file_name":"src/ch03/s3_async_runtime.rs","byte_start":172529,"byte_end":172533,"line_start":10,"line_end":10,"column_start":1,"column_end":5}},{"value":"/ æ¡†æ¶å‰–æï¼š","span":{"file_name":"src/ch03/s3_async_runtime.rs","byte_start":172534,"byte_end":172553,"line_start":11,"line_end":11,"column_start":1,"column_end":10}},{"value":"/ ","span":{"file_name":"src/ch03/s3_async_runtime.rs","byte_start":172554,"byte_end":172558,"line_start":12,"line_end":12,"column_start":1,"column_end":5}},{"value":"/ - [rocket](https://github.com/SergioBenitez/Rocket)","span":{"file_name":"src/ch03/s3_async_runtime.rs","byte_start":172559,"byte_end":172614,"line_start":13,"line_end":13,"column_start":1,"column_end":56}},{"value":"/ - [acitx-web](https://github.com/actix/actix-web)","span":{"file_name":"src/ch03/s3_async_runtime.rs","byte_start":172615,"byte_end":172668,"line_start":14,"line_end":14,"column_start":1,"column_end":54}},{"value":"/ - [tide](https://github.com/http-rs/tide)","span":{"file_name":"src/ch03/s3_async_runtime.rs","byte_start":172669,"byte_end":172714,"line_start":15,"line_end":15,"column_start":1,"column_end":46}},{"value":"/ - [lunatic](https://github.com/lunatic-solutions/lunatic)","span":{"file_name":"src/ch03/s3_async_runtime.rs","byte_start":172715,"byte_end":172776,"line_start":16,"line_end":16,"column_start":1,"column_end":62}}]}],"impls":[],"refs":[{"kind":"Mod","span":{"file_name":"src/lib.rs","byte_start":202,"byte_end":206,"line_start":8,"line_end":8,"column_start":9,"column_end":13},"ref_id":{"krate":0,"index":3}},{"kind":"Mod","span":{"file_name":"src/ch01/mod.rs","byte_start":284,"byte_end":291,"line_start":6,"line_end":6,"column_start":9,"column_end":16},"ref_id":{"krate":0,"index":4}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6935}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6935}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6935}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6935}},{"kind":"Function","span":{"file_name":"src/ch01/lexical.rs","byte_start":3186,"byte_end":3193,"line_start":131,"line_end":131,"column_start":13,"column_end":20},"ref_id":{"krate":2,"index":5683}},{"kind":"Type","span":{"file_name":"src/ch01/lexical.rs","byte_start":3196,"byte_end":3199,"line_start":131,"line_end":131,"column_start":23,"column_end":26},"ref_id":{"krate":5,"index":5370}},{"kind":"Type","span":{"file_name":"src/ch01/lexical.rs","byte_start":3179,"byte_end":3184,"line_start":131,"line_end":131,"column_start":6,"column_end":11},"ref_id":{"krate":2,"index":29003}},{"kind":"Variable","span":{"file_name":"src/ch01/lexical.rs","byte_start":3179,"byte_end":3180,"line_start":131,"line_end":131,"column_start":6,"column_end":7},"ref_id":{"krate":2,"index":29005}},{"kind":"Variable","span":{"file_name":"src/ch01/lexical.rs","byte_start":3182,"byte_end":3184,"line_start":131,"line_end":131,"column_start":9,"column_end":11},"ref_id":{"krate":2,"index":29006}},{"kind":"Function","span":{"file_name":"src/ch01/lexical.rs","byte_start":3222,"byte_end":3235,"line_start":132,"line_end":132,"column_start":16,"column_end":29},"ref_id":{"krate":5,"index":5378}},{"kind":"Type","span":{"file_name":"src/ch01/lexical.rs","byte_start":3211,"byte_end":3214,"line_start":132,"line_end":132,"column_start":5,"column_end":8},"ref_id":{"krate":5,"index":5370}},{"kind":"Mod","span":{"file_name":"src/ch01/mod.rs","byte_start":301,"byte_end":305,"line_start":7,"line_end":7,"column_start":9,"column_end":13},"ref_id":{"krate":0,"index":15}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Mod","span":{"file_name":"src/ch01/mod.rs","byte_start":315,"byte_end":319,"line_start":8,"line_end":8,"column_start":9,"column_end":13},"ref_id":{"krate":0,"index":20}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6935}},{"kind":"Mod","span":{"file_name":"src/lib.rs","byte_start":216,"byte_end":220,"line_start":9,"line_end":9,"column_start":9,"column_end":13},"ref_id":{"krate":0,"index":33}},{"kind":"Mod","span":{"file_name":"src/ch02/mod.rs","byte_start":14850,"byte_end":14862,"line_start":10,"line_end":10,"column_start":9,"column_end":21},"ref_id":{"krate":0,"index":34}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Mod","span":{"file_name":"src/ch02/mod.rs","byte_start":14886,"byte_end":14897,"line_start":12,"line_end":12,"column_start":9,"column_end":20},"ref_id":{"krate":0,"index":42}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Mod","span":{"file_name":"src/ch02/mod.rs","byte_start":14921,"byte_end":14935,"line_start":14,"line_end":14,"column_start":9,"column_end":23},"ref_id":{"krate":0,"index":50}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Mod","span":{"file_name":"src/ch02/mod.rs","byte_start":14959,"byte_end":14970,"line_start":16,"line_end":16,"column_start":9,"column_end":20},"ref_id":{"krate":0,"index":55}},{"kind":"Mod","span":{"file_name":"src/ch02/mod.rs","byte_start":14994,"byte_end":15014,"line_start":18,"line_end":18,"column_start":9,"column_end":29},"ref_id":{"krate":0,"index":57}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Mod","span":{"file_name":"src/ch02/mod.rs","byte_start":15038,"byte_end":15050,"line_start":20,"line_end":20,"column_start":9,"column_end":21},"ref_id":{"krate":0,"index":65}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Mod","span":{"file_name":"src/ch02/mod.rs","byte_start":15074,"byte_end":15089,"line_start":22,"line_end":22,"column_start":9,"column_end":24},"ref_id":{"krate":0,"index":67}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Mod","span":{"file_name":"src/ch02/mod.rs","byte_start":15113,"byte_end":15131,"line_start":24,"line_end":24,"column_start":9,"column_end":27},"ref_id":{"krate":0,"index":71}},{"kind":"Mod","span":{"file_name":"src/ch02/mod.rs","byte_start":15155,"byte_end":15169,"line_start":26,"line_end":26,"column_start":9,"column_end":23},"ref_id":{"krate":0,"index":76}},{"kind":"Mod","span":{"file_name":"src/lib.rs","byte_start":230,"byte_end":234,"line_start":10,"line_end":10,"column_start":9,"column_end":13},"ref_id":{"krate":0,"index":80}},{"kind":"Mod","span":{"file_name":"src/ch03/mod.rs","byte_start":158337,"byte_end":158348,"line_start":15,"line_end":15,"column_start":9,"column_end":20},"ref_id":{"krate":0,"index":81}},{"kind":"Mod","span":{"file_name":"src/ch03/mod.rs","byte_start":158372,"byte_end":158386,"line_start":17,"line_end":17,"column_start":9,"column_end":23},"ref_id":{"krate":0,"index":87}},{"kind":"Mod","span":{"file_name":"src/ch03/mod.rs","byte_start":158410,"byte_end":158426,"line_start":19,"line_end":19,"column_start":9,"column_end":25},"ref_id":{"krate":0,"index":90}}],"macro_refs":[],"relations":[]}