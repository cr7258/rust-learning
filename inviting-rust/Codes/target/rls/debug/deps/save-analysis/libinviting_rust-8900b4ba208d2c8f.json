{"config":{"output_file":null,"full_docs":false,"pub_only":false,"reachable_only":false,"distro_crate":false,"signatures":false,"borrow_data":false},"version":"0.19.1","compilation":{"directory":"/Users/zhangalex/Work/Consultation/GeekTime/inviting-rust","program":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/bin/rls","arguments":[],"output":"/Users/zhangalex/Work/Consultation/GeekTime/inviting-rust/target/rls/debug/deps/libinviting_rust-8900b4ba208d2c8f.rmeta"},"prelude":{"crate_id":{"name":"inviting_rust","disambiguator":[12361996849156886837,15747726852956746209]},"crate_root":"src","external_crates":[{"file_name":"/Users/zhangalex/Work/Consultation/GeekTime/inviting-rust/src/lib.rs","num":1,"id":{"name":"std","disambiguator":[15271846124424689693,12828167138405415005]}},{"file_name":"/Users/zhangalex/Work/Consultation/GeekTime/inviting-rust/src/lib.rs","num":2,"id":{"name":"core","disambiguator":[3522436643036113830,3458472283245946581]}},{"file_name":"/Users/zhangalex/Work/Consultation/GeekTime/inviting-rust/src/lib.rs","num":3,"id":{"name":"compiler_builtins","disambiguator":[18443775081675161881,8871531110487799323]}},{"file_name":"/Users/zhangalex/Work/Consultation/GeekTime/inviting-rust/src/lib.rs","num":4,"id":{"name":"rustc_std_workspace_core","disambiguator":[14133466982911310258,776543773745642680]}},{"file_name":"/Users/zhangalex/Work/Consultation/GeekTime/inviting-rust/src/lib.rs","num":5,"id":{"name":"alloc","disambiguator":[1810916959507492673,6992362399719939798]}},{"file_name":"/Users/zhangalex/Work/Consultation/GeekTime/inviting-rust/src/lib.rs","num":6,"id":{"name":"libc","disambiguator":[14542582121781483850,6595427450071768280]}},{"file_name":"/Users/zhangalex/Work/Consultation/GeekTime/inviting-rust/src/lib.rs","num":7,"id":{"name":"unwind","disambiguator":[13128264859918991565,1389008832397617215]}},{"file_name":"/Users/zhangalex/Work/Consultation/GeekTime/inviting-rust/src/lib.rs","num":8,"id":{"name":"cfg_if","disambiguator":[13519202797247513544,2344338743936253762]}},{"file_name":"/Users/zhangalex/Work/Consultation/GeekTime/inviting-rust/src/lib.rs","num":9,"id":{"name":"hashbrown","disambiguator":[15198817458514557480,12619727005655851827]}},{"file_name":"/Users/zhangalex/Work/Consultation/GeekTime/inviting-rust/src/lib.rs","num":10,"id":{"name":"rustc_std_workspace_alloc","disambiguator":[7792981388631258554,13574744570605464789]}},{"file_name":"/Users/zhangalex/Work/Consultation/GeekTime/inviting-rust/src/lib.rs","num":11,"id":{"name":"rustc_demangle","disambiguator":[18366362480168335528,6204773997848079802]}},{"file_name":"/Users/zhangalex/Work/Consultation/GeekTime/inviting-rust/src/lib.rs","num":12,"id":{"name":"addr2line","disambiguator":[10062380695705566486,8667061503757010039]}},{"file_name":"/Users/zhangalex/Work/Consultation/GeekTime/inviting-rust/src/lib.rs","num":13,"id":{"name":"gimli","disambiguator":[7067261615280639564,60947903771806555]}},{"file_name":"/Users/zhangalex/Work/Consultation/GeekTime/inviting-rust/src/lib.rs","num":14,"id":{"name":"object","disambiguator":[15231746228855223727,7991947149439765402]}},{"file_name":"/Users/zhangalex/Work/Consultation/GeekTime/inviting-rust/src/lib.rs","num":15,"id":{"name":"panic_unwind","disambiguator":[6287783694532592178,16708986191446005949]}}],"span":{"file_name":"src/lib.rs","byte_start":1,"byte_end":235,"line_start":2,"line_end":10,"column_start":1,"column_end":14}},"imports":[],"defs":[{"kind":"Mod","id":{"krate":0,"index":0},"span":{"file_name":"src/lib.rs","byte_start":1,"byte_end":235,"line_start":2,"line_end":10,"column_start":1,"column_end":14},"name":"","qualname":"::","value":"src/lib.rs","parent":null,"children":[{"krate":0,"index":1},{"krate":0,"index":2},{"krate":0,"index":3},{"krate":0,"index":33},{"krate":0,"index":80}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":3},"span":{"file_name":"src/ch01/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"ch01","qualname":"::ch01","value":"src/ch01/mod.rs","parent":null,"children":[{"krate":0,"index":4},{"krate":0,"index":15},{"krate":0,"index":20},{"krate":0,"index":32}],"decl_id":null,"docs":" 第一章：Rust语言基础","sig":null,"attributes":[{"value":"/ 第一章：Rust语言基础","span":{"file_name":"src/ch01/mod.rs","byte_start":237,"byte_end":269,"line_start":2,"line_end":2,"column_start":1,"column_end":17}},{"value":"/","span":{"file_name":"src/ch01/mod.rs","byte_start":270,"byte_end":273,"line_start":3,"line_end":3,"column_start":1,"column_end":4}}]},{"kind":"Mod","id":{"krate":0,"index":4},"span":{"file_name":"src/ch01/lexical.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"lexical","qualname":"::ch01::lexical","value":"src/ch01/lexical.rs","parent":null,"children":[{"krate":0,"index":5},{"krate":0,"index":6},{"krate":0,"index":8},{"krate":0,"index":9}],"decl_id":null,"docs":" 第一章：Rust语言基础\n 1.3 语法面面观（一） 词法结构\n \n 包括：\n    1. Rust 语言版本说明\n    2. Rust 词法结构\n","sig":null,"attributes":[{"value":"allow(unused_variables)","span":{"file_name":"src/ch01/lexical.rs","byte_start":505,"byte_end":532,"line_start":1,"line_end":1,"column_start":1,"column_end":28}},{"value":"/ 第一章：Rust语言基础","span":{"file_name":"src/ch01/lexical.rs","byte_start":533,"byte_end":565,"line_start":2,"line_end":2,"column_start":1,"column_end":17}},{"value":"/ 1.3 语法面面观（一） 词法结构","span":{"file_name":"src/ch01/lexical.rs","byte_start":566,"byte_end":611,"line_start":3,"line_end":3,"column_start":1,"column_end":22}},{"value":"/ ","span":{"file_name":"src/ch01/lexical.rs","byte_start":612,"byte_end":616,"line_start":4,"line_end":4,"column_start":1,"column_end":5}},{"value":"/ 包括：","span":{"file_name":"src/ch01/lexical.rs","byte_start":617,"byte_end":630,"line_start":5,"line_end":5,"column_start":1,"column_end":8}},{"value":"/    1. Rust 语言版本说明","span":{"file_name":"src/ch01/lexical.rs","byte_start":631,"byte_end":664,"line_start":6,"line_end":6,"column_start":1,"column_end":22}},{"value":"/    2. Rust 词法结构","span":{"file_name":"src/ch01/lexical.rs","byte_start":665,"byte_end":692,"line_start":7,"line_end":7,"column_start":1,"column_end":20}}]},{"kind":"Function","id":{"krate":0,"index":5},"span":{"file_name":"src/ch01/lexical.rs","byte_start":1152,"byte_end":1162,"line_start":30,"line_end":30,"column_start":8,"column_end":18},"name":"ident_show","qualname":"::ch01::lexical::ident_show","value":"pub fn ident_show()","parent":null,"children":[],"decl_id":null,"docs":"    # 标识符:","sig":null,"attributes":[{"value":"*\n\n    # 标识符:\n\n   ```rust\n   let thinking = \"thinking\";\n   let thinking123_ = \"thinking 123\";\n   \n   // error: invalid suffix `thinking` for integer literal\n   // let 321_thinking = \"thinking\";\n   \n   // ok\n   let _321_thinking = \"thinking\";\n\n   // non-ascii ident\n   // RFC: https://github.com/rust-lang/rfcs/blob/master/text/2457-non-ascii-idents.md\n   // error: unknown start of token: \\u{1f914} \n   //  let 🤔 = \"thinking \"; \n   ```\n\n*/","span":{"file_name":"src/ch01/lexical.rs","byte_start":694,"byte_end":1144,"line_start":9,"line_end":29,"column_start":1,"column_end":3}}]},{"kind":"Local","id":{"krate":0,"index":3221225477},"span":{"file_name":"src/ch01/lexical.rs","byte_start":1174,"byte_end":1182,"line_start":31,"line_end":31,"column_start":9,"column_end":17},"name":"thinking","qualname":"thinking$HirId { owner: DefId(0:5 ~ inviting_rust[ab8e]::ch01::lexical::ident_show), local_id: 3 }","value":"&str","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6},"span":{"file_name":"src/ch01/lexical.rs","byte_start":1871,"byte_end":1881,"line_start":64,"line_end":64,"column_start":8,"column_end":18},"name":"macro_show","qualname":"::ch01::lexical::macro_show","value":"pub fn macro_show()","parent":null,"children":[],"decl_id":null,"docs":"    # 声明宏示例","sig":null,"attributes":[{"value":"*\n\n    # 声明宏示例\n\n    ```rust\n    macro_rules! calculate {\n        (eval $e:expr) => {{\n            {\n                let val: usize = $e; // Force types to be integers\n                println!(\"{} = {}\", stringify!{$e}, val);\n            }\n        }};\n    }\n\n    fn main() {\n        calculate! {\n            eval 1 + 2 // hehehe `eval` is _not_ a Rust keyword!\n        }\n\n        calculate! {\n            eval (1 + 2) * (3 / 4)\n        }\n    }\n    ```\n*/","span":{"file_name":"src/ch01/lexical.rs","byte_start":1398,"byte_end":1863,"line_start":39,"line_end":63,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":8},"span":{"file_name":"src/ch01/lexical.rs","byte_start":3160,"byte_end":3169,"line_start":130,"line_end":130,"column_start":8,"column_end":17},"name":"path_show","qualname":"::ch01::lexical::path_show","value":"pub fn path_show()","parent":null,"children":[],"decl_id":null,"docs":"    # Path 展示","sig":null,"attributes":[{"value":"*\n\n    # Path 展示\n\n    ```\n    // 模块路径\n    mod a {\n        fn foo() {}\n\n        mod b {\n            mod c {\n                fn foo() {\n                    super::super::foo(); // call a's foo function\n                    self::super::super::foo(); // call a's foo function\n                }\n            }\n        }\n    }\n    \n    // 方法调用\n    \n    struct S;\n    impl S {\n        fn f() { println!(\"S\"); }\n    }\n    trait T1 {\n        fn f() { println!(\"T1 f\"); }\n    }\n    impl T1 for S {}\n    trait T2 {\n        fn f() { println!(\"T2 f\"); }\n    }\n    impl T2 for S {}\n    S::f();  // Calls the inherent impl.\n    // 完全限定无歧义调用\n    <S as T1>::f();  // Calls the T1 trait function.\n    <S as T2>::f();  // Calls the T2 trait function.\n\n\n    // 泛型函数-turbofish操作符\n    (0..10).collect::<Vec<_>>();\n    Vec::<u8>::with_capacity(1024);\n    ```\n\n*/","span":{"file_name":"src/ch01/lexical.rs","byte_start":2260,"byte_end":3152,"line_start":85,"line_end":129,"column_start":1,"column_end":3}}]},{"kind":"Mod","id":{"krate":0,"index":9},"span":{"file_name":"src/ch01/lexical.rs","byte_start":4996,"byte_end":5008,"line_start":200,"line_end":200,"column_start":9,"column_end":21},"name":"outer_module","qualname":"::ch01::lexical::outer_module","value":"src/ch01/lexical.rs","parent":null,"children":[{"krate":0,"index":10},{"krate":0,"index":11},{"krate":0,"index":13}],"decl_id":null,"docs":"    # 注释示例\n    pub mod outer_module {\n \n        //!  - 模块级文档注释，置于模块头部\n        //!! - 模块级文档注释，但是和上面注释置于同一行","sig":null,"attributes":[{"value":"*  \n    # 注释示例\n    pub mod outer_module {\n \n        //!  - 模块级文档注释，置于模块头部\n        //!! - 模块级文档注释，但是和上面注释置于同一行\n\n        //!  - 模块级文档注释，但会换行\n \n        /*!  - 模块块级文档注释 */\n        /*!! - 模块级注释，但是和上面注释置于同一行 */\n\n        /*!  - 模块块级注释，但会换行 */\n \n        //   - 普通行注释\n        ///  - 行级文档注释 ( 必须是 3 个斜杠)\n        //// - 普通行注释\n \n        /*   - 普通块级注释 */\n        /**  - 块级文档注释 (精确) 2 个星号 */\n        /*** - 普通注释 */\n \n        pub mod inner_module {}\n \n        pub mod nested_comments {\n            /* Rust 中的注释内/* 可以 /* 嵌入注释 */ */ */\n \n            // 所有三种块注释都可以相互包含或嵌套\n \n            /*   /* */  /** */  /*! */  */\n            /*!  /* */  /** */  /*! */  */\n            /**  /* */  /** */  /*! */  */\n            pub mod dummy_item {}\n        }\n \n        pub mod degenerate_cases {\n            // 空的模块级文档注释\n            //!\n \n            // 空的模块块级文档注释\n            /*!*/\n \n            // 空的行注释\n            //\n \n            // empty outer line doc\n            /// 空的行级文档注释\n \n            // 空的块注释\n            /**/\n \n            pub mod dummy_item {}\n \n            // 注意，此处不是空的块级文档注释，而只是一个普通的块级注释\n            /***/\n \n        }\n \n        /* \n        下面这种文档注释是不允许的，因为文档注释下面必须要有语言项，比如方法、函数等\n        /// Where is my item?\n        */\n    }\n\n*/","span":{"file_name":"src/ch01/lexical.rs","byte_start":3246,"byte_end":4987,"line_start":135,"line_end":199,"column_start":1,"column_end":3}},{"value":"/  - 模块级文档注释，置于模块头部","span":{"file_name":"src/ch01/lexical.rs","byte_start":5016,"byte_end":5065,"line_start":202,"line_end":202,"column_start":5,"column_end":26}},{"value":"/! - 模块级文档注释，但是和上面注释置于同一行","span":{"file_name":"src/ch01/lexical.rs","byte_start":5070,"byte_end":5137,"line_start":203,"line_end":203,"column_start":5,"column_end":32}},{"value":"/  - 模块级文档注释，但会换行","span":{"file_name":"src/ch01/lexical.rs","byte_start":5143,"byte_end":5186,"line_start":205,"line_end":205,"column_start":5,"column_end":24}},{"value":"*  - 模块块级文档注释 */","span":{"file_name":"src/ch01/lexical.rs","byte_start":5193,"byte_end":5227,"line_start":207,"line_end":207,"column_start":5,"column_end":23}},{"value":"*! - 模块级注释，但是和上面注释置于同一行 */","span":{"file_name":"src/ch01/lexical.rs","byte_start":5232,"byte_end":5296,"line_start":208,"line_end":208,"column_start":5,"column_end":33}},{"value":"*  - 模块块级注释，但会换行 */","span":{"file_name":"src/ch01/lexical.rs","byte_start":5302,"byte_end":5345,"line_start":210,"line_end":210,"column_start":5,"column_end":26}}]},{"kind":"Mod","id":{"krate":0,"index":10},"span":{"file_name":"src/ch01/lexical.rs","byte_start":5585,"byte_end":5597,"line_start":220,"line_end":220,"column_start":13,"column_end":25},"name":"inner_module","qualname":"::ch01::lexical::outer_module::inner_module","value":"src/ch01/lexical.rs","parent":null,"children":[],"decl_id":null,"docs":"  - 行级文档注释 ( 必须是 3 个斜杠)\n  - 块级文档注释 (精确) 2 个星号 \n","sig":null,"attributes":[{"value":"/  - 行级文档注释 ( 必须是 3 个斜杠)","span":{"file_name":"src/ch01/lexical.rs","byte_start":5379,"byte_end":5429,"line_start":213,"line_end":213,"column_start":5,"column_end":31}},{"value":"*  - 块级文档注释 (精确) 2 个星号 */","span":{"file_name":"src/ch01/lexical.rs","byte_start":5495,"byte_end":5544,"line_start":217,"line_end":217,"column_start":5,"column_end":32}}]},{"kind":"Mod","id":{"krate":0,"index":11},"span":{"file_name":"src/ch01/lexical.rs","byte_start":5642,"byte_end":5657,"line_start":223,"line_end":223,"column_start":13,"column_end":28},"name":"nested_comments","qualname":"::ch01::lexical::outer_module::nested_comments","value":"src/ch01/lexical.rs","parent":null,"children":[{"krate":0,"index":12}],"decl_id":null,"docs":" mod 定义个模块\n  /* */  /** */  /*! */  \n","sig":null,"attributes":[{"value":"/ mod 定义个模块","span":{"file_name":"src/ch01/lexical.rs","byte_start":5606,"byte_end":5629,"line_start":222,"line_end":222,"column_start":5,"column_end":18}},{"value":"*  /* */  /** */  /*! */  */","span":{"file_name":"src/ch01/lexical.rs","byte_start":5838,"byte_end":5868,"line_start":229,"line_end":229,"column_start":9,"column_end":39}}]},{"kind":"Mod","id":{"krate":0,"index":12},"span":{"file_name":"src/ch01/lexical.rs","byte_start":5924,"byte_end":5934,"line_start":231,"line_end":231,"column_start":17,"column_end":27},"name":"dummy_item","qualname":"::ch01::lexical::outer_module::nested_comments::dummy_item","value":"src/ch01/lexical.rs","parent":null,"children":[],"decl_id":null,"docs":"  /* */  /** */  /*! */  \n","sig":null,"attributes":[{"value":"*  /* */  /** */  /*! */  */","span":{"file_name":"src/ch01/lexical.rs","byte_start":5877,"byte_end":5907,"line_start":230,"line_end":230,"column_start":9,"column_end":39}}]},{"kind":"Mod","id":{"krate":0,"index":13},"span":{"file_name":"src/ch01/lexical.rs","byte_start":5957,"byte_end":5973,"line_start":234,"line_end":234,"column_start":13,"column_end":29},"name":"degenerate_cases","qualname":"::ch01::lexical::outer_module::degenerate_cases","value":"src/ch01/lexical.rs","parent":null,"children":[{"krate":0,"index":14}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"/","span":{"file_name":"src/ch01/lexical.rs","byte_start":6023,"byte_end":6026,"line_start":236,"line_end":236,"column_start":9,"column_end":12}},{"value":"**/","span":{"file_name":"src/ch01/lexical.rs","byte_start":6078,"byte_end":6083,"line_start":239,"line_end":239,"column_start":9,"column_end":14}}]},{"kind":"Mod","id":{"krate":0,"index":14},"span":{"file_name":"src/ch01/lexical.rs","byte_start":6251,"byte_end":6261,"line_start":250,"line_end":250,"column_start":17,"column_end":27},"name":"dummy_item","qualname":"::ch01::lexical::outer_module::degenerate_cases::dummy_item","value":"src/ch01/lexical.rs","parent":null,"children":[],"decl_id":null,"docs":" 空的行级文档注释\n","sig":null,"attributes":[{"value":"/ 空的行级文档注释","span":{"file_name":"src/ch01/lexical.rs","byte_start":6164,"byte_end":6192,"line_start":245,"line_end":245,"column_start":9,"column_end":21}}]},{"kind":"Mod","id":{"krate":0,"index":15},"span":{"file_name":"src/ch01/expr.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"expr","qualname":"::ch01::expr","value":"src/ch01/expr.rs","parent":null,"children":[{"krate":0,"index":16},{"krate":0,"index":17},{"krate":0,"index":18},{"krate":0,"index":19}],"decl_id":null,"docs":" 第一章：Rust语言基础\n 1.4 语法面面观（二）：面向表达式（上）\n \n \n    \n","sig":null,"attributes":[{"value":"allow(unused_variables)","span":{"file_name":"src/ch01/expr.rs","byte_start":6551,"byte_end":6578,"line_start":1,"line_end":1,"column_start":1,"column_end":28}},{"value":"/ 第一章：Rust语言基础","span":{"file_name":"src/ch01/expr.rs","byte_start":6579,"byte_end":6611,"line_start":2,"line_end":2,"column_start":1,"column_end":17}},{"value":"/ 1.4 语法面面观（二）：面向表达式（上）","span":{"file_name":"src/ch01/expr.rs","byte_start":6612,"byte_end":6671,"line_start":3,"line_end":3,"column_start":1,"column_end":26}},{"value":"/ ","span":{"file_name":"src/ch01/expr.rs","byte_start":6672,"byte_end":6676,"line_start":4,"line_end":4,"column_start":1,"column_end":5}},{"value":"/ ","span":{"file_name":"src/ch01/expr.rs","byte_start":6677,"byte_end":6681,"line_start":5,"line_end":5,"column_start":1,"column_end":5}},{"value":"/    ","span":{"file_name":"src/ch01/expr.rs","byte_start":6682,"byte_end":6689,"line_start":6,"line_end":6,"column_start":1,"column_end":8}}]},{"kind":"Function","id":{"krate":0,"index":16},"span":{"file_name":"src/ch01/expr.rs","byte_start":7263,"byte_end":7266,"line_start":39,"line_end":39,"column_start":8,"column_end":11},"name":"eop","qualname":"::ch01::expr::eop","value":"pub fn eop()","parent":null,"children":[],"decl_id":null,"docs":"    ### 面向表达式 (Expression-Oriented programming)","sig":null,"attributes":[{"value":"*\n\n    ### 面向表达式 (Expression-Oriented programming)\n\n    ```\n    use std::collections::HashMap;\n\n    fn add_one(i: &mut u32) {\n        *i += 1;\n    }\n\n    fn plus_one(i: &u32) -> u32 {\n        let i = i + 1;\n        i\n    }\n\n    fn main() {\n        let mut a = 41 ;\n        add_one(&mut a) ;\n        println!(\"{:?}\", a) ;\n        \n        let a = 41;\n        let b = plus_one(&a);\n        println!(\"{:?}\", b) ;\n        \n        let mut h = HashMap::new();\n        h.insert(\"anwser\", 42);\n        println!(\"anwser is {:?}\", h[\"anwser\"]);\n    }\n    ```\n*/","span":{"file_name":"src/ch01/expr.rs","byte_start":6691,"byte_end":7255,"line_start":8,"line_end":38,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":17},"span":{"file_name":"src/ch01/expr.rs","byte_start":7875,"byte_end":7894,"line_start":70,"line_end":70,"column_start":8,"column_end":27},"name":"semi_and_block_expr","qualname":"::ch01::expr::semi_and_block_expr","value":"pub fn semi_and_block_expr()","parent":null,"children":[],"decl_id":null,"docs":"    ### 分号表达式 vs 块表达式","sig":null,"attributes":[{"value":"*\n\n    ### 分号表达式 vs 块表达式\n\n    1. 分号表达式返回值永远为自身的单元(Unit)类型：`()`\n    2. 分号表达式只有在块表达式最后一行才会进行求值，其他时候只作为「连接符」存在\n    3. 块表达式只对其最后一行表达式进行求值。\n\n    ```\n    fn main(){\n        ; \n        ;\n        {\n            ()\n        }\n        {\n            ();\n            use std::vec::Vec;\n        }\n        ();\n        &();\n        &{;}; // -> &()\n        ; // ->  ()\n    }\n    ```\n*/","span":{"file_name":"src/ch01/expr.rs","byte_start":7330,"byte_end":7867,"line_start":44,"line_end":69,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":18},"span":{"file_name":"src/ch01/expr.rs","byte_start":8286,"byte_end":8300,"line_start":92,"line_end":92,"column_start":8,"column_end":22},"name":"fizzbuzz_match","qualname":"::ch01::expr::fizzbuzz_match","value":"pub fn fizzbuzz_match()","parent":null,"children":[],"decl_id":null,"docs":"    ### FizzBuzz in match ","sig":null,"attributes":[{"value":"*\n\n    ### FizzBuzz in match \n\n    ```\n    fn main() {\n        for i in 1..102 {\n            match (i%3, i%5) {\n                (0, 0) => println!(\"FizzBuzz\"),\n                (0, _) => println!(\"Fizz\"),\n                (_, 0) => println!(\"Buzz\"),\n                (_, _) => println!(\"{}\", i)\n            }\n        }\n    }   \n    ```\n*/","span":{"file_name":"src/ch01/expr.rs","byte_start":7941,"byte_end":8278,"line_start":75,"line_end":91,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":19},"span":{"file_name":"src/ch01/expr.rs","byte_start":8663,"byte_end":8674,"line_start":114,"line_end":114,"column_start":8,"column_end":19},"name":"fizzbuzz_if","qualname":"::ch01::expr::fizzbuzz_if","value":"pub fn fizzbuzz_if()","parent":null,"children":[],"decl_id":null,"docs":"    ### FizzBuzz in if ","sig":null,"attributes":[{"value":"*\n\n    ### FizzBuzz in if \n\n    ```\n    fn main() {\n        for i in 1..102 {\n            if i % 15 == 0 { println!(\"FizzBuzz\") }\n            else if i % 3 == 0 { println!(\"Fizz\") }\n            else if i % 5 == 0 { println!(\"Buzz\") }\n            else { println!(\"{}\", i) }\n        }\n    }\n\n    ```\n\n*/","span":{"file_name":"src/ch01/expr.rs","byte_start":8352,"byte_end":8655,"line_start":97,"line_end":113,"column_start":1,"column_end":3}}]},{"kind":"Mod","id":{"krate":0,"index":20},"span":{"file_name":"src/ch01/ctfe.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"ctfe","qualname":"::ch01::ctfe","value":"src/ch01/ctfe.rs","parent":null,"children":[{"krate":0,"index":21},{"krate":0,"index":22},{"krate":0,"index":23},{"krate":0,"index":24},{"krate":0,"index":25},{"krate":0,"index":26},{"krate":0,"index":27},{"krate":0,"index":28},{"krate":0,"index":29},{"krate":0,"index":30},{"krate":0,"index":31}],"decl_id":null,"docs":" 第一章：Rust语言基础\n 1.4 语法面面观（二）：面向表达式（中）\n \n \n    \n","sig":null,"attributes":[{"value":"allow(unused_variables)","span":{"file_name":"src/ch01/ctfe.rs","byte_start":8722,"byte_end":8749,"line_start":1,"line_end":1,"column_start":1,"column_end":28}},{"value":"/ 第一章：Rust语言基础","span":{"file_name":"src/ch01/ctfe.rs","byte_start":8750,"byte_end":8782,"line_start":2,"line_end":2,"column_start":1,"column_end":17}},{"value":"/ 1.4 语法面面观（二）：面向表达式（中）","span":{"file_name":"src/ch01/ctfe.rs","byte_start":8783,"byte_end":8842,"line_start":3,"line_end":3,"column_start":1,"column_end":26}},{"value":"/ ","span":{"file_name":"src/ch01/ctfe.rs","byte_start":8843,"byte_end":8847,"line_start":4,"line_end":4,"column_start":1,"column_end":5}},{"value":"/ ","span":{"file_name":"src/ch01/ctfe.rs","byte_start":8848,"byte_end":8852,"line_start":5,"line_end":5,"column_start":1,"column_end":5}},{"value":"/    ","span":{"file_name":"src/ch01/ctfe.rs","byte_start":8853,"byte_end":8860,"line_start":6,"line_end":6,"column_start":1,"column_end":8}}]},{"kind":"Function","id":{"krate":0,"index":21},"span":{"file_name":"src/ch01/ctfe.rs","byte_start":9092,"byte_end":9107,"line_start":19,"line_end":19,"column_start":8,"column_end":23},"name":"must_const_expr","qualname":"::ch01::ctfe::must_const_expr","value":"pub fn must_const_expr()","parent":null,"children":[],"decl_id":null,"docs":"    ### 必须是常量表达式才能在常量上下文使用","sig":null,"attributes":[{"value":"*\n    ### 必须是常量表达式才能在常量上下文使用\n\n    ```\n    fn main(){\n        let an = (42,).0;\n        const AN: i32 = an; // Error: attempt to use a non-constant value in a constant\n    }\n    ```\n*/","span":{"file_name":"src/ch01/ctfe.rs","byte_start":8863,"byte_end":9084,"line_start":9,"line_end":18,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":22},"span":{"file_name":"src/ch01/ctfe.rs","byte_start":9367,"byte_end":9382,"line_start":38,"line_end":38,"column_start":8,"column_end":23},"name":"const_array_len","qualname":"::ch01::ctfe::const_array_len","value":"pub fn const_array_len()","parent":null,"children":[],"decl_id":null,"docs":"    ### const fn","sig":null,"attributes":[{"value":"*\n\n    ### const fn\n\n\n    ```\n    const fn len() -> usize { 3 }\n\n    fn main(){\n        // 数组长度是常量上下文\n        let array: [i32; len()] = [1, 2, 3];\n    }\n    ```\n\n*/","span":{"file_name":"src/ch01/ctfe.rs","byte_start":9173,"byte_end":9359,"line_start":23,"line_end":37,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":23},"span":{"file_name":"src/ch01/ctfe.rs","byte_start":10259,"byte_end":10268,"line_start":81,"line_end":81,"column_start":8,"column_end":17},"name":"const_fib","qualname":"::ch01::ctfe::const_fib","value":"pub fn const_fib()","parent":null,"children":[],"decl_id":null,"docs":"    ### const fn : fib","sig":null,"attributes":[{"value":"*\n    ### const fn : fib\n\n    ```\n    const fn gcd(a: u32, b: u32) -> u32 {\n        match (a, b) {\n            (x, 0) | (0, x) => x,\n\n            (x, y) if x % 2 == 0 && y % 2 == 0 => 2*gcd(x/2, y/2),\n            (x, y) | (y, x) if x % 2 == 0 => gcd(x/2, y),\n\n            (x, y) if x < y => gcd((y-x)/2, x),\n            (x, y) => gcd((x-y)/2, y),\n        }\n    }\n\n\n    const fn fib(n: u128) -> u128 {\n        const fn helper(n: u128, a: u128, b: u128, i: u128) -> u128 {\n            if i <= n {\n                helper(n, b, a + b, i + 1)\n            } else {\n                b\n            }\n        }\n        helper(n, 1, 1, 2)\n    }\n\n    const X: u128 = fib(10);\n    const GCD: u32 = gcd(21, 7);\n\n    fn main(){\n        println!(\"{}\", X);\n        println!(\"{}\", GCD);\n    }\n\n    ```\n\n*/","span":{"file_name":"src/ch01/ctfe.rs","byte_start":9462,"byte_end":10251,"line_start":42,"line_end":80,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":24},"span":{"file_name":"src/ch01/ctfe.rs","byte_start":10974,"byte_end":10983,"line_start":118,"line_end":118,"column_start":8,"column_end":17},"name":"const_fn_","qualname":"::ch01::ctfe::const_fn_","value":"pub fn const_fn_()","parent":null,"children":[],"decl_id":null,"docs":"    ### const fn","sig":null,"attributes":[{"value":"*\n\n    ### const fn\n\n    ```\n    const UNIT_TUPLE: [(u64, &str); 6] = {\n        let mut i = 0;\n        [\n            (1 << (10 * { i += 1; i }), \"KiB\"),\n            (1 << (10 * { i += 1; i }), \"MiB\"),\n            (1 << (10 * { i += 1; i }), \"GiB\"),\n            (1 << (10 * { i += 1; i }), \"TiB\"),\n            (1 << (10 * { i += 1; i }), \"PiB\"),\n            (1 << (10 * { i += 1; i }), \"EiB\")\n        ]\n    };\n\n    const fn square_area(a: i32) -> i32 {\n        let area = a * a;\n        area\n    }\n\n    const AREA: i32 = square_area(5);\n\n    fn main (){\n        dbg!(UNIT_TUPLE);\n        dbg!(AREA);\n    }\n    \n    ```\n*/","span":{"file_name":"src/ch01/ctfe.rs","byte_start":10344,"byte_end":10966,"line_start":87,"line_end":117,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":25},"span":{"file_name":"src/ch01/ctfe.rs","byte_start":11307,"byte_end":11321,"line_start":143,"line_end":143,"column_start":8,"column_end":22},"name":"const_fn_error","qualname":"::ch01::ctfe::const_fn_error","value":"pub fn const_fn_error()","parent":null,"children":[],"decl_id":null,"docs":"    ### 展示错误的 const 求值用法","sig":null,"attributes":[{"value":"*\n\n    ### 展示错误的 const 求值用法\n\n    ```\n    #![feature(const_fn)]\n\n    // Error\n    const fn hello() -> String{\n        \"Hello\".to_string()\n    }\n\n    // Error\n    const S : String = hello();\n\n    fn main(){ \n        println!(\" {:?} \", S);\n    }\n\n    ```\n*/","span":{"file_name":"src/ch01/ctfe.rs","byte_start":11025,"byte_end":11299,"line_start":122,"line_end":142,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":26},"span":{"file_name":"src/ch01/ctfe.rs","byte_start":11584,"byte_end":11604,"line_start":164,"line_end":164,"column_start":8,"column_end":28},"name":"fixed_const_fn_error","qualname":"::ch01::ctfe::fixed_const_fn_error","value":"pub fn fixed_const_fn_error()","parent":null,"children":[],"decl_id":null,"docs":"    ### 修正错误的 const 求值用法","sig":null,"attributes":[{"value":"*\n    ### 修正错误的 const 求值用法\n\n    ```\n\n    const fn hello() -> &'static str{\n        \"Hello\"\n    }\n\n    const Y: &str = hello();\n\n    fn main(){\n        println!(\"{}\", Y);\n    }\n\n    ```\n*/","span":{"file_name":"src/ch01/ctfe.rs","byte_start":11369,"byte_end":11576,"line_start":147,"line_end":163,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":27},"span":{"file_name":"src/ch01/ctfe.rs","byte_start":11853,"byte_end":11868,"line_start":184,"line_end":184,"column_start":8,"column_end":23},"name":"others_const_fn","qualname":"::ch01::ctfe::others_const_fn","value":"pub fn others_const_fn()","parent":null,"children":[],"decl_id":null,"docs":"    ### 其他的Const fn 用法","sig":null,"attributes":[{"value":"*\n\n    ### 其他的Const fn 用法\n\n    ```\n    #[derive(Debug)]\n    struct Answer(u32);\n    const A: Answer = Answer(42);\n\n    fn main(){\n        println!(\"{}\", A);\n    }\n\n    ```\n*/","span":{"file_name":"src/ch01/ctfe.rs","byte_start":11659,"byte_end":11845,"line_start":169,"line_end":183,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":28},"span":{"file_name":"src/ch01/ctfe.rs","byte_start":12092,"byte_end":12100,"line_start":202,"line_end":202,"column_start":8,"column_end":16},"name":"mir_show","qualname":"::ch01::ctfe::mir_show","value":"pub fn mir_show()","parent":null,"children":[],"decl_id":null,"docs":"    ### 编译期计算原理：MIR 展示\n    ```\n    const fn anwser() -> u32 { 42 }","sig":null,"attributes":[{"value":"*\n\n    ### 编译期计算原理：MIR 展示\n    ```\n    const fn anwser() -> u32 { 42 }\n\n    const A: u32 = anwser();\n\n    fn main(){\n        A;\n    }\n    ```\n\n*/","span":{"file_name":"src/ch01/ctfe.rs","byte_start":11918,"byte_end":12084,"line_start":188,"line_end":201,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":29},"span":{"file_name":"src/ch01/ctfe.rs","byte_start":12789,"byte_end":12802,"line_start":239,"line_end":239,"column_start":8,"column_end":21},"name":"if_while_true","qualname":"::ch01::ctfe::if_while_true","value":"pub fn if_while_true()","parent":null,"children":[],"decl_id":null,"docs":"    ### If True && While True","sig":null,"attributes":[{"value":"*\n\n    ### If True && While True\n\n    ```\n    fn if_true(x: i32) -> i32 {\n        if true {  // error[E0308]: mismatched types，expected type `i32` found type `()`\n            return x+1;\n        }\n    }\n\n    fn while_true(x: i32) -> i32 {\n        while true {  // error[E0308]: mismatched types，expected type `i32` found type `()`\n            return x+1;\n        }\n    }\n\n    fn main() {\n        let y = while_true(5);\n        assert_eq!(y, 6);\n\n        let y = if_true(5);\n        assert_eq!(y, 6);\n\n        let x;\n        // while true { x = 1; break; } \n        loop { x = 1; break; }\n        println!(\"{}\", x);\n\n    }\n    ```\n\n*/","span":{"file_name":"src/ch01/ctfe.rs","byte_start":12142,"byte_end":12781,"line_start":206,"line_end":238,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":30},"span":{"file_name":"src/ch01/ctfe.rs","byte_start":14146,"byte_end":14164,"line_start":297,"line_end":297,"column_start":8,"column_end":26},"name":"const_generic_show","qualname":"::ch01::ctfe::const_generic_show","value":"pub fn const_generic_show()","parent":null,"children":[],"decl_id":null,"docs":"    ### const generic ","sig":null,"attributes":[{"value":"*\n    ### const generic \n\n    ```\n    #![feature(min_const_generics)]\n    #![feature(const_in_array_repeat_expressions)]\n\n    use core::mem::MaybeUninit;\n\n    #[derive(Debug)]\n    pub struct ArrayVec<T, const N: usize> {\n        items: [MaybeUninit<T>; N],\n        length: usize,\n    }\n\n    impl<T, const N: usize> ArrayVec<T,  {N} > {\n        pub const fn new() -> ArrayVec<T, {N} > {\n            ArrayVec {\n                items: [MaybeUninit::uninit(); N],\n                length: 0,\n            }\n        }\n        \n        #[inline]\n        pub const fn len(&self) -> usize { self.length }\n        \n        #[inline]\n        pub const fn is_empty(&self) -> bool { self.len() == 0 }\n        \n        #[inline]\n        pub const fn capacity(&self) -> usize { N }\n        \n        #[inline]\n        pub const fn is_full(&self) -> bool { self.len() >= self.capacity() }\n        \n    }\n\n    impl<T, const N: usize> Drop for ArrayVec<T, { N }> {\n        #[inline]\n        fn drop(&mut self) {\n            // Makes sure the destructors for all items are run.\n            // self.clear();\n        }\n    }\n\n\n    fn main(){\n        // let mut vector = ArrayVec::new();\n        // println!(\"{}, {}\", vector.len(), vector.capacity());\n        // println!(\"{:?}\", vector);\n    }\n    ```\n*/","span":{"file_name":"src/ch01/ctfe.rs","byte_start":12855,"byte_end":14138,"line_start":244,"line_end":296,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":31},"span":{"file_name":"src/ch01/ctfe.rs","byte_start":14630,"byte_end":14646,"line_start":320,"line_end":320,"column_start":8,"column_end":24},"name":"array_chunk_show","qualname":"::ch01::ctfe::array_chunk_show","value":"pub fn array_chunk_show()","parent":null,"children":[],"decl_id":null,"docs":"    ### array chunk 演示","sig":null,"attributes":[{"value":"*\n\n    ### array chunk 演示\n\n    ```\n    #![feature(array_chunks)]\n    fn main() {\n        let data = [1, 2, 3, 4, 5, 6];\n        let sum1 = data.array_chunks().map(|&[x, y]| x * y).sum::<i32>();\n        assert_eq!(sum1, (1 * 2) + (3 * 4) + (5 * 6));\n\n        let sum2 = data.array_chunks().map(|&[x, y, z]| x * y * z).sum::<i32>();\n        assert_eq!(sum2, (1 * 2 * 3) + (4 * 5 * 6));\n    }\n\n    ```\n*/","span":{"file_name":"src/ch01/ctfe.rs","byte_start":14215,"byte_end":14622,"line_start":303,"line_end":319,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":32},"span":{"file_name":"src/ch01/mod.rs","byte_start":442,"byte_end":447,"line_start":18,"line_end":18,"column_start":8,"column_end":13},"name":"title","qualname":"::ch01::title","value":"pub fn title()","parent":null,"children":[],"decl_id":null,"docs":" # Examples","sig":null,"attributes":[{"value":"/ # Examples","span":{"file_name":"src/ch01/mod.rs","byte_start":322,"byte_end":336,"line_start":10,"line_end":10,"column_start":1,"column_end":15}},{"value":"/","span":{"file_name":"src/ch01/mod.rs","byte_start":337,"byte_end":340,"line_start":11,"line_end":11,"column_start":1,"column_end":4}},{"value":"/ Basic usage:","span":{"file_name":"src/ch01/mod.rs","byte_start":341,"byte_end":357,"line_start":12,"line_end":12,"column_start":1,"column_end":17}},{"value":"/","span":{"file_name":"src/ch01/mod.rs","byte_start":358,"byte_end":361,"line_start":13,"line_end":13,"column_start":1,"column_end":4}},{"value":"/ ```","span":{"file_name":"src/ch01/mod.rs","byte_start":362,"byte_end":369,"line_start":14,"line_end":14,"column_start":1,"column_end":8}},{"value":"/   println!(\"第1章：{}\", \"Rust语言基础\");","span":{"file_name":"src/ch01/mod.rs","byte_start":370,"byte_end":421,"line_start":15,"line_end":15,"column_start":1,"column_end":38}},{"value":"/ ","span":{"file_name":"src/ch01/mod.rs","byte_start":422,"byte_end":426,"line_start":16,"line_end":16,"column_start":1,"column_end":5}},{"value":"/ ```","span":{"file_name":"src/ch01/mod.rs","byte_start":427,"byte_end":434,"line_start":17,"line_end":17,"column_start":1,"column_end":8}}]},{"kind":"Mod","id":{"krate":0,"index":33},"span":{"file_name":"src/ch02/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"ch02","qualname":"::ch02","value":"src/ch02/mod.rs","parent":null,"children":[{"krate":0,"index":34},{"krate":0,"index":42},{"krate":0,"index":50},{"krate":0,"index":55},{"krate":0,"index":57},{"krate":0,"index":65},{"krate":0,"index":67},{"krate":0,"index":71},{"krate":0,"index":76}],"decl_id":null,"docs":" 第二章：Rust核心概念","sig":null,"attributes":[{"value":"/ 第二章：Rust核心概念","span":{"file_name":"src/ch02/mod.rs","byte_start":14693,"byte_end":14725,"line_start":1,"line_end":1,"column_start":1,"column_end":17}},{"value":"/","span":{"file_name":"src/ch02/mod.rs","byte_start":14726,"byte_end":14729,"line_start":2,"line_end":2,"column_start":1,"column_end":4}},{"value":"/ 本章包括：","span":{"file_name":"src/ch02/mod.rs","byte_start":14730,"byte_end":14749,"line_start":3,"line_end":3,"column_start":1,"column_end":10}},{"value":"/ 1. 安全管理","span":{"file_name":"src/ch02/mod.rs","byte_start":14750,"byte_end":14769,"line_start":4,"line_end":4,"column_start":1,"column_end":12}},{"value":"/ 2. 工程能力","span":{"file_name":"src/ch02/mod.rs","byte_start":14770,"byte_end":14789,"line_start":5,"line_end":5,"column_start":1,"column_end":12}},{"value":"/ 3. 元编程","span":{"file_name":"src/ch02/mod.rs","byte_start":14790,"byte_end":14806,"line_start":6,"line_end":6,"column_start":1,"column_end":11}},{"value":"/ 4. 安全边界","span":{"file_name":"src/ch02/mod.rs","byte_start":14807,"byte_end":14826,"line_start":7,"line_end":7,"column_start":1,"column_end":12}}]},{"kind":"Mod","id":{"krate":0,"index":34},"span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"s1_ownership","qualname":"::ch02::s1_ownership","value":"src/ch02/s1_ownership.rs","parent":null,"children":[{"krate":0,"index":35},{"krate":0,"index":36},{"krate":0,"index":37},{"krate":0,"index":38},{"krate":0,"index":39},{"krate":0,"index":40},{"krate":0,"index":41}],"decl_id":null,"docs":" 第二章：Rust核心概念\n 2.1 安全管理之内存安全\n \n 所有权相关代码\n \n  String 结构：\n  \n  ```text\n  ---  \n                   buffer\n                  /   capacity\n                 /   /  length\n                /   /   /\n              +–––+–––+–––+\n  stack frame │ • │ 8 │ 6 │ <- my_name: String\n              +–│–+–––+–––+\n                │\n              [–│–––––––– capacity –––––––––––]\n                │\n              +–V–+–––+–––+–––+–––+–––+–––+–––+\n  heap        │ P │ a │ s │ c │ a │ l │   │   │\n              +–––+–––+–––+–––+–––+–––+–––+–––+\n              [––––––– length ––––––––]\n   \n  &'static str 结构：\n              [–––––––––––]\n              +–––+–––+\n  stack frame │ • │ 6 │ \n              +–│–+–––+\n                │                 \n                +––+                \n                   │\n  preallocated   +–V–+–––+–––+–––+–––+–––+\n  read-only      │ P │ a │ s │ c │ a │ l │\n  memory         +–––+–––+–––+–––+–––+–––+\n  ```\n","sig":null,"attributes":[{"value":"/ 第二章：Rust核心概念","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15171,"byte_end":15203,"line_start":1,"line_end":1,"column_start":1,"column_end":17}},{"value":"/ 2.1 安全管理之内存安全","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15204,"byte_end":15239,"line_start":2,"line_end":2,"column_start":1,"column_end":18}},{"value":"/ ","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15240,"byte_end":15244,"line_start":3,"line_end":3,"column_start":1,"column_end":5}},{"value":"/ 所有权相关代码","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15245,"byte_end":15270,"line_start":4,"line_end":4,"column_start":1,"column_end":12}},{"value":"/ ","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15271,"byte_end":15275,"line_start":5,"line_end":5,"column_start":1,"column_end":5}},{"value":"/  String 结构：","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15276,"byte_end":15297,"line_start":6,"line_end":6,"column_start":1,"column_end":16}},{"value":"/  ","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15298,"byte_end":15303,"line_start":7,"line_end":7,"column_start":1,"column_end":6}},{"value":"/  ```text","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15304,"byte_end":15316,"line_start":8,"line_end":8,"column_start":1,"column_end":13}},{"value":"/  ---  ","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15317,"byte_end":15327,"line_start":9,"line_end":9,"column_start":1,"column_end":11}},{"value":"/                   buffer","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15328,"byte_end":15356,"line_start":10,"line_end":10,"column_start":1,"column_end":29}},{"value":"/                  /   capacity","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15357,"byte_end":15390,"line_start":11,"line_end":11,"column_start":1,"column_end":34}},{"value":"/                 /   /  length","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15391,"byte_end":15424,"line_start":12,"line_end":12,"column_start":1,"column_end":34}},{"value":"/                /   /   /","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15425,"byte_end":15453,"line_start":13,"line_end":13,"column_start":1,"column_end":29}},{"value":"/              +–––+–––+–––+","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15454,"byte_end":15502,"line_start":14,"line_end":14,"column_start":1,"column_end":31}},{"value":"/  stack frame │ • │ 8 │ 6 │ <- my_name: String","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15503,"byte_end":15562,"line_start":15,"line_end":15,"column_start":1,"column_end":50}},{"value":"/              +–│–+–––+–––+","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15563,"byte_end":15611,"line_start":16,"line_end":16,"column_start":1,"column_end":31}},{"value":"/                │","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15612,"byte_end":15634,"line_start":17,"line_end":17,"column_start":1,"column_end":21}},{"value":"/              [–│–––––––– capacity –––––––––––]","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15635,"byte_end":15727,"line_start":18,"line_end":18,"column_start":1,"column_end":51}},{"value":"/                │","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15728,"byte_end":15750,"line_start":19,"line_end":19,"column_start":1,"column_end":21}},{"value":"/              +–V–+–––+–––+–––+–––+–––+–––+–––+","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15751,"byte_end":15847,"line_start":20,"line_end":20,"column_start":1,"column_end":51}},{"value":"/  heap        │ P │ a │ s │ c │ a │ l │   │   │","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15848,"byte_end":15916,"line_start":21,"line_end":21,"column_start":1,"column_end":51}},{"value":"/              +–––+–––+–––+–––+–––+–––+–––+–––+","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":15917,"byte_end":16015,"line_start":22,"line_end":22,"column_start":1,"column_end":51}},{"value":"/              [––––––– length ––––––––]","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":16016,"byte_end":16088,"line_start":23,"line_end":23,"column_start":1,"column_end":43}},{"value":"/   ","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":16089,"byte_end":16095,"line_start":24,"line_end":24,"column_start":1,"column_end":7}},{"value":"/  &'static str 结构：","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":16096,"byte_end":16123,"line_start":25,"line_end":25,"column_start":1,"column_end":22}},{"value":"/              [–––––––––––]","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":16124,"byte_end":16176,"line_start":26,"line_end":26,"column_start":1,"column_end":31}},{"value":"/              +–––+–––+","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":16177,"byte_end":16215,"line_start":27,"line_end":27,"column_start":1,"column_end":27}},{"value":"/  stack frame │ • │ 6 │ ","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":16216,"byte_end":16251,"line_start":28,"line_end":28,"column_start":1,"column_end":28}},{"value":"/              +–│–+–––+","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":16252,"byte_end":16290,"line_start":29,"line_end":29,"column_start":1,"column_end":27}},{"value":"/                │                 ","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":16291,"byte_end":16330,"line_start":30,"line_end":30,"column_start":1,"column_end":38}},{"value":"/                +––+                ","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":16331,"byte_end":16374,"line_start":31,"line_end":31,"column_start":1,"column_end":40}},{"value":"/                   │","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":16375,"byte_end":16400,"line_start":32,"line_end":32,"column_start":1,"column_end":24}},{"value":"/  preallocated   +–V–+–––+–––+–––+–––+–––+","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":16401,"byte_end":16480,"line_start":33,"line_end":33,"column_start":1,"column_end":46}},{"value":"/  read-only      │ P │ a │ s │ c │ a │ l │","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":16481,"byte_end":16540,"line_start":34,"line_end":34,"column_start":1,"column_end":46}},{"value":"/  memory         +–––+–––+–––+–––+–––+–––+","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":16541,"byte_end":16622,"line_start":35,"line_end":35,"column_start":1,"column_end":46}},{"value":"/  ```","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":16623,"byte_end":16631,"line_start":36,"line_end":36,"column_start":1,"column_end":9}}]},{"kind":"Function","id":{"krate":0,"index":35},"span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":17831,"byte_end":17846,"line_start":83,"line_end":83,"column_start":8,"column_end":23},"name":"primitive_types","qualname":"::ch02::s1_ownership::primitive_types","value":"pub fn primitive_types()","parent":null,"children":[],"decl_id":null,"docs":"    ### Rust 语义：Move 语义 与 Copy 语义","sig":null,"attributes":[{"value":"*\n    ### Rust 语义：Move 语义 与 Copy 语义\n\n    基本数据类型： https://doc.rust-lang.org/std/index.html#primitives\n\n    ```\n    fn main(){\n        // impl Copy for i32\n        let a = 42;\n        let b = a;\n        println!(\"{:?}\", a);  // work\n\n        // impl Copy for &'static str\n        let a = \"42\";\n        let b = a;\n        println!(\"{:?}\", a); // work\n        \n        // impl !Copy for String\n        let a = \"42\".to_string();\n        // &String deref to &str\n        let b : &str = &a;\n        // impl Copy for &'a T\n        let c = b;\n        println!(\"{:?}\", b); // work\n\n        // impl !Copy for String\n        let mut a = \"42\".to_string();\n        // impl !Copy for &mut T\n        let b : &mut str = &mut a;\n        let c = b;\n        // println!(\"{:?}\", b); // don't work, b have been moved\n        \n        // auto impl Copy for Tuple, if all item implemented Copy trait in Tuple\n        let t = (42, \"42\");\n        let t2 = t;\n        println!(\"{:?}\", t); // work\n        \n        // auto impl !Copy for Tuple\n        let t = (42, \"42\".to_string());\n        let t2 = t;\n        // println!(\"{:?}\", t); // don't work, t have been moved\n    }\n    ```\n*/","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":16634,"byte_end":17823,"line_start":39,"line_end":82,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":36},"span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":18686,"byte_end":18698,"line_start":129,"line_end":129,"column_start":8,"column_end":20},"name":"custom_types","qualname":"::ch02::s1_ownership::custom_types","value":"pub fn custom_types()","parent":null,"children":[],"decl_id":null,"docs":"    ### Rust 语义：Move 语义 与 Copy 语义","sig":null,"attributes":[{"value":"*\n    ### Rust 语义：Move 语义 与 Copy 语义\n\n    自定义数据类型：\n\n    ```\n    // #[derive(Copy, Clone)]\n    struct A;\n\n    // #[derive(Copy, Clone)]\n    struct Point(u32);\n\n    // #[derive(Copy, Clone)]\n    struct Member {\n        name: &'static str,\n        age: u32,\n    }\n\n    // #[derive(Copy, Clone)]\n    struct Person {\n        name: String,\n        age: u32,\n    }\n\n    fn main(){\n        let a = A;\n        let b = a;\n        println!(\"{:?}\", a);  // work\n\n        let a = Point(60);\n        let b = a;\n        println!(\"{:?}\", a);  // work\n\n        let a = Member{name: \"Alex\", age: \"18\"};\n        let b = a;\n\n        let a = Member{name: \"Alex\".to_string(), age: \"18\"};\n        let b = a;\n    }\n    ```\n*/","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":17944,"byte_end":18678,"line_start":88,"line_end":128,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":37},"span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":19275,"byte_end":19296,"line_start":161,"line_end":161,"column_start":8,"column_end":29},"name":"understand_copy_clone","qualname":"::ch02::s1_ownership::understand_copy_clone","value":"pub fn understand_copy_clone()","parent":null,"children":[],"decl_id":null,"docs":"    ### Rust 语义：Move 语义 与 Copy 语义","sig":null,"attributes":[{"value":"*\n    ### Rust 语义：Move 语义 与 Copy 语义\n\n    - 理解 Copy：Clone  https://doc.rust-lang.org/std/marker/trait.Copy.html\n\n\n    ```\n    struct A;\n\n    // 没用，自己实现Copy和Clone无法改变编译器默认行为\n    impl Clone for A {\n        fn clone(&self) -> Self {\n            println!(\"from Custom Copy: Clone\");\n            *self\n        }\n    }\n\n    impl Copy for A {}\n\n\n    fn main(){\n        let a = A;\n        let b = a;\n    }\n    \n    ```\n*/","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":18793,"byte_end":19267,"line_start":134,"line_end":160,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":38},"span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":21458,"byte_end":21473,"line_start":259,"line_end":259,"column_start":8,"column_end":23},"name":"understand_copy","qualname":"::ch02::s1_ownership::understand_copy","value":"pub fn understand_copy()","parent":null,"children":[],"decl_id":null,"docs":"    ### Rust 语义：Move 语义 与 Copy 语义","sig":null,"attributes":[{"value":"*\n    ### Rust 语义：Move 语义 与 Copy 语义\n\n    - 理解 按位复制\n\n    ```\n    #[derive(Copy, Clone)]\n    struct A(i8, i32);\n    fn main() {\n        let a = A(1, 2);\n        let b = a; // 按位复制，复制后，b和a完全相同，包括内存对齐填充的padding部分。\n        let c = A(a.0, a.1); // 逐成员复制，非按位复制，c和a的padding部分不一定相同。        \n    }\n    \n    ```\n\n    示例二：\n    \n    ```rust\n    #[derive(Debug, Copy, Clone)]\n    struct A {\n        a: u16,\n        b: u8,\n        c: bool,\n    }\n\n    fn main() {\n        let a = unsound_a();\n        // 尝试将 Some(a) 改为 a\n        let some_a = Some(a);\n        \n        println!(\"a: {:#?}\", a);\n        println!(\"some_a: {:#?}\", some_a);\n    }\n\n\n    fn unsound_a() -> A {\n        #[derive(Debug, Copy, Clone)]\n        struct B {\n            a: u16,\n            b: u8,\n            c: u8,\n        }\n        // 依次修改 c 的值为 0，1，2 打印输出结果\n        let b = B { a: 1, b: 1, c: 1 };\n        unsafe {*(&b as *const B as *const A) }\n    }\n    ```\n\n    示例三：\n\n    ```rust\n    #![allow(unused_variables)]\n\n    use std::{ptr, mem};\n\n    fn main() {\n        let mut d = String::from(\"cccc\");\n        let d_len = d.len();\n        // {\n            let mut c = String::with_capacity(d_len);\n\n            unsafe {\n                ptr::copy(&d, &mut c, 1);\n            };\n            println!(\"{:?}\", c.as_ptr());\n            // unsafe {\n            //     ptr::drop_in_place(c.as_mut_ptr());\n            // }\n            // 注掉 drop，会产生double free，\n            // 但是不注掉 drop，会产生无效指针\n            mem::drop(c);\n        // }\n\n        println!(\"{:?}\", d.as_ptr());\n        d.push_str(\"c\");\n        println!(\"{}\", d);\n    }\n    ```\n\n    示例四: Copy 不一定只在栈上进行\n\n    ```rust\n    use std::cell::RefCell;\n\n    fn main() {\n        let a = Box::new(RefCell::new(1));\n        let b = Box::new(RefCell::new(2));\n        *b.borrow_mut() = *a.borrow();\n        println!(\"b = {}\", b.borrow());\n    }\n    ```\n*/","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":19352,"byte_end":21450,"line_start":166,"line_end":258,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":39},"span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":22319,"byte_end":22334,"line_start":302,"line_end":302,"column_start":8,"column_end":23},"name":"understand_move","qualname":"::ch02::s1_ownership::understand_move","value":"pub fn understand_move()","parent":null,"children":[],"decl_id":null,"docs":"    示例1: Box<T> 实现 DereMove","sig":null,"attributes":[{"value":"*\n\n    示例1: Box<T> 实现 DereMove\n\n    ```rust\n    fn main(){\n        let s = Box::new(\"hello\".to_string());\n        println!(\"{:p}\", &s);\n        println!(\"{:p}\", s.as_ptr());\n        // DerefMove\n        let s2 = *s;\n        // println!(\"{:p}\", s.as_ptr()); // Moved s\n        println!(\"{:p}\", s2.as_ptr());\n    }\n    ```\n\n    示例二：Arc 无法 DerefMove\n\n    https://doc.rust-lang.org/std/sync/struct.Arc.html\n\n\n\n    ```rust\n    use std::sync::Arc;\n\n    fn main(){\n        let s = Arc::new(\"hello\".to_string());\n        println!(\"{:p}\", &s);\n        println!(\"{:p}\", s.as_ptr());\n        // DerefMove Error : cannot move out of an `Arc`\n        let s2 = *s;\n        // println!(\"{:p}\", s.as_ptr()); // Moved s\n        println!(\"{:p}\", s2.as_ptr());\n    }\n    ```\n\n*/","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":21530,"byte_end":22311,"line_start":265,"line_end":301,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":40},"span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":22577,"byte_end":22593,"line_start":312,"line_end":312,"column_start":8,"column_end":24},"name":"understand_clone","qualname":"::ch02::s1_ownership::understand_clone","value":"pub fn understand_clone()","parent":null,"children":[],"decl_id":null,"docs":"    语义层面来理解 Clone ：显式的clone方法调用同一种语义下的两种实现\n    1. String 等 引用类型的 Clone\n    2. Rc/Arc 类型的 Clone\n","sig":null,"attributes":[{"value":"*\n    语义层面来理解 Clone ：显式的clone方法调用同一种语义下的两种实现\n    1. String 等 引用类型的 Clone\n    2. Rc/Arc 类型的 Clone\n*/","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":22398,"byte_end":22569,"line_start":307,"line_end":311,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":41},"span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":26030,"byte_end":26045,"line_start":476,"line_end":476,"column_start":8,"column_end":23},"name":"understand_drop","qualname":"::ch02::s1_ownership::understand_drop","value":"pub fn understand_drop()","parent":null,"children":[],"decl_id":null,"docs":"    示例1: Move 的本质：drop 标记","sig":null,"attributes":[{"value":"*\n\n    示例1: Move 的本质：drop 标记\n\n    ```rust\n    fn main(){\n        // impl Copy for i32\n        let mut a = \"42\".to_string();\n        let b = a; // drop(a);\n        \n        a = \"32\".to_string();\n        println!(\"{:?}\", a);\n    }\n    ```\n\n    示例二：Drop 析构函数\n\n\n    ```rust\n    struct PrintDrop(&'static str);\n    impl Drop for PrintDrop {\n        fn drop(&mut self) {\n            println!(\"Dropping {}\", self.0)\n        }\n    }\n    fn main() {\n        let x = PrintDrop(\"x\");\n        let y = PrintDrop(\"y\");\n    }\n    ```\n    \n    元组：\n\n    ```rust\n    struct PrintDrop(&'static str);\n        impl Drop for PrintDrop {\n            fn drop(&mut self) {\n                println!(\"Dropping {}\", self.0)\n        }\n    }\n    fn main() {\n        let tup1 = (PrintDrop(\"a\"), PrintDrop(\"b\"), PrintDrop(\"c\"));\n        let tup2 = (PrintDrop(\"x\"), PrintDrop(\"y\"), PrintDrop(\"z\"));\n    }\n    ```\n\n    带panic的元组：\n\n    ```rust\n    struct PrintDrop(&'static str);\n    impl Drop for PrintDrop {\n        fn drop(&mut self) {\n            println!(\"Dropping {}\", self.0)\n    }\n    }\n    fn main() {\n        let tup1 = (PrintDrop(\"a\"), PrintDrop(\"b\"), PrintDrop(\"c\"));\n        let tup2 = (PrintDrop(\"x\"), PrintDrop(\"y\"), panic!());\n    }\n\n    ```\n \n    结构体：\n\n    ```rust\n    struct PrintDrop(&'static str);\n\n    impl Drop for PrintDrop {\n        fn drop(&mut self) {\n            println!(\"Dropping {}\", self.0)\n        }\n    }\n\n    struct Foo {\n        bar: PrintDrop,\n        baz: PrintDrop,\n    }\n\n    impl Drop for Foo {\n        fn drop(&mut self) {\n            println!(\"Dropping Foo\")\n        }\n    }\n\n    fn main() {\n        let foo = Foo {\n            bar: PrintDrop(\"bar\"),\n            baz: PrintDrop(\"baz\"),\n        };\n    }\n    ```\n\n    闭包：\n\n    ```\n    struct PrintDrop(&'static str);\n    impl Drop for PrintDrop {\n        fn drop(&mut self) {\n            println!(\"Dropping {}\", self.0)\n        }\n    }\n    fn main() {\n        let z = PrintDrop(\"z\");\n        let x = PrintDrop(\"x\");\n        let y = PrintDrop(\"y\");\n        let closure = move || { y; z; x; };\n    }\n    ```\n\n    闭包修改变量：\n\n    ```\n    struct PrintDrop(&'static str);\n    impl Drop for PrintDrop {\n        fn drop(&mut self) {\n            println!(\"Dropping {}\", self.0)\n        }\n    }\n    fn main() {\n        let y = PrintDrop(\"y\");\n        let x = PrintDrop(\"x\");\n        let z = PrintDrop(\"z\");\n        let closure = move || {\n            { let z_ref = &z; }\n            x; y; z;\n        };\n    }\n    ```\n\n    示例三： 所有权 forget/ ManuallyDrop\n\n    ```rust\n    // https://doc.rust-lang.org/src/alloc/sync.rs.html#319\n    impl<T> Arc<T> {\n        pub fn new(data: T) -> Arc<T> {\n            // Start the weak pointer count as 1 which is the weak pointer that's\n            // held by all the strong pointers (kinda), see std/rc.rs for more info\n            let x: Box<_> = box ArcInner {\n                strong: atomic::AtomicUsize::new(1),\n                weak: atomic::AtomicUsize::new(1),\n                data,\n            };\n            // ManuallyDrop\n            Self::from_inner(Box::leak(x).into())\n        }\n\n        // ...\n    }\n\n    impl<T> Weak<T> {\n        pub fn into_raw(self) -> *const T {\n            let result = self.as_ptr();\n            mem::forget(self);\n            result\n        }\n    }\n    ```\n\n*/","span":{"file_name":"src/ch02/s1_ownership.rs","byte_start":22657,"byte_end":26022,"line_start":317,"line_end":475,"column_start":1,"column_end":3}}]},{"kind":"Mod","id":{"krate":0,"index":42},"span":{"file_name":"src/ch02/s2_lifetime.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"s2_lifetime","qualname":"::ch02::s2_lifetime","value":"src/ch02/s2_lifetime.rs","parent":null,"children":[{"krate":0,"index":43},{"krate":0,"index":44},{"krate":0,"index":45},{"krate":0,"index":46},{"krate":0,"index":47},{"krate":0,"index":48},{"krate":0,"index":49}],"decl_id":null,"docs":" 第二章：Rust核心概念\n 2.2 生命周期与借用检查\n \n 借用检查相关代码\n","sig":null,"attributes":[{"value":"/ 第二章：Rust核心概念","span":{"file_name":"src/ch02/s2_lifetime.rs","byte_start":26083,"byte_end":26115,"line_start":1,"line_end":1,"column_start":1,"column_end":17}},{"value":"/ 2.2 生命周期与借用检查","span":{"file_name":"src/ch02/s2_lifetime.rs","byte_start":26116,"byte_end":26151,"line_start":2,"line_end":2,"column_start":1,"column_end":18}},{"value":"/ ","span":{"file_name":"src/ch02/s2_lifetime.rs","byte_start":26152,"byte_end":26156,"line_start":3,"line_end":3,"column_start":1,"column_end":5}},{"value":"/ 借用检查相关代码","span":{"file_name":"src/ch02/s2_lifetime.rs","byte_start":26157,"byte_end":26185,"line_start":4,"line_end":4,"column_start":1,"column_end":13}}]},{"kind":"Function","id":{"krate":0,"index":43},"span":{"file_name":"src/ch02/s2_lifetime.rs","byte_start":26474,"byte_end":26490,"line_start":22,"line_end":22,"column_start":8,"column_end":24},"name":"understand_scope","qualname":"::ch02::s2_lifetime::understand_scope","value":"pub fn understand_scope()","parent":null,"children":[],"decl_id":null,"docs":"    ### 理解词法作用域","sig":null,"attributes":[{"value":"*\n    ### 理解词法作用域\n\n    基本数据类型： https://doc.rust-lang.org/std/index.html#primitives\n\n    ```\n    fn main(){\n        let mut v = vec![];\n        v.push(1);\n        {\n            println!(\"{:?}\", v[0]);\n            v.push(2);\n        }\n    }\n    ```\n*/","span":{"file_name":"src/ch02/s2_lifetime.rs","byte_start":26187,"byte_end":26466,"line_start":6,"line_end":21,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":44},"span":{"file_name":"src/ch02/s2_lifetime.rs","byte_start":27712,"byte_end":27726,"line_start":58,"line_end":58,"column_start":8,"column_end":22},"name":"understand_nll","qualname":"::ch02::s2_lifetime::understand_nll","value":"pub fn understand_nll()","parent":null,"children":[],"decl_id":null,"docs":"    ### 理解借用检查 NLL","sig":null,"attributes":[{"value":"*\n    ### 理解借用检查 NLL\n\n    示例：替换字符串中的问号\n\n    ```\n    fn main(){\n        let s = \"abc?d\";\n        let mut chars = s.chars().collect::<Vec<char>>();\n        \n        // 处理字符串\n        for (i, c) in chars.iter_mut().enumerate() {\n            // 定义 a-z 字母集\n            let mut words = ('a'..='z').into_iter();\n            // 此处 `chars[i]` 是对chars的不可变借用\n            if chars[i] == '?' {\n                // 此处 `chars[i]` 是对chars的不可变借用\n                let left = if i==0 {None} else { Some(chars[i-1]) };\n                // 此处 `chars[i]` 是对chars的不可变借用\n                let right = if i==s.len()-1 {None} else {Some(chars[i+1])};\n                // 此处 `chars[i]` 是对chars的可变借用，要修改chars数组了\n                // 从a-z 字母集中查找和左右两边不一样的字母去替换当前字符，避免重复\n                chars[i] = words.find(|&w| Some(w) != left && Some(w) != right).unwrap();\n            }\n        }\n        \n        let s = chars.into_iter().collect::<String>();\n        println!(\"{:?}\", s);\n    }\n    ```\n*/","span":{"file_name":"src/ch02/s2_lifetime.rs","byte_start":26540,"byte_end":27704,"line_start":27,"line_end":57,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":45},"span":{"file_name":"src/ch02/s2_lifetime.rs","byte_start":29266,"byte_end":29285,"line_start":135,"line_end":135,"column_start":8,"column_end":27},"name":"understand_lifetime","qualname":"::ch02::s2_lifetime::understand_lifetime","value":"pub fn understand_lifetime()","parent":null,"children":[],"decl_id":null,"docs":"    理解普通生命周期参数：","sig":null,"attributes":[{"value":"*\n\n    理解普通生命周期参数：\n\n    说明： 生命周期参数：late bound vs early bound\n\n    示例1: \n\n    ```rust\n    fn return_str<'a>() -> &'a str {\n        let mut s = \"Rust\".to_string();\n        for i in 0..3 {\n            s.push_str(\"Good \");\n        }\n        &s[..]                   //\"Rust Good Good Good\"\n    }\n    fn main() {\n        let x = return_str();\n    }\n\n    ```\n\n    示例2: \n\n    ```rust\n    fn foo<'a>(x: &'a str, y: &'a str) -> &'a str {\n        let result = String::from(\"really long string\");\n        // error\n        result.as_str()\n    }\n\n    fn main() {\n        let x = \"hello\";\n        let y = \"rust\";\n        foo(x, y);\n    }\n    ```\n\n    示例3: \n\n    ```rust\n    fn the_longest(s1: &str, s2: &str) -> &str {\n        if s1.len() > s2.len() { s1 } else { s2 }\n    }\n    fn main() {\n        let s1 = String::from(\"Rust\");\n        let s1_r = &s1;\n        {\n            let s2 = String::from(\"C\");\n            let res = the_longest(s1_r, &s2);\n        println!(\"{} is the longest\", res);\n    }\n    \n    ```\n\n    示例4: \n\n    ```rust\n    fn the_longest<'a>(s1: &'a str, s2: &'a str) -> &'a str {\n        if s1.len() > s2.len() { s1 } else { s2}\n    }\n    fn main() {\n        let s1 = String::from(\"Rust\");\n        let s1_r = &s1;\n        {\n            let s2 = String::from(\"C\");\n            let res = the_longest(s1_r, &s2);\n        println!(\"{} is the longest\", res); // Rust is the longest\n    }\n\n    ```\n*/","span":{"file_name":"src/ch02/s2_lifetime.rs","byte_start":27799,"byte_end":29258,"line_start":63,"line_end":134,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":46},"span":{"file_name":"src/ch02/s2_lifetime.rs","byte_start":30950,"byte_end":30986,"line_start":233,"line_end":233,"column_start":8,"column_end":44},"name":"understand_lifetime_early_late_bound","qualname":"::ch02::s2_lifetime::understand_lifetime_early_late_bound","value":"pub fn understand_lifetime_early_late_bound()","parent":null,"children":[],"decl_id":null,"docs":"说明： 生命周期参数：late bound vs early bound ","sig":null,"attributes":[{"value":"*\n\n说明： 生命周期参数：late bound vs early bound \n\nQuiz 11: [https://dtolnay.github.io/rust-quiz/11](https://dtolnay.github.io/rust-quiz/11)\n\n\n```rust\n\nfn f<'a>() {}\nfn g<'a: 'a>() {}\n\nfn main() {\n    let pf = f::<'static> as fn(); // late bound\n    let pg = g::<'static> as fn(); // early bound\n    print!(\"{}\", pf == pg);\n}\n\n```\n\n\n示例一：late bound lifetime\n\n```rust\nstruct Buffer {\n    buf: Vec<u8>,\n    pos: usize,\n}\n\nimpl Buffer {\n    fn new() -> Buffer {\n        Buffer {\n            buf: vec![1,2,3, 4, 5,6],\n            pos: 0,\n        }\n    }\n\n    fn read_bytes<'a>(&'a mut self) -> &'a [u8] {\n        self.pos += 3;\n        &self.buf[self.pos-3..self.pos]\n    }\n}\n\nfn print(b1 :&[u8], b2: &[u8]) {\n    println!(\"{:#?} {:#?}\", b1, b2)\n}\n\nfn main() {\n    let mut buf = Buffer::new();\n    // let b1 = buf.read_bytes(); // don't work\n    let b1 = &(buf.read_bytes().to_owned());\n    let b2 = buf.read_bytes();\n    print(b1,b2)\n}\n```\n\n示例二： early bound lifetime\n\n```rust\nfn main() {\n    let v = vec![1,2,3, 4, 5,6];\n    let mut buf = Buffer::new(&v);\n    let b1 = buf.read_bytes();\n    // let b1 = &buf.read_bytes().to_owned();\n    let b2 = buf.read_bytes();\n    print(b1,b2)\n}\n\nfn print(b1 :&[u8], b2: &[u8]) {\n    println!(\"{:#?} {:#?}\", b1, b2)\n}\n\nstruct Buffer<'a> {\n    buf: &'a [u8],\n    pos: usize,\n}\n\nimpl<'b, 'a: 'b> Buffer<'a> {\n    fn new(b: &'a [u8]) -> Buffer {\n        Buffer {\n            buf: b,\n            pos: 0,\n        }\n    }\n\n    fn read_bytes(&'b mut self) -> &'a [u8] {\n        self.pos += 3;\n        &self.buf[self.pos-3..self.pos]\n    }\n}\n```\n*/","span":{"file_name":"src/ch02/s2_lifetime.rs","byte_start":29340,"byte_end":30942,"line_start":141,"line_end":232,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":47},"span":{"file_name":"src/ch02/s2_lifetime.rs","byte_start":31824,"byte_end":31855,"line_start":273,"line_end":273,"column_start":8,"column_end":39},"name":"understand_lifetime_for_closure","qualname":"::ch02::s2_lifetime::understand_lifetime_for_closure","value":"pub fn understand_lifetime_for_closure()","parent":null,"children":[],"decl_id":null,"docs":"    ### 闭包 与 高阶生命周期","sig":null,"attributes":[{"value":"*\n\n    ### 闭包 与 高阶生命周期\n\n    ```rust\n\n    fn main() {\n        let f = |x: &i32| x; // error\n        // 假如支持下面的语法就方便多了，目前还未支持\n        // let f: for<'a> Fn(&'a i32) -> &'a i32 = |x| x; \n        let i = &3;\n        let j = f(i);\n    }\n\n    ```\n\n    修正：\n\n    相关：[Explicit lifetime bounds RFC 0192](https://rust-lang.github.io/rfcs/0192-bounds-on-object-and-generic-types.html)\n    ```rust\n\n    // fn annotate<'a, T: 'a ,F>(f: F) -> F where F: Fn(&'a T) -> &'a T { f }\n\n    fn annotate<T,F>(f: F) -> F where for<'a> F: Fn(&'a T) -> &'a T { f }\n\n    fn main() {\n        let f = annotate(|x| x);\n        let i = &3;\n        let j = f(i);\n        assert_eq!(*j, 3);\n    }\n\n    ```\n*/","span":{"file_name":"src/ch02/s2_lifetime.rs","byte_start":31068,"byte_end":31816,"line_start":239,"line_end":272,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":48},"span":{"file_name":"src/ch02/s2_lifetime.rs","byte_start":34122,"byte_end":34157,"line_start":382,"line_end":382,"column_start":8,"column_end":43},"name":"understand_lifetime_in_generic_type","qualname":"::ch02::s2_lifetime::understand_lifetime_in_generic_type","value":"pub fn understand_lifetime_in_generic_type()","parent":null,"children":[],"decl_id":null,"docs":"    ### 理解 T vs &T","sig":null,"attributes":[{"value":"*\n\n    ### 理解 T vs &T\n\n    ```rust\n    use std::fmt::Debug;\n\n    #[derive(Debug)]\n    struct Ref<'a, T: 'a>(&'a T);\n\n    fn print<T>(t: T)\n    where\n        T: Debug,\n    {\n        println!(\"`print`: t is {:?}\", t);\n    }\n\n    fn print_ref<'a, T>(t: &'a T)\n    where\n    T: Debug + 'a,\n    {\n    println!(\"`print_ref`: t is {:?}\", t);\n    }\n\n    fn main() {\n        let x = 7;\n        let ref_x = Ref(&x);\n        print_ref(&ref_x);\n        print(ref_x);\n    }\n    ```\n\n    示例：Rust Quiz 5 ：[https://zhuanlan.zhihu.com/p/51616607](https://zhuanlan.zhihu.com/p/51616607)\n\n    以下代码输出什么？\n\n    ```rust\n    trait Trait {\n        fn f(self);\n    }\n\n    impl<T> Trait for fn(T) {\n        fn f(self) {\n            print!(\"1\");\n        }\n    }\n\n    impl<T> Trait for fn(&T) {\n        fn f(self) {\n            print!(\"2\");\n        }\n    }\n\n    fn main() {\n        let a: fn(_) = |_: u8| {};\n        let b: fn(_) = |_: &u8| {};\n        let c: fn(&_) = |_: &u8| {};\n        a.f();\n        b.f();\n        c.f();\n    }\n    ```\n\n    示例：来自于社区 Potato TooLarge 的案例 \n         \n    [https://zhuanlan.zhihu.com/p/194156624](https://zhuanlan.zhihu.com/p/194156624)\n\n    ```rust\n\n    // https://doc.rust-lang.org/std/collections/struct.HashSet.html\n\n    use std::collections::HashSet;\n\n    fn main() {\n        \n        let hello = \"hello\".to_owned();\n        let mut items = HashSet::new();\n        \n        items.insert(hello.as_str());\n        \n        let mut global_set = HashSet::new();\n        global_set.insert(hello.as_str());\n        \n        while !global_set.is_empty() {\n            let mut temp_set = HashSet::new();\n            \n            for &item in global_set.iter() {\n                let copy = item.to_owned();\n                let copy_str = copy.as_str();\n                \n                // copy_str <==> &copy  ===>  HashSet::get() \n                // &copy_str <==> &'x &'a copy \n\n                if let Some(inner) = items.get(copy_str).cloned() {\n                    temp_set.insert(inner);\n                };\n            };\n            std::mem::swap(&mut global_set, &mut temp_set);\n            break;\n        };\n    }\n    ```\n\n    \n*/","span":{"file_name":"src/ch02/s2_lifetime.rs","byte_start":31920,"byte_end":34114,"line_start":277,"line_end":381,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":49},"span":{"file_name":"src/ch02/s2_lifetime.rs","byte_start":37858,"byte_end":37882,"line_start":535,"line_end":535,"column_start":8,"column_end":32},"name":"understand_lifetime_hrtb","qualname":"::ch02::s2_lifetime::understand_lifetime_hrtb","value":"pub fn understand_lifetime_hrtb()","parent":null,"children":[],"decl_id":null,"docs":"    示例： 理解 trait对象中的生命周期参数","sig":null,"attributes":[{"value":"*\n\n    示例： 理解 trait对象中的生命周期参数\n\n    ```rust\n    trait Foo<'a> {}\n    struct FooImpl<'a> {\n        s: &'a [u32],\n    }\n    impl<'a> Foo<'a> for FooImpl<'a> {\n    }\n    // 为 trait对象 增加 'a ，因为 Box 默认是 static 的，而FooImpl 中的 s 则是引用\n    // 表明该trait对象（结构体实例）与其结构体中的引用的生命周期是一样长的（<=）\n    fn foo<'a>(s: &'a [u32]) -> Box<dyn Foo<'a> + 'a> {\n        Box::new(FooImpl { s: s })\n    }\n    fn main(){}\n    ```\n\n    ###  理解 HRTB (higher ranked trait bounds)\n\n    示例一： \n\n    ```rust\n    use std::fmt::Debug;\n    trait DoSomething<T> {\n        fn do_sth(&self, value: T);\n    }\n    impl<'a, T: Debug> DoSomething<T> for &'a usize {\n        fn do_sth(&self, value: T) {\n            println!(\"{:?}\", value);\n        }\n    }\n    fn foo<'a>(b: Box<DoSomething<&'a usize>>) {\n        let s: usize = 10;\n        b.do_sth(&s) // error[E0597]: `s` does not live long enough\n    }\n    fn main(){\n        let x  = Box::new(&2usize);\n        foo(x);\n    }\n    ```\n\n    修正：使用 `for<'f>` 改为 late bound\n\n    ```rust\n\n    use std::fmt::Debug;\n    trait DoSomething<T> {\n        fn do_sth(&self, value: T);\n    }\n    impl<'a, T: Debug> DoSomething<T> for &'a usize {\n        fn do_sth(&self, value: T) {\n            println!(\"{:?}\", value);\n        }\n    }\n    fn bar(b: Box<for<'f> DoSomething<&'f usize>>) {\n        let s: usize = 10;\n        b.do_sth(&s);\n    }\n    fn main(){\n        let x  = Box::new(&2usize);\n        bar(x);\n    }\n    ```\n\n    示例 2:\n\n    ```rust\n    use rand;\n    use std::io::Read;\n\n    trait Checksum<R: Read> {\n        fn calc(&mut self, r: R) -> Vec<u8>;\n    }\n\n    struct Xor;\n\n    impl<R: Read> Checksum<R> for Xor {\n        fn calc(&mut self, mut r: R) -> Vec<u8> {\n            let mut res: u8 = 0;\n            let mut buf = [0u8; 8];\n            loop {\n                let read = r.read(&mut buf).unwrap();\n                if read == 0 {\n                    break;\n                }\n                for b in &buf[..read] {\n                    res ^= b;\n                }\n            }\n\n            vec![res]\n        }\n    }\n\n    struct Add;\n\n    impl<R: Read> Checksum<R> for Add {\n        fn calc(&mut self, mut r: R) -> Vec<u8> {\n            let mut res: u8 = 0;\n            let mut buf = [0u8; 8];\n            loop {\n                let read = r.read(&mut buf).unwrap();\n                if read == 0 {\n                    break;\n                }\n                for b in &buf[..read] {\n                    let tmp = res as u16 + *b as u16;\n                    res = tmp as u8;\n                }\n            }\n\n            vec![res]\n        }\n    }\n\n    fn main() {\n        let mut buf = [0u8; 8];\n        // error[E0308]: `if` and `else` have incompatible types\n        // 修正：\n        // step 1: Box<dyn Checksum<&[u8]>> 转为 trait 对象\n        // step 2: Box<dyn for<'a> Checksum<&'a [u8]>> 使用 for<'a> 转为 late bound\n        let mut checker = if rand::random() {\n            println!(\"Initializing Xor Checksum\");\n            Box::new(Xor)\n        } else {\n            println!(\"Initializing Add Checksum\");\n            Box::new(Add)\n        };\n\n        let mut data = \"Sedm lumpu slohlo pumpu za uplnku\".as_bytes();\n        let mut i = 0;\n\n        loop {\n            let chunk_size = data.read(&mut buf).unwrap();\n            if chunk_size == 0 {\n                break;\n            }\n            let cs = checker.calc(&buf[..chunk_size]);\n            println!(\"Checksum {} is {:?}\", i, cs);\n            i += 1;\n        }\n    }\n    ```\n\n    \n\n*/","span":{"file_name":"src/ch02/s2_lifetime.rs","byte_start":34219,"byte_end":37850,"line_start":386,"line_end":534,"column_start":1,"column_end":3}}]},{"kind":"Mod","id":{"krate":0,"index":50},"span":{"file_name":"src/ch02/s3_thread_safe.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"s3_thread_safe","qualname":"::ch02::s3_thread_safe","value":"src/ch02/s3_thread_safe.rs","parent":null,"children":[{"krate":0,"index":51},{"krate":0,"index":52},{"krate":0,"index":53},{"krate":0,"index":54}],"decl_id":null,"docs":" 第二章：Rust核心概念\n 2.3 Thread Safe\n","sig":null,"attributes":[{"value":"/ 第二章：Rust核心概念","span":{"file_name":"src/ch02/s3_thread_safe.rs","byte_start":37969,"byte_end":38001,"line_start":1,"line_end":1,"column_start":1,"column_end":17}},{"value":"/ 2.3 Thread Safe","span":{"file_name":"src/ch02/s3_thread_safe.rs","byte_start":38002,"byte_end":38021,"line_start":2,"line_end":2,"column_start":1,"column_end":20}}]},{"kind":"Function","id":{"krate":0,"index":51},"span":{"file_name":"src/ch02/s3_thread_safe.rs","byte_start":39019,"byte_end":39042,"line_start":41,"line_end":41,"column_start":8,"column_end":31},"name":"understand_local_thread","qualname":"::ch02::s3_thread_safe::understand_local_thread","value":"pub fn understand_local_thread()","parent":null,"children":[],"decl_id":null,"docs":"    ### 理解本地线程，理解并发","sig":null,"attributes":[{"value":"*\n    ### 理解本地线程，理解并发\n\n    - 并发：同时「应对」很多事的能力\n    - 并行：同时「执行」很多事的能力\n\n    相关类型：\n\n    - [Duration](https://doc.rust-lang.org/std/time/struct.Duration.html)\n    - [JoinHandle](https://doc.rust-lang.org/std/thread/struct.JoinHandle.html)\n\n    ```\n    use std::thread;\n\n    fn main() {\n        // Duration 实现了 Copy、Send、Sync\n        let duration = std::time::Duration::from_millis(3000);\n\n        println!(\"Main thread\");\n\n        let handle  = thread::spawn(move || {\n            println!(\"Sub thread 1\");\n\n            // 注意：它的父线程是主线程，而不是线程1\n            let handle2 = thread::spawn( move || {\n                println!(\"Sub thread 2\");\n                thread::sleep(duration);\n            });\n\n            handle2.join().unwrap();\n            thread::sleep(duration);\n        });\n\n        handle.join().unwrap();\n        thread::sleep(duration);\n    }\n*/","span":{"file_name":"src/ch02/s3_thread_safe.rs","byte_start":38023,"byte_end":39011,"line_start":4,"line_end":40,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":52},"span":{"file_name":"src/ch02/s3_thread_safe.rs","byte_start":41848,"byte_end":41872,"line_start":173,"line_end":173,"column_start":8,"column_end":32},"name":"understand_shared_thread","qualname":"::ch02::s3_thread_safe::understand_shared_thread","value":"pub fn understand_shared_thread()","parent":null,"children":[],"decl_id":null,"docs":"    ### 线程间共享数据","sig":null,"attributes":[{"value":"*\n    ### 线程间共享数据\n\n    [https://doc.rust-lang.org/std/time/struct.Duration.html](https://doc.rust-lang.org/std/time/struct.Duration.html)\n\n    ```\n    use std::thread;\n\n    fn main() {\n        let mut v = vec![1,2,3];\n        thread::spawn(move || {\n            v.push(4);\n        });\n        // Can no longer access `v` here.\n    }\n    ```\n\n    ```\n    // invalid\n    use std::thread;\n\n    fn main() {\n        let mut v = vec![1,2,3];\n        for i in 0..10 {\n            thread::spawn(move || {\n                v.push(i);\n            });\n        }\n    }\n    ```\n\n    借用检查阻止并发Bug\n\n    ```\n    // invalid \n    fn inner_func(vref: &mut Vec<u32>) {\n        std::thread::spawn(move || {\n        vref.push(3);\n        });\n    }\n\n    fn main() {\n        let mut v = vec![1,2,3];\n        inner_func(&mut v);\n    }\n    ```\n\n    `'static' 与 线程安全\n\n    Note: [曾经的 thread::scoped 会泄漏 JoinGuard 所以被废弃](https://github.com/rust-lang/rust/issues/24292)\n\n    ```\n    use std::fmt;\n    use std::time::Duration;\n    use std::thread;\n\n    struct Foo {\n        string: String,\n        v: Vec<f64>,\n    }\n\n    impl fmt::Display for Foo {\n        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n            write!(f, \"{}: {:?}\", self.string, self.v)\n        }\n    }\n\n    fn test<T: Send + Sync + fmt::Display + 'static >(val: T) {\n        thread::spawn(move || println!(\"{}\", val));\n    }\n\n    fn main() {\n        test(\"hello\");                // &'static str\n        test(String::from(\"hello\"));  // String\n        test(5);                      // i32\n        \n        // Arbitrary struct containing String and Vec<f64>\n        test(Foo {string: String::from(\"hi\"), v: vec![1.2, 2.3]});\n        thread::sleep(Duration::new(1, 0));\n    }\n    ```\n\n    使用 crossbeam::scope 共享数据\n\n    ```rust\n    use crossbeam; \n    use std::{thread, time::Duration};\n\n    fn main() {\n        let mut vec = vec![1, 2, 3, 4, 5];\n\n        crossbeam::scope(|scope| {\n            for e in &vec {\n                scope.spawn(move |_| {\n                    println!(\"{:?}\", e);\n                });\n            }\n        })\n        .expect(\"A child thread panicked\");\n\n        println!(\"{:?}\", vec);\n    }\n    ```\n\n    scope thread 修改数据\n\n    ```rust\n    use crossbeam; // 0.6.0\n    use std::{thread, time::Duration};\n\n    fn main() {\n        let mut vec = vec![1, 2, 3, 4, 5];\n\n        crossbeam::scope(|scope| {\n            for e in &mut vec {\n                scope.spawn(move |_| {\n                    thread::sleep(Duration::from_secs(1));\n                    *e += 1;\n                });\n            }\n        })\n        .expect(\"A child thread panicked\");\n\n        println!(\"{:?}\", vec);\n    }\n    ```\n*/","span":{"file_name":"src/ch02/s3_thread_safe.rs","byte_start":39089,"byte_end":41840,"line_start":46,"line_end":172,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":53},"span":{"file_name":"src/ch02/s3_thread_safe.rs","byte_start":42303,"byte_end":42333,"line_start":196,"line_end":196,"column_start":8,"column_end":38},"name":"understand_safed_shared_thread","qualname":"::ch02::s3_thread_safe::understand_safed_shared_thread","value":"pub fn understand_safed_shared_thread()","parent":null,"children":[],"decl_id":null,"docs":"    ### 使用 Arc 和 Mutex 安全共享数据","sig":null,"attributes":[{"value":"*\n    ### 使用 Arc 和 Mutex 安全共享数据\n\n    ```\n    use std::sync::{Arc, Mutex};\n    use std::thread;\n\n    fn main() {\n        let v = Arc::new(Mutex::new(vec![1,2,3]));\n\n        for i in 0..3 {\n            let cloned_v = v.clone();\n            thread::spawn(move || {\n                cloned_v.lock().unwrap().push(i);\n            });\n        }\n    }\n    ```\n*/","span":{"file_name":"src/ch02/s3_thread_safe.rs","byte_start":41921,"byte_end":42295,"line_start":177,"line_end":195,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":54},"span":{"file_name":"src/ch02/s3_thread_safe.rs","byte_start":86558,"byte_end":86588,"line_start":1241,"line_end":1241,"column_start":8,"column_end":38},"name":"understand_channel_and_condvar","qualname":"::ch02::s3_thread_safe::understand_channel_and_condvar","value":"pub fn understand_channel_and_condvar()","parent":null,"children":[],"decl_id":null,"docs":"    ### 构建「无悔」并发系统","sig":null,"attributes":[{"value":"*\n    ### 构建「无悔」并发系统\n\n    使用 channel 和 condvar ： 模拟并行组件\n\n    - [parking_lot](https://github.com/Amanieu/parking_lot)\n    - [crossbeam](https://github.com/crossbeam-rs/crossbeam)\n\n    > 1. Rust 保证安全性上「无畏」，但不保证工程性上的「无悔」。\n    > 2. 但 Rust 有提供帮助我们建立「无悔」并发的「工具」。\n    > 3. 通过这些工具，结合从实际沉淀出来并发模型的最佳默认模式「event-loop」来建立健壮的并发应用。\n    > 4. 拓展阅读：\n    > [Rust concurrency patterns: regret-less concurrency](https://medium.com/@polyglot_factotum/rust-regret-less-concurrency-2238b9e53333)\n\n\n    示例1: 用 channel 模拟 event \n\n    ```text\n\n                    \n                                    +--------------+\n                                    | main thread  |      send work msg\n    +-----------------------------> |    主 组 件     |  +-------------+\n    |           receive result msg  |              |                  |\n    |                               +--------------+                  work1\n    |                                                                 |\n    |                       send result msg                           |\n    |              +-----------------------+                          work1\n    |              |                       |                          |\n    |              v                       |                          v\n    |        result channel                |                      work channel\n    |            +---+                     |                         +---+\n    |            |   |                     |                         |   |\n    |            +---+                     |                         +---+\n    |            |   |                     |                         |   |\n    |            +---+                 +---+----+                    +---+\n    |            |   |                 | worker |                    |   |\n    |            +---+                 | thread |                    +---+\n    |            |   |                 |   并    |                   |   |\n    |            +---+                 |   行    |                   +---+\n    |            |   |                 |   组    |                   |   |\n    |            +---+                 |   件    |                   +---+\n    |            |   |                 +----+---+                    |   |\n    |            +-+-+                      ^                        +-+-+\n    |              |                        |receive work msg          |\n    |              |                        |                          |\n    +--------------+                        +--------------------------+\n\n    ```\n\n    代码\n\n    ```\n    #[macro_use]\n    extern crate crossbeam_channel;\n    extern crate rayon;\n\n    use crossbeam_channel::unbounded;\n    use std::collections::HashMap;\n    use std::sync::{Arc, Condvar, Mutex};\n    // use parking_lot::{Mutex, Condvar};\n    // use std::sync::Arc;\n    use std::thread;\n\n    // 此消息用于发送到与「主组件」并行运行的其他组件。\n    enum WorkMsg {\n        Work(u8),\n        Exit,\n    }\n\n    // 此消息用于从并行运行的其他组件 发送回「主组件」。\n    enum ResultMsg {\n        Result(u8),\n        Exited,\n    }\n\n    fn main() {\n        let (work_sender, work_receiver) = unbounded();\n        let (result_sender, result_receiver) = unbounded();\n\n        // 生成子线程用于执行另一个并行组件\n        let _ = thread::spawn(move || loop {\n            // 接收并处理消息，直到收到 exit 消息\n            match work_receiver.recv() {\n                Ok(WorkMsg::Work(num)) => {\n                    // 执行一些工作，并且发送消息给 Result 队列\n                    let _ = result_sender.send(ResultMsg::Result(num));\n                }\n                Ok(WorkMsg::Exit) => {\n                    // 发送 exit 确认消息\n                    let _ = result_sender.send(ResultMsg::Exited);\n                    break;\n                }\n                _ => panic!(\"Error receiving a WorkMsg.\"),\n            }\n        });\n\n        let _ = work_sender.send(WorkMsg::Work(0));\n        let _ = work_sender.send(WorkMsg::Work(1));\n        let _ = work_sender.send(WorkMsg::Exit);\n\n        // worker执行计数\n        let mut counter = 0;\n\n        loop {\n            match result_receiver.recv() {\n                Ok(ResultMsg::Result(num)) => {\n                    // 断言确保接收和发送的顺序是一致的\n                    assert_eq!(num, counter);\n                    counter += 1;\n                }\n                Ok(ResultMsg::Exited) => {\n                    // 断言确保在接收两条工作消息之后收到退出消息\n                    assert_eq!(2, counter);\n                    break;\n                }\n                _ => panic!(\"Error receiving a ResultMsg.\"),\n            }\n        }\n    }\n    ```\n\n    示例二：引入线程池，工作的顺序将无法确定\n\n    ```text\n                                    +--------------+\n                                    | main thread  |      send work msg\n    +-----------------------------> |    主 组 件   |  +---------------+\n    |           receive result msg  |              |                  |\n    |                               +--------------+                  work1\n    |                                                                 |\n    |                       send result msg                           |\n    |              +-----------------------+                          work0\n    |              |                       |                          |\n    |              v                       |                          v\n    |        result channel       +--------+------+               work channel\n    |            +---+            |               |                  +---+\n    |            |   |            |               |                  |   |\n    |            +---+       +----+---+      +----+----+             +---+\n    |            |   |       | worker |      |  worker |             |   |\n    |            +---+       | thread |thread|  thread |             +---+\n    |            |   |       |   并    | pool|    并    |             |   |\n    |            +---+       |   行    |     |    行    |             +---+\n    |            |   |       |   组    |     |    组    |             |   |\n    |            +---+       |   件    |     |    件    |             +---+\n    |            |   |       +----+---+      +-----+---+             |   |\n    |            +---+            ^                ^                 +---+\n    |            |   |            |                |                 |   |\n    |            +-+-+            +receive-work-msg+                 +-+-+\n    |              |                        |                          |\n    |              |                        |                          |\n    +--------------+                        +--------------------------+\n\n    ```\n\n    代码：\n\n    ```rust\n    #[macro_use]\n    extern crate crossbeam_channel;\n    extern crate rayon;\n\n    use crossbeam_channel::unbounded;\n    use std::collections::HashMap;\n    // use std::sync::{Arc, Condvar, Mutex};\n\n    use parking_lot::{Condvar, Mutex};\n    use std::sync::Arc;\n    use std::thread;\n\n    enum WorkMsg {\n        Work(u8),\n        Exit,\n    }\n\n    enum ResultMsg {\n        Result(u8),\n        Exited,\n    }\n\n    fn main() {\n        let (work_sender, work_receiver) = unbounded();\n        let (result_sender, result_receiver) = unbounded();\n        // 引入线程池，开两个工作线程\n        let pool = rayon::ThreadPoolBuilder::new()\n            .num_threads(2)\n            .build()\n            .unwrap();\n\n        let _ = thread::spawn(move || loop {\n            match work_receiver.recv() {\n                Ok(WorkMsg::Work(num)) => {\n                    let result_sender = result_sender.clone();\n                    // 使用线程池中的线程\n                    pool.spawn(move || {\n                        // 执行一些工作，并且发送消息给 Result 队列\n                        let _ = result_sender.send(ResultMsg::Result(num));\n                    });\n                }\n                Ok(WorkMsg::Exit) => {\n                    let _ = result_sender.send(ResultMsg::Exited);\n                    break;\n                }\n                _ => panic!(\"Error receiving a WorkMsg.\"),\n            }\n        });\n\n        let _ = work_sender.send(WorkMsg::Work(0));\n        let _ = work_sender.send(WorkMsg::Work(1));\n        let _ = work_sender.send(WorkMsg::Exit);\n\n        loop {\n            match result_receiver.recv() {\n                Ok(ResultMsg::Result(_)) => {\n                    // 不能再断言顺序了\n                }\n                Ok(ResultMsg::Exited) => {\n                    // 也不能断言在退出消息之前已经收到了结果\n                    break;\n                }\n                _ => panic!(\"Error receiving a ResultMsg.\"),\n            }\n        }\n    }\n    ```\n\n    示例3: 确保工作结束再退出\n\n    ```text\n\n                                        +--------------+\n                                        | main thread  |      send work msg\n        +-----------------------------> |    主 组 件   |  +--------------------------+\n        |           receive result msg  |              |                             +\n        |                               +--------------+                             work1\n        |                                                                            |\n        |                       send result msg                                      |\n        |              +-----------------------+                                     work0\n        |              |                       |                                     |\n        |              v                       |                                     v\n        |        result channel       +--------+-------------------------+       work channel\n        |            +---+            |              thread              |          +---+\n        |            |   |            |               pool               |          |   |\n        |            +---+       +----+---+                         +----+----+     +---+\n        |            |   |       | worker |                         |  worker |     |   |\n        |            +---+       | thread |     pool_res_channel    |  thread |     +---+\n        |            |   |       |   并   +-------------------------+    并    |     |   |\n        |            +---+       |   行    send msg when job finished     行   |     +---+\n        |            |   |       |   组   +-------------------------+    组    |     |   |\n        |            +---+       |   件   |                         |    件    |     +---+\n        |            |   |       +----+---+                         +-----+---+     |   |\n        |            +---+            ^                                   ^         +---+\n        |            |   |            |                                   |         |   |\n        |            +-+-+            +receive-work-msg+------------------+         +-+-+\n        |              |                        |                                     |\n        |              |                        |                                     |\n        +--------------+                        +-------------------------------------+\n\n\n\n    ```\n\n    代码：\n\n    ```rust\n    #[macro_use]\n    extern crate crossbeam_channel;\n    extern crate rayon;\n\n    use crossbeam_channel::unbounded;\n    use std::collections::HashMap;\n    // use std::sync::{Arc, Condvar, Mutex};\n\n    use parking_lot::{Condvar, Mutex};\n    use std::sync::Arc;\n    use std::thread;\n\n    enum WorkMsg {\n        Work(u8),\n        Exit,\n    }\n\n    enum ResultMsg {\n        Result(u8),\n        Exited,\n    }\n\n    fn main() {\n        let (work_sender, work_receiver) = unbounded();\n        let (result_sender, result_receiver) = unbounded();\n        // 添加一个新的Channel，Worker使用它来通知“并行”组件已经完成了一个工作单元\n        let (pool_result_sender, pool_result_receiver) = unbounded();\n        let mut ongoing_work = 0;\n        let mut exiting = false;\n        // 使用线程池\n        let pool = rayon::ThreadPoolBuilder::new()\n            .num_threads(2)\n            .build()\n            .unwrap();\n\n        let _ = thread::spawn(move || loop {\n            // 使用 corssbeam 提供的 select! 宏 选择一个就绪工作\n            select! {\n                recv(work_receiver) -> msg => {\n                    match msg {\n                        Ok(WorkMsg::Work(num)) => {\n                            let result_sender = result_sender.clone();\n                            let pool_result_sender = pool_result_sender.clone();\n\n                            // 注意，这里正在池上启动一个新的工作单元。\n                            ongoing_work += 1;\n\n                            pool.spawn(move || {\n                                // 1. 发送结果给「主组件」\n                                let _ = result_sender.send(ResultMsg::Result(num));\n\n                                // 2. 让并行组件知道这里完成了一个工作单元\n                                let _ = pool_result_sender.send(());\n                            });\n                        },\n                        Ok(WorkMsg::Exit) => {\n                            // N注意，这里接收请求并退出\n                            exiting = true;\n\n                            // 如果没有正则进行的工作则立即退出\n                            if ongoing_work == 0 {\n                                let _ = result_sender.send(ResultMsg::Exited);\n                                break;\n                            }\n                        },\n                        _ => panic!(\"Error receiving a WorkMsg.\"),\n                    }\n                },\n                recv(pool_result_receiver) -> _ => {\n                    if ongoing_work == 0 {\n                        panic!(\"Received an unexpected pool result.\");\n                    }\n\n                    // 注意，一个工作单元已经被完成\n                    ongoing_work -=1;\n\n                    // 如果没有正在进行的工作，并且接收到了退出请求，那么就退出\n                    if ongoing_work == 0 && exiting {\n                        let _ = result_sender.send(ResultMsg::Exited);\n                        break;\n                    }\n                },\n            }\n        });\n\n        let _ = work_sender.send(WorkMsg::Work(0));\n        let _ = work_sender.send(WorkMsg::Work(1));\n        let _ = work_sender.send(WorkMsg::Exit);\n\n        let mut counter = 0;\n\n        loop {\n            match result_receiver.recv() {\n                Ok(ResultMsg::Result(_)) => {\n                    // 计数当前完成的工作单元\n                    counter += 1;\n                }\n                Ok(ResultMsg::Exited) => {\n                    // 断言检测：是在接收到两个请求以后退出的\n                    assert_eq!(2, counter);\n                    break;\n                }\n                _ => panic!(\"Error receiving a ResultMsg.\"),\n            }\n        }\n    }\n    ```\n\n    示例3 重构\n\n    ```rust\n    #[macro_use]\n    extern crate crossbeam_channel;\n    extern crate rayon;\n\n    use crossbeam_channel::unbounded;\n    use std::collections::HashMap;\n    // use std::sync::{Arc, Condvar, Mutex};\n\n    use parking_lot::{Condvar, Mutex};\n    use std::sync::Arc;\n    use std::thread;\n\n    enum WorkMsg {\n        Work(u8),\n        Exit,\n    }\n\n    enum ResultMsg {\n        Result(u8),\n        Exited,\n    }\n\n    struct WorkerState {\n        ongoing: i16,\n        exiting: bool,\n    }\n\n    impl WorkerState {\n        fn init() -> Self {\n            WorkerState{ ongoing: 0, exiting: false }\n        }\n        \n        fn set_ongoing(&mut self, count: i16) {\n            self.ongoing += count;\n        }\n        \n        fn set_exiting(&mut self, exit_state: bool) {\n            self.exiting = exit_state;\n        }\n        \n        fn is_exiting(&self) -> bool {\n            self.exiting == true\n        }\n        \n        fn is_nomore_work(&self)-> bool {\n            self.ongoing == 0\n        }\n        \n    }\n\n    fn main() {\n        let (work_sender, work_receiver) = unbounded();\n        let (result_sender, result_receiver) = unbounded();\n        // 添加一个新的Channel，Worker使用它来通知“并行”组件已经完成了一个工作单元\n        let (pool_result_sender, pool_result_receiver) = unbounded();\n        let mut worker_state = WorkerState::init();\n        \n        // 使用线程池\n        let pool = rayon::ThreadPoolBuilder::new()\n            .num_threads(2)\n            .build()\n            .unwrap();\n\n        let _ = thread::spawn(move || loop {\n            // 使用 corssbeam 提供的 select! 宏 选择一个就绪工作\n            select! {\n                recv(work_receiver) -> msg => {\n                    match msg {\n                        Ok(WorkMsg::Work(num)) => {\n                            let result_sender = result_sender.clone();\n                            let pool_result_sender = pool_result_sender.clone();\n\n                            // 注意，这里正在池上启动一个新的工作单元。\n                            worker_state.set_ongoing(1);\n\n                            pool.spawn(move || {\n                                // 1. 发送结果给「主组件」\n                                result_sender.send(ResultMsg::Result(num));\n\n                                // 2. 让并行组件知道这里完成了一个工作单元\n                                pool_result_sender.send(());\n                            });\n                        },\n                        Ok(WorkMsg::Exit) => {\n                            // N注意，这里接收请求并退出\n                            // exiting = true;\n                            worker_state.set_exiting(true);\n\n                            // 如果没有正则进行的工作则立即退出\n                            if worker_state.is_nomore_work() {\n                                result_sender.send(ResultMsg::Exited);\n                                break;\n                            }\n                        },\n                        _ => panic!(\"Error receiving a WorkMsg.\"),\n                    }\n                },\n                recv(pool_result_receiver) -> _ => {\n                    if worker_state.is_nomore_work() {\n                        panic!(\"Received an unexpected pool result.\");\n                    }\n\n                    // 注意，一个工作单元已经被完成\n                    worker_state.set_ongoing(-1);\n\n                    // 如果没有正在进行的工作，并且接收到了退出请求，那么就退出\n                    if worker_state.is_nomore_work() && worker_state.is_exiting() {\n                        result_sender.send(ResultMsg::Exited);\n                        break;\n                    }\n                },\n            }\n        });\n\n        work_sender.send(WorkMsg::Work(0));\n        work_sender.send(WorkMsg::Work(1));\n        work_sender.send(WorkMsg::Exit);\n\n        let mut counter = 0;\n\n        loop {\n            match result_receiver.recv() {\n                Ok(ResultMsg::Result(_)) => {\n                    // 计数当前完成的工作单元\n                    counter += 1;\n                }\n                Ok(ResultMsg::Exited) => {\n                    // 断言检测：是在接收到两个请求以后退出的\n                    assert_eq!(2, counter);\n                    break;\n                }\n                _ => panic!(\"Error receiving a ResultMsg.\"),\n            }\n        }\n    }\n    ```\n\n    示例4: 使用缓存共享数据\n\n    ```text\n                                        +--------------+\n                                        | main thread  |      send work msg\n        +-----------------------------> |    主 组 件   |  +--------------------------+\n        |           receive result msg  |              |                             +\n        |                               +--------------+                             work1\n        |                                                                            |\n        |                       send result msg                                      |\n        |              +------------------------+                                    work0\n        |              |                        |                                    +\n        |              v                        |                                    |\n        |        result channel                 |                                    |\n        |            +---+            +---------+------------------------+           |\n        |            |   |            |              thread              |           |\n        |            +---+            |               pool               |           |\n        |            |   |       +----+---+                         +----+----+      |\n        |            +---+       | worker |                         |  worker |      |\n        |            |   |       | thread |                         |  thread |      |\n        |            +---+       |        |                         |         |      |\n        |            |   |       |        |                         |         |      +\n        |            +---+       |        |                         |         |  work channel\n        |            |   |       |        |get +--------------+  get|         |     +---+\n        |            +---+       |        +--->+  work cache  +<----+         |     |   |\n        |            |   |       |        |    +--------------+     |         |     +---+\n        |            +-+-+       |        |                         |         |     |   |\n        |              |         |        |     pool_res_channel    |         |     +---+\n        |              |         |   并    +-------------------------+    并   |     |   |\n        +--------------+         |   行    send msg when job finished     行   |     +---+\n                                 |   组    +-------------------------+    组    |    |   |\n                                 |   件    |                         |    件    |    +---+\n                                 +----+---+                         +-----+---+     |   |\n                                      ^                                   ^         +---+\n                                      |                                   |         |   |\n                                      +receive-work-msg+------------------+         +-+-+\n                                                |                                     |\n                                                |                                     |\n                                                +-------------------------------------+\n\n\n    ```\n\n    代码：\n\n    ```rust\n    #[macro_use]\n    extern crate crossbeam_channel;\n    extern crate rayon;\n\n    use crossbeam_channel::unbounded;\n    use std::collections::HashMap;\n    use std::sync::{Arc, Condvar, Mutex};\n\n    // use parking_lot::{Condvar, Mutex};\n    // use std::sync::Arc;\n    use std::thread;\n\n    enum WorkMsg {\n        Work(u8),\n        Exit,\n    }\n\n    enum ResultMsg {\n        Result(u8, WorkPerformed),\n        Exited,\n    }\n\n    struct WorkerState {\n        ongoing: i16,\n        exiting: bool,\n    }\n\n    impl WorkerState {\n        fn init() -> Self {\n            WorkerState{ ongoing: 0, exiting: false }\n        }\n        \n        fn set_ongoing(&mut self, count: i16) {\n            self.ongoing += count;\n        }\n        \n        fn set_exiting(&mut self, exit_state: bool) {\n            self.exiting = exit_state;\n        }\n        \n        fn is_exiting(&self) -> bool {\n            self.exiting == true\n        }\n        \n        fn is_nomore_work(&self)-> bool {\n            self.ongoing == 0\n        }\n    }\n\n    #[derive(Debug, Eq, PartialEq)]\n    enum WorkPerformed {\n        FromCache,\n        New,\n    }\n\n    #[derive(Eq, Hash, PartialEq)]\n    struct CacheKey(u8);\n\n    fn main() {\n        let (work_sender, work_receiver) = unbounded();\n        let (result_sender, result_receiver) = unbounded();\n        // 添加一个新的Channel，Worker使用它来通知“并行”组件已经完成了一个工作单元\n        let (pool_result_sender, pool_result_receiver) = unbounded();\n        let mut worker_state = WorkerState::init();\n        \n        // 使用线程池\n        let pool = rayon::ThreadPoolBuilder::new()\n            .num_threads(2)\n            .build()\n            .unwrap();\n            \n        // 缓存 work ，由 池 中的 worker 共享\n        let cache: Arc<Mutex<HashMap<CacheKey, u8>>> = Arc::new(Mutex::new(HashMap::new()));\n\n        let _ = thread::spawn(move || loop {\n            // 使用 corssbeam 提供的 select! 宏 选择一个就绪工作\n            select! {\n                recv(work_receiver) -> msg => {\n                    match msg {\n                        Ok(WorkMsg::Work(num)) => {\n                            let result_sender = result_sender.clone();\n                            let pool_result_sender = pool_result_sender.clone();\n                            // 使用缓存\n                            let cache = cache.clone();\n\n                            // 注意，这里正在池上启动一个新的工作单元。\n                            worker_state.set_ongoing(1);\n\n                            pool.spawn(move || {\n                                let num = {\n                                    // 缓存开始\n                                    let cache = cache.lock().unwrap();\n                                    let key = CacheKey(num);\n                                    if let Some(result) = cache.get(&key) {\n                                        // 从缓存中获得一个结果，并将其发送回去，\n                                        // 同时带有一个标志，表明是从缓存中获得了它\n                                        let _ = result_sender.send(ResultMsg::Result(result.clone(), WorkPerformed::FromCache));\n                                        let _ = pool_result_sender.send(());\n                                        return;\n                                    }\n                                    key.0\n                                    // 缓存结束\n                                };\n\n                                // work work work work work work...\n\n                                // 返回结果，表明我们必须执行work\n                                let _ = result_sender.send(ResultMsg::Result(num.clone(), WorkPerformed::New));\n\n                                // 在缓存中存储“昂贵”的work.\n                                let mut cache = cache.lock().unwrap();\n                                let key = CacheKey(num.clone());\n                                cache.insert(key, num);\n\n                                let _ = pool_result_sender.send(());\n                            });\n                        },\n                        Ok(WorkMsg::Exit) => {\n                            // N注意，这里接收请求并退出\n                            // exiting = true;\n                            worker_state.set_exiting(true);\n\n                            // 如果没有正则进行的工作则立即退出\n                            if worker_state.is_nomore_work() {\n                                result_sender.send(ResultMsg::Exited);\n                                break;\n                            }\n                        },\n                        _ => panic!(\"Error receiving a WorkMsg.\"),\n                    }\n                },\n                recv(pool_result_receiver) -> _ => {\n                    if worker_state.is_nomore_work() {\n                        panic!(\"Received an unexpected pool result.\");\n                    }\n\n                    // 注意，一个工作单元已经被完成\n                    worker_state.set_ongoing(-1);\n\n                    // 如果没有正在进行的工作，并且接收到了退出请求，那么就退出\n                    if worker_state.is_nomore_work() && worker_state.is_exiting() {\n                        result_sender.send(ResultMsg::Exited);\n                        break;\n                    }\n                },\n            }\n        });\n\n        let _ = work_sender.send(WorkMsg::Work(0));\n        // 发送两个相同的work\n        let _ = work_sender.send(WorkMsg::Work(1));\n        let _ = work_sender.send(WorkMsg::Work(1));\n        let _ = work_sender.send(WorkMsg::Exit);\n\n        let mut counter = 0;\n\n        loop {\n            match result_receiver.recv() {\n                Ok(ResultMsg::Result(_, _cached)) => {\n                    // 计数当前完成的工作单元\n                    counter += 1;\n                }\n                Ok(ResultMsg::Exited) => {\n                    // 断言检测：是在接收到两个请求以后退出的\n                    assert_eq!(3, counter);\n                    break;\n                }\n                _ => panic!(\"Error receiving a ResultMsg.\"),\n            }\n        }\n    }\n    ```\n\n    示例5: 确保从缓存中取共享数据的行为是确定的\n\n    ```text\n                                        +--------------+\n                                        | main thread  |      send work msg\n        +-----------------------------> |    主 组 件   |  +----------------------------------+\n        |           receive result msg  |              |                                     +\n        |                               +--------------+                                     work1\n        |                                                                                    |\n        |                       send result msg                                              |\n        |              +------------------------+                                            work0\n        |              |                        |                                            +\n        |              v                        |          thread                            |\n        |        result channel                 |           pool                             |\n        |            +---+            |---------+--------------------------------|           |\n        |            |   |       +--------+   wait    +------------+  wait  +---------+      |\n        |            +---+       | worker +<----------+  inproces  +------->+  worker |      |\n        |            |   |       | thread |       +----            ---+     |  thread |      |\n        |            +---+       |        |  +--->+ work cache state  +<--+ |         |      |\n        |            |   |       |        |  |    +-----+        +----+   | |         |      |\n        |            +---+       |        +--+          |  ready |        +-+         |      |\n        |            |   |       |        |      notify +----+---++  notify |         |      +\n        |            +---+       |        | <-----------+    |    +-------->+         |  work channel\n        |            |   |       |        |                  v              |         |     +---+\n        |            +---+       |        |         +--------+-----+        |         |     |   |\n        |            |   |       |        |         |  work cache  |        |         |     +---+\n        |            +-+-+       |        |         +--------------+        |         |     |   |\n        |              |         |        |     pool_res_channel            |         |     +---+\n        |              |         |   并    +---------------------------------+    并   |     |   |\n        +--------------+         |   行        send msg when job finished         行   |     +---+\n                                 |   组    +---------------------------------+    组   |     |   |\n                                 |   件    |                                 |    件   |     +---+\n                                 +----+---+                                  +-----+---+    |   |\n                                      ^                                           ^         +---+\n                                      |                                           |         |   |\n                                      +receive-work-msg+--------------------------+         +-+-+\n                                                |                                             |\n                                                |                                             |\n                                                +---------------------------------------------+\n\n    ```\n\n    代码：\n\n    ```\n    #[macro_use]\n    extern crate crossbeam_channel;\n    extern crate rayon;\n\n    use crossbeam_channel::unbounded;\n    use std::collections::HashMap;\n    use std::sync::{Arc, Condvar, Mutex};\n\n    // use parking_lot::{Condvar, Mutex};\n    // use std::sync::Arc;\n    use std::thread;\n\n    enum WorkMsg {\n        Work(u8),\n        Exit,\n    }\n\n    #[derive(Debug, Eq, PartialEq)]\n    enum CacheState {\n        Ready,\n        WorkInProgress,\n    }\n\n    enum ResultMsg {\n        Result(u8, WorkPerformed),\n        Exited,\n    }\n\n    struct WorkerState {\n        ongoing: i16,\n        exiting: bool,\n    }\n\n    impl WorkerState {\n        fn init() -> Self {\n            WorkerState{ ongoing: 0, exiting: false }\n        }\n            \n        fn set_ongoing(&mut self, count: i16) {\n            self.ongoing += count;\n        }\n            \n        fn set_exiting(&mut self, exit_state: bool) {\n            self.exiting = exit_state;\n        }\n            \n        fn is_exiting(&self) -> bool {\n            self.exiting == true\n        }\n            \n        fn is_nomore_work(&self)-> bool {\n            self.ongoing == 0\n        }\n    }\n\n    #[derive(Debug, Eq, PartialEq)]\n    enum WorkPerformed {\n        FromCache,\n        New,\n    }\n\n    #[derive(Eq, Hash, PartialEq)]\n    struct CacheKey(u8);\n\n    fn main() {\n        let (work_sender, work_receiver) = unbounded();\n        let (result_sender, result_receiver) = unbounded();\n        // 添加一个新的Channel，Worker使用它来通知“并行”组件已经完成了一个工作单元\n        let (pool_result_sender, pool_result_receiver) = unbounded();\n        let mut worker_state = WorkerState::init();\n            \n        // 使用线程池\n        let pool = rayon::ThreadPoolBuilder::new()\n            .num_threads(2)\n            .build()\n            .unwrap();\n                \n        // 缓存 work ，由 池 中的 worker 共享\n        let cache: Arc<Mutex<HashMap<CacheKey, u8>>> = Arc::new(Mutex::new(HashMap::new()));\n\n        // 增加缓存状态，指示对于给定的key，缓存是否已经准备好被读取。\n        let cache_state: Arc<Mutex<HashMap<CacheKey, Arc<(Mutex<CacheState>, Condvar)>>>> =\n            Arc::new(Mutex::new(HashMap::new()));\n            \n        let _ = thread::spawn(move || loop {\n            // 使用 corssbeam 提供的 select! 宏 选择一个就绪工作\n            select! {\n                recv(work_receiver) -> msg => {\n                    match msg {\n                        Ok(WorkMsg::Work(num)) => {\n                            let result_sender = result_sender.clone();\n                            let pool_result_sender = pool_result_sender.clone();\n                            // 使用缓存\n                            let cache = cache.clone();\n                            let cache_state = cache_state.clone();\n\n                            // 注意，这里正在池上启动一个新的工作单元。\n                            worker_state.set_ongoing(1);\n\n                            pool.spawn(move || {\n                                let num = {\n                                    let (cache_state_lock, cvar) = {\n                                        //  `cache_state` 临界区开始\n                                        let mut state_map = cache_state.lock().unwrap();\n                                        &*state_map\n                                            .entry(CacheKey(num.clone()))\n                                            .or_insert_with(|| {\n                                                Arc::new((\n                                                    Mutex::new(CacheState::Ready),\n                                                    Condvar::new(),\n                                                ))\n                                            })\n                                            .clone()\n                                        //  `cache_state` 临界区结束\n                                    };\n\n                                    //  `state` 临界区开始\n                                    let mut state = cache_state_lock.lock().unwrap();\n\n                                    // 注意：使用while循环来防止条件变量的虚假唤醒\n                                    while let CacheState::WorkInProgress = *state {\n                                        // 阻塞直到状态是 `CacheState::Ready`.\n                                        //\n                                        // 当唤醒时会自动释放锁\n                                        let current_state = cvar\n                                            .wait(state)\n                                            .unwrap();\n                                        state = current_state;\n                                    }\n\n                                    // 循环外可以认为state 已经是 Ready 的了\n                                    assert_eq!(*state, CacheState::Ready);\n\n                                    let (num, result) = {\n                                        // 缓存临界区开始\n                                        let cache = cache.lock().unwrap();\n                                        let key = CacheKey(num);\n                                        let result = match cache.get(&key) {\n                                            Some(result) => Some(result.clone()),\n                                            None => None,\n                                        };\n                                        (key.0, result)\n                                        // 缓存临界区结束\n                                    };\n\n                                    if let Some(result) = result {\n                                        // 从缓存中获得一个结果，并将其发送回去，\n                                        // 同时带有一个标志，表明是从缓存中获得了它\n                                        let _ = result_sender.send(ResultMsg::Result(result, WorkPerformed::FromCache));\n                                        let _ = pool_result_sender.send(());\n\n                                        // 不要忘记通知等待线程\n                                        cvar.notify_one();\n                                        return;\n                                    } else {\n                                        // 如果缓存里没有找到结果，那么切换状态\n                                        *state = CacheState::WorkInProgress;\n                                        num\n                                    }\n                                    // `state` 临界区结束\n                                };\n\n                                // 在临界区外做更多「昂贵工作」\n\n                                let _ = result_sender.send(ResultMsg::Result(num.clone(), WorkPerformed::New));\n\n                                {\n                                    // 缓存临界区开始\n                                    // 插入工作结果到缓存中\n                                    let mut cache = cache.lock().unwrap();\n                                    let key = CacheKey(num.clone());\n                                    cache.insert(key, num);\n                                    // 缓存临界区结束\n                                }\n\n                                let (lock, cvar) = {\n                                    let mut state_map = cache_state.lock().unwrap();\n                                    &*state_map\n                                        .get_mut(&CacheKey(num))\n                                        .expect(\"Entry in cache state to have been previously inserted\")\n                                        .clone()\n                                };\n                                // 重新进入 `state` 临界区\n                                let mut state = lock.lock().unwrap();\n\n                                // 在这里，由于已经提前设置了state，并且任何其他worker都将等待状态切换回ready，可以确定该状态是“in-progress”。\n                                assert_eq!(*state, CacheState::WorkInProgress);\n\n                                // 切换状态为 Ready\n                                *state = CacheState::Ready;\n\n                                // 通知等待线程\n                                cvar.notify_one();\n\n                                let _ = pool_result_sender.send(());\n                            });\n                        },\n                        Ok(WorkMsg::Exit) => {\n                            // N注意，这里接收请求并退出\n                            // exiting = true;\n                            worker_state.set_exiting(true);\n\n                            // 如果没有正则进行的工作则立即退出\n                            if worker_state.is_nomore_work() {\n                                result_sender.send(ResultMsg::Exited);\n                                break;\n                            }\n                        },\n                        _ => panic!(\"Error receiving a WorkMsg.\"),\n                    }\n                },\n                recv(pool_result_receiver) -> _ => {\n                    if worker_state.is_nomore_work() {\n                        panic!(\"Received an unexpected pool result.\");\n                    }\n\n                    // 注意，一个工作单元已经被完成\n                    worker_state.set_ongoing(-1);\n\n                    // 如果没有正在进行的工作，并且接收到了退出请求，那么就退出\n                    if worker_state.is_nomore_work() && worker_state.is_exiting() {\n                        result_sender.send(ResultMsg::Exited);\n                        break;\n                    }\n                },\n            }\n        });\n\n        let _ = work_sender.send(WorkMsg::Work(0));\n        // 发送两个相同的work\n        let _ = work_sender.send(WorkMsg::Work(1));\n        let _ = work_sender.send(WorkMsg::Work(1));\n        let _ = work_sender.send(WorkMsg::Exit);\n\n        let mut counter = 0;\n        \n        // 当work 是 1 的时候重新计数\n        let mut work_one_counter = 0;\n\n        loop {\n            match result_receiver.recv() {\n                Ok(ResultMsg::Result(num, cached)) => {\n                    counter += 1;\n\n                    if num == 1 {\n                        work_one_counter += 1;\n                    }\n\n                    // 现在我们可以断言，当收到 num 为 1 的第二个结果时，它已经来自缓存。\n                    if num == 1 && work_one_counter == 2 {\n                        assert_eq!(cached, WorkPerformed::FromCache);\n                    }\n                }\n                Ok(ResultMsg::Exited) => {\n                    assert_eq!(3, counter);\n                    break;\n                }\n                _ => panic!(\"Error receiving a ResultMsg.\"),\n            }\n        }\n    }\n    ```\n*/","span":{"file_name":"src/ch02/s3_thread_safe.rs","byte_start":42389,"byte_end":86550,"line_start":201,"line_end":1240,"column_start":1,"column_end":3}}]},{"kind":"Mod","id":{"krate":0,"index":55},"span":{"file_name":"src/ch02/s4_lockfree.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"s4_lockfree","qualname":"::ch02::s4_lockfree","value":"src/ch02/s4_lockfree.rs","parent":null,"children":[{"krate":0,"index":56}],"decl_id":null,"docs":" 第二章：Rust核心概念\n 2.3 Lockfree\n \n","sig":null,"attributes":[{"value":"/ 第二章：Rust核心概念","span":{"file_name":"src/ch02/s4_lockfree.rs","byte_start":86645,"byte_end":86677,"line_start":1,"line_end":1,"column_start":1,"column_end":17}},{"value":"/ 2.3 Lockfree","span":{"file_name":"src/ch02/s4_lockfree.rs","byte_start":86678,"byte_end":86694,"line_start":2,"line_end":2,"column_start":1,"column_end":17}},{"value":"/ ","span":{"file_name":"src/ch02/s4_lockfree.rs","byte_start":86695,"byte_end":86699,"line_start":3,"line_end":3,"column_start":1,"column_end":5}}]},{"kind":"Function","id":{"krate":0,"index":56},"span":{"file_name":"src/ch02/s4_lockfree.rs","byte_start":98551,"byte_end":98568,"line_start":279,"line_end":279,"column_start":8,"column_end":25},"name":"memory_reordering","qualname":"::ch02::s4_lockfree::memory_reordering","value":"pub fn memory_reordering()","parent":null,"children":[],"decl_id":null,"docs":"    ### 并发编程注重的三点：","sig":null,"attributes":[{"value":"*\n \n    ### 并发编程注重的三点：\n\n    1. 原子性。保证操作是原子的。\n    2. 可见性。保证数据是同步的。\n    3. 顺序性。保证操作的顺序是正确的。\n\n    方法：\n\n    - 同步锁\n    - 无锁编程\n\n\n    ### 思考：锁带来的问题？\n\n    1. 性能。引入无锁编程可以最大化减少线程上下文切换，线程等待。\n    2. 死锁。引入无锁编程就不会产生死锁。\n\n    无锁编程性能并不是总是优于锁同步。\n\n    无锁编程依赖于原子类型，使用原子类型还需要深入了解一些概念。\n\n\n    ###  理解无锁并发的关键在于理解计算机组成\n \n    ```text\n    +------+    +------+    +------+\n    | core |    | core |    | core |\n    +---+--+    +---+--+    +---+--+\n        |           |           |\n    +lv1+--+    +-lv1--+    +lv1---+\n    |cache |    |cache |    | cache|\n    +---+--+    +---+--+    +---+--+\n        |           |           |\n    +lv2---+    +lv2---+    +lv2---+\n    | cache|    | cache|    | cache|\n    +---+--+    +---+--+    +---+--+\n        |           |           |\n        +-----------------------+\n                    |\n    +---------------+--------------+\n    |           lv3 cache          |\n    +---------------+--------------+\n                    |\n                    |\n    +---------------+--------------+\n    |          main memory         |\n    +------------------------------+\n\n    ```\n\n    ### 缓存一致性问题\n\n    思考：下面代码最终执行后 x 和 y 的状态上什么？\n\n    ``` text\n    // THREAD 1                       \n\n    if unsafe { *x == 1 } {\n        unsafe { *y += 1 }\n    }                   \n    \n    // THREAD 2\n    unsafe {\n        *y = 10;\n        *x = 1;\n    }\n    ```\n\n    最终结果实际取决于下面几个问题：\n\n    1. THREAD 1 和 THREAD 2 运行顺序是什么？ （使用锁同步可以保证“喂给” CPU 的指令锁有顺序性的）\n    2. 每一个 CPU 使用的高速缓存的状态 （要保证缓存一致性）\n    3. CPU 指令重排（乱序执行，为了更好的利用流水线，达到性能极致）\n    4. 编译器指令重排 （调整指令顺序，使其对 CPU 更友好）\n\n\n    > 高速缓存通过 M(Modified)E(Exclusive)S(Shared)I(Invalid) 协议来保持同步。MESI的有趣之处在于，每个高速缓存行都在维护自己的内存地址状态机。\n    > 一个 CPU 通过 IPC (Inter-Processor-Communication) 向 另一个 CPU 来发送消息，比如，「独占内存地址」、「修改内存数据」等。\n    > 这里要注意，CPU 并不是做来某些操作马上发出消息或者是收到消息马上就执行相应操作的。也就是说，CPU 通信的这些消息都是异步的。\n    > 如果 CPU 多核之间用同步通信的话，性能上无法接受。比如一个 CPU 要等待其他 CPU 来确认信息，或从其他 CPU 获取最新数据等。\n    > 所以，为了让 CPU 核之间可以高性能地同步信息（保证cpu乱序执行指令的同时，还要保证程序正确性），就引入了内存屏障的技术。\n    \n\n    ### 内存屏障\n    \n    内存屏障允许开发者在编写代码等时候在需要等地方加入它。\n\n    内存屏障分为：\n\n    1. 读屏障（Load Memory Barrier）。任何「读屏障」前的「读操作」都会先于「读屏障」后的「读操作」完成。\n    2. 写屏障（Store Memory Barrier）。任何「写屏障」前的「写操作」都会先于「写屏障」后的「写操作」完成。\n    3. 全屏障。同时包含读屏障和写屏障的作用。\n\n    load，代表从内存读数据。store，代表向内存写数据。\n\n    现代 CPU 架构中一般分为四种内存屏障：\n\n    1. Load-Load: 等价于上面介绍的「读屏障」。任何「该屏障」前的「读操作」都会先于「该屏障」后的「读操作」完成。\n    2. Load-Store: 任何「该屏障」前的「读操作」都会先于「该屏障后」的「写操作」完成。\n    3. Store-Load: 任何「该屏障」前的「写操作」都会先于「该屏障后」的「读操作」完成。\n    4. Store-Store: 等价于上面介绍的「写屏障」。任何「该屏障」前的「写操作」都会先于「该屏障」后的「写操作」完成。\n\n\n    开发者通过内存屏障，告诉 CPU/编译器 内存屏障前后指令的顺序关系，这样 CPU/编译器 就不会重排这些指令，从而保证原子指令的顺序性。\n\n    ### 内存模型\n\n    这么多内存屏障，什么时候该使用哪种，需要由开发者来指定。这道理和 Unsafe Rust 类似，编译器无法检查的安全性，交给开发者。\n\n    这就是语言提供内存模型的原因。Cpp 和 Rust 语言都提供了原子（Atomic）类型，并且这些原子类型都是可以指定内存顺序（告诉CPU使用哪种内存屏障）\n\n    Rust 目前并没有正式的内存顺序模型，但是它在语义和行为上和 Cpp 一致。\n\n    由此引申出内存屏障都两种语义：\n\n    1. acquire（获取）语义。Load 之后的读写操作无法被重排至 Load 之前。即 相当于Load-Load和Load-Store屏障。\n    2. release（释放）语义。Store 之前的读写操作无法被重排至 Store 之后。即 相当于Load-Store和Store-Store屏障。\n\n\n    ### 原子操作\n\n    Rust 标准库中定义的原子类型：[std::sync::atomic: https://doc.rust-lang.org/stable/std/sync/atomic/index.html](https://doc.rust-lang.org/stable/std/sync/atomic/index.html)\n    其中`// std::sync::atomic::Ordering`定义了 Rust 支持的内存顺序，官方文档指出，当前和 Cpp20 的内存顺序是一致的。\n    \n\n    ```rust\n    // std::sync::atomic::Ordering\n\n    pub enum Ordering {\n        Relaxed,\n        Release,\n        Acquire,\n        AcqRel,\n        SeqCst,\n    }\n    ```\n\n    注意，Rust 当前并没有公开 cpp 里面包含对 consume 语义。\n\n    内存顺序说明：\n\n    - Relaxed，表示原子类型只保证原子操作即可，没有内存顺序（不指定内存屏障）\n    - Release，\n        - 表示使用 Release 语义。\n        - 当前线程内的所有写操作，对于其他对这个原子变量进行 acquire 的线程可见\n    - Acquire，\n        - 表示使用 Acquire 语义。\n        - acquire 可以保证读到所有在 release 前发生的写入。\n    - AcqRel，\n        - 表示对读取和写入施加 acquire-release 语义，无法被重排。\n        - 可以看见其他线程施加 release 语义的所有写入，同时自己的 release 结束后所有写入对其他施加 acquire 语义的线程可见。\n    - SeqCst，\n        - 如果是读取就是 acquire 语义，如果是写入就是 release 语义，如果是读取+写入就是 acquire-release 语义。\n        - 所有线程都能以相同的顺序看到所有顺序一致的操作。\n    \n    不同对内存顺序，对应不同对内存屏障，进一步，也代表了不同的性能。\n    在竞争条件比较激烈的情况下，Relaxed 性能是最好的，因为它不需要任何内存屏障，这就意味着CPU之间不需要进行一致性同步。\n    相对而言，SeqCst 就是性能最差的那个了，因为它需要 CPU 同步所有指令。\n    但是 Relaxed 因为没有内存屏障，所以可能会有指令重排带来带风险。\n    所以，Rust 标准库也提供了` std::sync::atomic::compiler_fence`和` std::sync::atomic::fence`两个函数，来帮助解决在原子指令使用 Relaxed 内存顺序的情况下编译器或CPU指令重排的问题。\n\n    示例：[https://doc.rust-lang.org/stable/std/sync/atomic/fn.compiler_fence.html](https://doc.rust-lang.org/stable/std/sync/atomic/fn.compiler_fence.html)\n\n    原子类型提供的方法，基于硬件原子指令 (x均为std::atomic)\t：\n\n    - `load`，返回x的值。\n    - `store`，把x设为n，什么都不返回。\n    - `swap`，把x设为n，返回设定之前的值。\n    - `compare_and_swap`，经典cas操作。\n    - `compare_exchange.\n    - `compare_exchange_weak\n    - `fetch_add(n), fetch_sub(n)`，原子地做x += n, x-= n，返回修改之前的值。\n\n   \n    使用原子类型需要注意的是：\n\n    - Store操作，可选内存顺序：Relaxed, Release, SeqCst。否则panic。\n    - Load操作，可选内存顺序：Relaxed, Acquire, SeqCst。否则panic。\n    - Read-modify-write(读-改-写)操作，可选如下顺序：Relaxed, Acquire, Release, AcqRel, SeqCst。\n    - 所有操作的默认顺序都是 SeqCst。\n\n     ```rust\n    // 实现一个简单的自旋锁（spinlock）\n    \n    use std::sync::Arc;\n    use std::sync::atomic::{AtomicUsize, Ordering};\n    use std::{thread, time};\n\n    fn main() {\n        let spinlock = Arc::new(AtomicUsize::new(1));\n\n        let spinlock_clone = Arc::clone(&spinlock);\n        let thread = thread::spawn(move|| {\n            // lock\n            spinlock_clone.store(1, Ordering::SeqCst);\n            // do something\n            let t = time::Duration::from_secs(3);\n            std::thread::sleep(t);\n            // unlock\n            spinlock_clone.store(0, Ordering::SeqCst);\n        });\n\n        // Wait for the other thread to release the lock\n        while spinlock.load(Ordering::SeqCst) != 0 {}\n\n        if let Err(panic) = thread.join() {\n            println!(\"Thread had an error: {:?}\", panic);\n        }\n    }\n\n    ```\n\n    利用 AtomicBool 实现一个 轻量级的锁 ：\n\n    ```rust\n    use std::sync::atomic::Ordering;\n    use core::sync::atomic::AtomicBool;\n\n    struct LightLock(AtomicBool);\n\n    impl LightLock {\n        pub fn new() -> LightLock {\n            LightLock(AtomicBool::new(false))\n        }\n\n        pub fn try_lock<'a>(&'a self) -> Option<LightGuard<'a>> {\n            let was_locked = self.0.swap(true, Ordering::Acquire);\n            if was_locked {\n                None\n            } else {\n                Some(LightGuard { lock: self })\n            }\n        }\n    }\n\n    struct LightGuard<'a> {\n        lock: &'a LightLock,\n    }\n\n    impl<'a> Drop for LightGuard<'a> {\n        fn drop(&mut self) {\n            self.lock.0.store(false, Ordering::Release);\n        }\n    }\n    ```\n\n    ### ABA 问题：\n\n    任何无 GC 的语言在无锁编程的时候都要考虑此问题。\n\n    试想一个连续压栈（push）和 出栈（pop）的并发操作。假设这两个操作都是由 cas 原语实现的。\n\n    > 具体来说，假如有两个线程 T1 和 T2，操作初始栈为「a->b->c」的栈结构。\n    > 当 T1 把 a 从栈内弹出，此时发生线程调度，\n    > 切换到 T2 ，T2 弹出 a 和 b，把 a 再 push 到栈里，此时 T2 的栈为 「a->c」。\n    > 然后线程切回 T1 ，T1 看到栈顶（a）的地址和它之前获得的 a 地址相同，然后将 栈顶设置为 b （a.next），然而 b 早就被释放来。\n\n    这就是 ABA 问题。ABA 问题本质是内存回收问题。当 b 被弹出当时候，要保障它当内存不能被立即重用。\n    \n    解决该问题的思路有多种：引用计数、分代回收（Epoch Based Reclamation）和 险象指针（Hazard pointer）。\n\n    注意：ABA 问题一般是发生在 X86 架构上 cas 原子操作的时候。ARM 架构已经从根源上解决了 ABA 问题。\n\n    - 分代回收示例：[https://github.com/crossbeam-rs/crossbeam/blob/master/crossbeam-epoch/examples/sanitize.rs](https://github.com/crossbeam-rs/crossbeam/blob/master/crossbeam-epoch/examples/sanitize.rs)\n    - 险象指针示例：\n        - [https://github.com/solotzg/rs-lockfree/blob/master/src/hazard_pointer.rs](https://github.com/solotzg/rs-lockfree/blob/master/src/hazard_pointer.rs)\n        -  [https://github.com/redox-os/conc/blob/master/src/sync/treiber.rs](https://github.com/redox-os/conc/blob/master/src/sync/treiber.rs)\n\n\n\n*/","span":{"file_name":"src/ch02/s4_lockfree.rs","byte_start":86702,"byte_end":98543,"line_start":6,"line_end":278,"column_start":1,"column_end":3}}]},{"kind":"Mod","id":{"krate":0,"index":57},"span":{"file_name":"src/ch02/s5_trait_and_generic.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"s5_trait_and_generic","qualname":"::ch02::s5_trait_and_generic","value":"src/ch02/s5_trait_and_generic.rs","parent":null,"children":[{"krate":0,"index":58},{"krate":0,"index":59},{"krate":0,"index":60},{"krate":0,"index":61},{"krate":0,"index":62},{"krate":0,"index":63},{"krate":0,"index":64}],"decl_id":null,"docs":" 第二章：Rust核心概念\n 2.4 trait 和 泛型\n \n \n","sig":null,"attributes":[{"value":"/ 第二章：Rust核心概念","span":{"file_name":"src/ch02/s5_trait_and_generic.rs","byte_start":98573,"byte_end":98605,"line_start":1,"line_end":1,"column_start":1,"column_end":17}},{"value":"/ 2.4 trait 和 泛型","span":{"file_name":"src/ch02/s5_trait_and_generic.rs","byte_start":98606,"byte_end":98630,"line_start":2,"line_end":2,"column_start":1,"column_end":19}},{"value":"/ ","span":{"file_name":"src/ch02/s5_trait_and_generic.rs","byte_start":98631,"byte_end":98635,"line_start":3,"line_end":3,"column_start":1,"column_end":5}},{"value":"/ ","span":{"file_name":"src/ch02/s5_trait_and_generic.rs","byte_start":98636,"byte_end":98640,"line_start":4,"line_end":4,"column_start":1,"column_end":5}}]},{"kind":"Function","id":{"krate":0,"index":58},"span":{"file_name":"src/ch02/s5_trait_and_generic.rs","byte_start":100481,"byte_end":100494,"line_start":108,"line_end":108,"column_start":8,"column_end":21},"name":"trait_concept","qualname":"::ch02::s5_trait_and_generic::trait_concept","value":"pub fn trait_concept()","parent":null,"children":[],"decl_id":null,"docs":"    # 概念介绍\n    \n    ### trait 四种作用","sig":null,"attributes":[{"value":"*\n\n    # 概念介绍\n    \n    ### trait 四种作用\n\n    - 接口 (interface)\n    - 类型标记（Mark)\n    - 泛型限定（trait bound）\n    - 抽象类型（trait object）\n\n\n   ### 静态分发（单态化 - Monomorphized）\n\n    ```rust\n    use std::string::ToString;\n\n    fn print<T: ToString>(v: T) {\n        println!(\"{}\", v.to_string());\n    }\n    ```\n\n    或 `impl Trait`语法\n\n    ```rust\n    use std::string::ToString;\n\n    #[inline(never)]\n    fn print(v: &impl ToString) {\n        println!(\"{}\", v.to_string());\n    }\n    ```\n\n    使用 `impl Trait` 解决问题：\n\n\n    ```rust\n    // error codes：\n\n    use std::fmt::Display;\n\n    fn main() {\n        println!(\"{}\", make_value(0));\n        println!(\"{}\", make_value(1));\n    }\n\n    fn make_value<T: Display>(index: usize) -> T {\n        match index {\n            0 => \"Hello, World\",\n            1 => \"Hello, World (1)\",\n            _ => panic!(),\n        }\n    }\n\n    ```\n\n    修正：\n\n    ```\n    use std::fmt::Display;\n\n    fn make_value(index: usize) -> impl Display {\n        match index {\n            0 => \"Hello, World\",\n            1 => \"Hello, World (1)\",\n            _ => panic!(),\n        }\n    }\n\n    ```\n\n    `impl Trait` 生命周期相关：\n\n    ```rust\n\n    // error\n    fn make_debug<T>(_: T) -> impl std::fmt::Debug + 'static{\n        42u8\n    }\n\n    // fn make_debug<'a, T: 'static>(_: &'a T) -> impl std::fmt::Debug + 'static{\n    //     42u8\n    // }\n\n    fn test() -> impl std::fmt::Debug {\n        let value = \"value\".to_string();\n        make_debug(&value)\n    }\n    ```\n\n   实际案例 - 模版模式：[https://github.com/actix/actix-extras/tree/master/actix-web-httpauth](https://github.com/actix/actix-extras/tree/master/actix-web-httpauth)\n\n\n   # trait 一致性\n\n    trait 和 类型 必须有一个在本地。\n\n\n\n */","span":{"file_name":"src/ch02/s5_trait_and_generic.rs","byte_start":98644,"byte_end":100473,"line_start":8,"line_end":107,"column_start":1,"column_end":4}}]},{"kind":"Function","id":{"krate":0,"index":59},"span":{"file_name":"src/ch02/s5_trait_and_generic.rs","byte_start":102170,"byte_end":102188,"line_start":186,"line_end":186,"column_start":8,"column_end":26},"name":"trait_dyn_dispatch","qualname":"::ch02::s5_trait_and_generic::trait_dyn_dispatch","value":"pub fn trait_dyn_dispatch()","parent":null,"children":[],"decl_id":null,"docs":"# 动态分发    ","sig":null,"attributes":[{"value":"*\n \n\n# 动态分发    \n\n    ### trait 对象\n\n    用泛型模拟 Class\n\n    ```rust\n\n    #![allow(unused)]\n\n    use core::any::{Any,TypeId};\n    use std::sync::Arc;\n\n    /// Class definition\n    struct Class {\n        /// The name of the class\n        name: String,\n        /// The corresponding Rust type\n        type_id: TypeId,\n    }\n\n    impl Class {\n        /// Create a new class definition for the type `T`\n        fn new<T: 'static>() -> Self {\n            Self {\n                name: std::any::type_name::<T>().to_string(),\n                type_id: TypeId::of::<T>(),\n            }\n        }\n    }\n\n    /// An instance of a class\n    struct Instance {\n        inner: Arc<dyn Any>, // `Arc` because we don't need/want mutability\n    }\n\n    impl Instance {\n        /// Construct a new `Instance` from a type that\n        /// implements `Any` (i.e. any sized type).\n        fn new(obj: impl Any) -> Self {\n            Self {\n                inner: Arc::new(obj)\n            }\n        }\n    }\n\n    impl Instance {\n        /// Check whether this is an instance of the provided class\n        fn instance_of(&self, class: &Class) -> bool {\n            // self.inner.type_id() == class.type_id\n            self.inner.as_ref().type_id() == class.type_id\n        }\n    }\n\n    struct Foo {}\n    struct Bar {}\n\n    fn main(){\n        \n\n        let foo_class: Class = Class::new::<Foo>();\n        let bar_class: Class = Class::new::<Bar>();\n        let foo_instance: Instance = Instance::new(Foo {});\n\n        assert!(foo_instance.instance_of(&foo_class));\n        assert!(!foo_instance.instance_of(&bar_class));\n    }\n    ```\n\n*/","span":{"file_name":"src/ch02/s5_trait_and_generic.rs","byte_start":100531,"byte_end":102162,"line_start":113,"line_end":185,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":60},"span":{"file_name":"src/ch02/s5_trait_and_generic.rs","byte_start":108905,"byte_end":108917,"line_start":370,"line_end":370,"column_start":8,"column_end":20},"name":"trait_object","qualname":"::ch02::s5_trait_and_generic::trait_object","value":"pub fn trait_object()","parent":null,"children":[],"decl_id":null,"docs":"# trait 对象本质","sig":null,"attributes":[{"value":"*\n   \n# trait 对象本质\n\n\n示例 1:\n\n```rust\n    struct CloningLab {\n        subjects: Vec<Box<Mammal>>,\n        // subjects: Vec<Box<Mammal + Clone>>,\n    }\n\n    trait Mammal {\n        fn walk(&self);\n        fn run(&self);\n    }\n\n    #[derive(Clone)]\n    struct Cat {\n        meow_factor: u8,\n        purr_factor: u8\n    }\n\n    impl Mammal for Cat {\n        fn walk(&self) {\n            println!(\"Cat::walk\");\n        }\n        fn run(&self) {\n            println!(\"Cat::run\")\n        }\n    }\n\n\n```\n\n示例2:\n\n```rust\n\n    #![allow(unused)]\n    #![feature(raw)]\n\n    use std::{mem, raw};\n\n    // an example trait\n    trait Foo {\n        fn bar(&self) -> i32;\n    }\n\n    impl Foo for i32 {\n        fn bar(&self) -> i32 {\n            *self + 1\n        }\n    }\n\n    fn main() {\n        let value: i32 = 123;\n\n        // let the compiler make a trait object\n        let object: &dyn Foo = &value;\n\n        // look at the raw representation\n        let raw_object: raw::TraitObject = unsafe { mem::transmute(object) };\n\n        // the data pointer is the address of `value`\n        assert_eq!(raw_object.data as *const i32, &value as *const _);\n\n        let other_value: i32 = 456;\n\n        // construct a new object, pointing to a different `i32`, being\n        // careful to use the `i32` vtable from `object`\n        let synthesized: &dyn Foo = unsafe {\n            mem::transmute(raw::TraitObject {\n                data: &other_value as *const _ as *mut (),\n                vtable: raw_object.vtable,\n            })\n        };\n\n        // it should work just as if we had constructed a trait object out of\n        // `other_value` directly\n        assert_eq!(synthesized.bar(), 457);\n    }\n\n```\n\n正常 trait Object 布局图：\n\n```text\n\n                                                           cat's vtable\nCat Layout                     Trait Object\n+------------+              +--------------+             +---------------+\n|            |              |              |             |               |\n|            |              |              |     +-----> | drop pointer  |\n| meow_factor|              |              |     |       |    size       |\n|            +<--------------+data pointer |     |       |    align      |\n| purr_factor|              |              |     |       |               |\n|            |              | vtable pointer-----+       | run fn pointer|\n|            |              |              |             |walk fn pointer|\n|            |              |              |             |               |\n+------------+              +--------------+             |               |\n                                                         |               |\n                                                         |               |\n                                                         |               |\n                                                         +---------------+\n\n```\n    \n假设：trait Mammal + Clone 布局图：\n    \n注意：非法\n\n```text\n\n                                                                  Mammal\n                                                           cat's vtable\nCat Layout                     Trait Object\n+------------+              +--------------+             +---------------+\n|            |              |              |             |               |\n|            |              |              |     +-----> | drop pointer  |\n| meow_factor|              |              |     |       |    size       |\n|            +<--------------+data pointer |     |       |    align      |\n| purr_factor|              |              |     |       |               |\n|            |              | vtable pointer-----+       | run fn pointer|\n|            |              |              |             |walk fn pointer|\n|            |              |              +-----+       |               |\n+------------+              +--------------+     |       |               |\n                                                 |       |               |\n                                                 |       |               |\n                                                 |       |               |\n                                                 |       +---------------+\n                                                 |\n                                                 |\n                                                 |           Clone Vtable\n                                                 |\n                                                 +-----> +--------------+\n                                                         |              |\n                                                         | drop pointe  |\n                                                         |              |\n                                                         | size         |\n                                                         | align        |\n                                                         |              |\n                                                         |  clone       |\n                                                         |  fn pointer  |\n                                                         |              |\n                                                         +--------------+\n\n\n```\n\n    假设：trait 继承(`trait MammalClone: Mammal+Clone`)布局图： \n\n    注意：非法\n  \n```text\n\n                                                            MammalClone\n                                                           cat's vtable\nCat Layout                     Trait Object\n+------------+              +--------------+             +-----------------+\n|            |              |              |             |                 |\n|            |              |              |     +-----> | drop pointer    |\n| meow_factor|              |              |     |       |    size         |\n|            +<--------------+data pointer |     |       |    align        |\n| purr_factor|              |              |     |       |                 |\n|            |              | vtable pointer-----+       | run fn pointer  |\n|            |              |              |             |walk fn pointer  |\n|            |              |              |             |                 |\n+------------+              +--------------+             |clone fn pointer |\n                                                         |                 |\n                                                         |                 |\n                                                         |                 |\n                                                         +-----------------+\n\n ```\n\n\n*/","span":{"file_name":"src/ch02/s5_trait_and_generic.rs","byte_start":102232,"byte_end":108897,"line_start":191,"line_end":369,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":61},"span":{"file_name":"src/ch02/s5_trait_and_generic.rs","byte_start":113515,"byte_end":113528,"line_start":478,"line_end":478,"column_start":8,"column_end":21},"name":"object_safety","qualname":"::ch02::s5_trait_and_generic::object_safety","value":"pub fn object_safety()","parent":null,"children":[],"decl_id":null,"docs":"#  对象安全","sig":null,"attributes":[{"value":"*\n\n#  对象安全\n\n\n\n### 对象安全\n    \n    一个 trait 如果能实现自己，就认为它是对象安全的\n\n为什么必须是对象安全呢？\n    \ntrait对象，在运行时已经擦除了类型信息，要通过虚表调用相应的方法。不像静态分发那样，trait对象不是为每个类型都实现trait的方法，而是只实现一个副本（自动为其实现自身），结合虚函数去调用。\n\n现在想一个问题： 假如那个类型没有实现这个方法怎么办？\n实际上，会有很多种情况下，会出现这个问题。运行时确定的类型和方法应该合法的，保证trait对象在运行时可以安全地调用相关的方法。\n\n比如trait里有泛型函数。这就搞的很复杂了，可能运行时无法确定该调用哪个函数。反正是各种情况吧。所以，为了避免出现这种问题，官方引入了对象安全的概念。\n实际上就是引入了一系列的规则，也就是上面列出的那些。编译器根据这些规则，在编译期判断一个你写的trait对象，是不是合法的。\n\n比如：trait对象其实在内部维护两个表：safe_vtable和nonself_vtable，标记有where Self: Sized的会被归类到nonself_vtable，也就是说，不会被trait对象调用。\n这样的话，方法标记有where Self: Sized的trait对象自然是安全的，因为这表示 这个方法 只能为 Self: Sized 都类型实现，是有条件的，所以在运行时有可能存在无效（万一有不是Sized的类型调用，就没有该方法）调用。\n\n如果是合法的，则代表了，这个trait对象在运行时调用方法应该是没问题的。\n不会出现没有实现，或者不知道该调用哪个的情况。\n这就是对象安全的概念。它和内存安全并无直接关系。\n所以，对象安全的本质就是为了让trait对象可以安全地调用相应的方法。\n\n如果没有Sized的限定，那么就会很容易写出无用的类型。比如 Box，它用做trait对象即便会编译，但是不能用它做任何事情（后面有演示代码）。\n对于更复杂的trait，往往就没有这么明显了，只有在做了大量繁重的工作之后可能会突然发现某个trait对象无法正常调用方法。\n所以，为trait增加Sized限定，然后编译器自动为该trait实现自身，就可以在编译期准确排除无效的trait对象。\n这就是对象安全。需要注意的是，对象安全和内存安全并无直接的关联，它只是保证trait对象在运行时可以安全准确地调用相关的方法。\n\n```rust\n    trait StarkFamily {\n        fn last_name(&self)  -> &'static str;\n        fn totem(&self) -> &'static str;\n    }\n\n    trait TullyFamily {\n        fn territory(&self) -> &'static str;\n    }\n\n    trait Children {\n        fn new(first_name: &'static str) -> Self where Self: Sized;\n        fn first_name(&self) -> &'static str;\n    }\n\n    impl StarkFamily for Children {\n        fn last_name(&self)  -> &'static str{\n            \"Stark\"\n        }\n        \n        fn totem(&self)  -> &'static str{\n            \"Wolf\"\n        }\n    }\n\n    impl TullyFamily for Children {\n        fn territory(&self)  -> &'static str{\n            \"Riverrun City\" \n        }\n    }\n\n    struct People{\n        first_name: &'static str\n    }\n\n    impl Children for People {\n        fn new(first_name: &'static str) -> Self where Self: Sized{\n            println!(\"hello : {} Stark \", first_name);\n            People{first_name: first_name}\n        }\n        \n        fn first_name(&self) -> &'static str{\n            self.first_name\n        }\n    }\n\n    fn full_name(person: Box<dyn Children>) {\n        println!(\" --- Winter is coming, the lone {:?} dies, the pack lives ---\", person.totem());\n        let full = format!(\"{} {}\", person.first_name(), person.last_name() );\n        println!(\"I'm {:?}\", full );\n        println!(\"My Mother come from {:?}\", person.territory());\n    }\n\n    fn main() {\n        let sansa = People::new(\"Sansa\");\n        let aray = People::new(\"Aray\");\n        \n        let starks: Box<dyn Children> = Box::new(sansa);\n        full_name(starks);\n        \n        let starks: Box<dyn Children> = Box::new(aray);\n        full_name(starks);\n    }\n\n```\n    \n    \n对象安全规则 Rust 源码：[https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/compiler/rustc_middle/src/traits/mod.rs#L643](https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/compiler/rustc_middle/src/traits/mod.rs#L643)\n\n\n*/","span":{"file_name":"src/ch02/s5_trait_and_generic.rs","byte_start":108960,"byte_end":113507,"line_start":374,"line_end":477,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":62},"span":{"file_name":"src/ch02/s5_trait_and_generic.rs","byte_start":116940,"byte_end":116960,"line_start":629,"line_end":629,"column_start":8,"column_end":28},"name":"trait_object_to_enum","qualname":"::ch02::s5_trait_and_generic::trait_object_to_enum","value":"pub fn trait_object_to_enum()","parent":null,"children":[],"decl_id":null,"docs":"# 当不能实现 trait 对象当时候该如何？","sig":null,"attributes":[{"value":"*\n\n# 当不能实现 trait 对象当时候该如何？\n\n1. 将其转化为 Enum \n\ntrait 对象代码：\n\n```rust\n    trait KnobControl {\n        fn set_position(&mut self, value: f64);\n        fn get_value(&self) -> f64;\n    }\n\n    struct LinearKnob {\n        position: f64,\n    }\n\n    struct LogarithmicKnob {\n        position: f64,\n    }\n\n    impl KnobControl for LinearKnob {\n        fn set_position(&mut self, value: f64) {\n            self.position = value;\n        }\n\n        fn get_value(&self) -> f64 {\n            self.position\n        }\n    }\n\n    impl KnobControl for LogarithmicKnob {\n        fn set_position(&mut self, value: f64) {\n            self.position = value;\n        }\n\n        fn get_value(&self) -> f64 {\n            (self.position + 1.).log2()\n        }\n    }\n\n    fn main() {\n        let v: Vec<Box<dyn KnobControl>> = vec![\n            //set the knobs\n        ];\n\n        //use the knobs\n    }\n```\n\n转为 enum：\n\n```rust\n    enum Knob {\n        Linear(LinearKnob),\n        Logarithmic(LogarithmicKnob),\n    }\n\n    impl KnobControl for Knob {\n        fn set_position(&mut self, value: f64) {\n            match self {\n                Knob::Linear(inner_knob) => inner_knob.set_position(value),\n                Knob::Logarithmic(inner_knob) => inner_knob.set_position(value),\n            }\n        }\n\n        fn get_value(&self) -> f64 {\n            match self {\n                Knob::Linear(inner_knob) => inner_knob.get_value(),\n                Knob::Logarithmic(inner_knob) => inner_knob.get_value(),\n            }\n        }\n    }\n```\n\n当 trait 不满足对象安全规则的时候，也可以用 Enum 代替。\n\n```rust\n#![allow(unused)]\n\nuse core::ops::Add;\n\ntrait KnobControl<T: Add + Add<Output = T> + Copy> {\n    fn set_position(&mut self, value: T);\n    fn get_value(&self, p: T) -> T;\n}\n\nstruct LinearKnob<T: Add+ Add<Output = T> + Copy> {\n    position: T,\n}\n\nstruct LogarithmicKnob<T: Add+ Add<Output = T> + Copy>  {\n    position: T,\n}\n\nimpl<T: Add+ Add<Output = T> + Copy> KnobControl<T> for LinearKnob<T> {\n    fn set_position(&mut self, value: T) {\n        self.position = value;\n    }\n\n    fn get_value(&self, p: T) -> T {\n        self.position + p\n    }\n}\n\nimpl<T: Add+ Add<Output = T> + Copy> KnobControl<T> for LogarithmicKnob<T> {\n    fn set_position(&mut self, value: T) {\n        self.position = value;\n    }\n\n    fn get_value(&self, p: T) -> T {\n        (self.position + p)\n    }\n}\n\nfn main() {\n    enum Knob<T: Add+ Add<Output = T> + Copy> {\n        Linear(LinearKnob<T>),\n        Logarithmic(LogarithmicKnob<T>),\n    }\n\n    impl<T: Add+ Add<Output = T> + Copy> KnobControl<T> for Knob<T> {\n        fn set_position(&mut self, value: T) {\n            match self {\n                Knob::Linear(inner_knob) => inner_knob.set_position(value),\n                Knob::Logarithmic(inner_knob) => inner_knob.set_position(value),\n            }\n        }\n\n        fn get_value(&self, p: T) -> T {\n            match self {\n                Knob::Linear(inner_knob) => inner_knob.get_value(p),\n                Knob::Logarithmic(inner_knob) => inner_knob.get_value(p),\n            }\n        }\n    }\n}\n\n\n```\n\n\n2. 利用 “魔法” ，相当于加一层代理 ： 参考：[https://github.com/dtolnay/erased-serde/blob/master/explanation/main.rs](https://github.com/dtolnay/erased-serde/blob/master/explanation/main.rs)\n\n*/","span":{"file_name":"src/ch02/s5_trait_and_generic.rs","byte_start":113572,"byte_end":116932,"line_start":483,"line_end":628,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":63},"span":{"file_name":"src/ch02/s5_trait_and_generic.rs","byte_start":118994,"byte_end":119007,"line_start":738,"line_end":738,"column_start":8,"column_end":21},"name":"blanket_impls","qualname":"::ch02::s5_trait_and_generic::blanket_impls","value":"pub fn blanket_impls()","parent":null,"children":[],"decl_id":null,"docs":"# Overlapping blanket impls","sig":null,"attributes":[{"value":"*\n\n# Overlapping blanket impls\n\n当前 Rust 不支持  `trait `为 同一个类型覆盖实现：\n\n```rust\n    trait Blanket {\n        fn blanket(&self) -> &'static str;\n    }\n\n    impl Blanket for u8 {\n        fn blanket(&self) -> &'static str {\n            \"impl1\"\n        }\n    }\n\n    // Compilation fails at that point\n    impl Blanket for u8 {\n        fn blanket(&self) -> &'static str {\n            \"impl2\"\n        }\n    }\n\n    fn main() {\n        // If compilation succeeded, what would be printed?\n        println!(\"{}\", 0u8.blanket());\n    }\n\n```\n\n再比如泛型：\n\n```rust\n    impl <T: ToString> Blanket for T { ... }\n\n    // Compilation fails at that point\n    impl <T: Clone> Blanket for T { ...}\n\n```\n\n以上是 Rust 不允许的。\n\n虽然特化功能也逐渐开始支持，但不足以解决上面这种存在`trait`实现“竞争”的情况。\n\n一个解决方案是：\n\n```rust\n    trait Blanket<I> {\n        fn blanket(&self) -> &'static str;\n    }\n\n    impl Blanket<u8> for u8 {\n        fn blanket(&self) -> &'static str {\n            \"u8\"\n        }\n    }\n\n    impl<T: ToString> Blanket<&ToString> for T {\n        fn blanket(&self) -> &'static str {\n            \"ToString\"\n        }\n    }\n\n    trait CloneBlanket {}\n\n    impl<T: Clone> Blanket<&CloneBlanket> for T {\n        fn blanket(&self) -> &'static str {\n            \"Clone\"\n        }\n    }\n\n    trait TryIntoBlanket<T> {\n        type Error;\n    }\n\n    impl<T, E, U> Blanket<&TryIntoBlanket<T, Error = E>> for U\n    where\n        U: TryInto<T, Error = E>,\n    {\n        fn blanket(&self) -> &'static str {\n            \"try_into\"\n        }\n    }\n\n    impl<T: ToString> Blanket<&ToString> for T {\n        fn blanket(&self) -> &'static str {\n            \"to_string\"\n        }\n    }\n\n    impl<T: AsRef<U>, U: ?Sized> Blanket<&AsRef<U>> for T {\n        fn blanket(&self) -> &'static str {\n            \"as_ref\"\n        }\n    }\n\n```\n\n方案参考：https://codesandwich.github.io/overlapping_blanket_impls/\n\n\n\n*/","span":{"file_name":"src/ch02/s5_trait_and_generic.rs","byte_start":116999,"byte_end":118986,"line_start":634,"line_end":737,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":64},"span":{"file_name":"src/ch02/s5_trait_and_generic.rs","byte_start":121143,"byte_end":121165,"line_start":854,"line_end":854,"column_start":8,"column_end":30},"name":"trait_self_sized_bound","qualname":"::ch02::s5_trait_and_generic::trait_self_sized_bound","value":"pub fn trait_self_sized_bound()","parent":null,"children":[],"decl_id":null,"docs":"    ### 对象安全规则里，为什么需要 `Self: Sized` ","sig":null,"attributes":[{"value":"*\n\n    ### 对象安全规则里，为什么需要 `Self: Sized` \n\n    思考：什么情况下需要 `Self: Sized` ？\n\n    ```rust\n\n    trait WithConstructor {\n        fn build(param: usize) -> Self where Self: Sized;\n\n        fn new() -> Self where Self: Sized {\n            Self::build(0)\n        }\n        \n\n        fn t(&self){\n            println!(\"T\");\n        }\n        \n        fn p(&self){\n            self.t();\n            println!(\"hello\");\n        }\n    }\n\n    struct A;\n\n    impl WithConstructor for A {\n        fn build(param: usize) -> Self{\n            A\n        }\n        \n    }\n\n    fn main(){\n        let a : &WithConstructor = &A ;\n    }\n    ```\n\n    示例 2:\n\n    ```rust\n\n    trait Test {\n        fn foo(self);\n        \n        fn works(self: Box<Self>){\n            println!(\"hello Trait\");\n        }\n        \n        fn fails(self: Box<Self>)\n        where Self: Sized\n        {\n            self.foo()    \n        }\n    }\n\n    struct Concrete;\n\n    impl Concrete {\n        fn hello(&self){\n            println!(\"hello\");\n        }\n    }\n\n    struct Bar;\n\n    impl Bar {\n        fn hello(&self){\n            println!(\"hello Bar\");\n        }\n    }\n\n    impl Test for Bar {\n        fn foo(self) { () }\n        fn works(self: Box<Self>) { self.hello()}\n    }\n\n    impl Test for Concrete {\n        fn foo(self) { () }\n        fn works(self: Box<Self>) { self.hello()}\n    }\n\n    fn main() {\n        let concrete: Box<dyn Test> = Box::new(Concrete);\n        concrete.works();\n        let concrete: Box<dyn Test> = Box::new(Bar);\n        concrete.works();\n        // concrete.fails(); // compilation error\n    }\n\n    ```\n\n    结论： \n    1. `Self: Sized` 为了保证 trait 默认实现内部的 Self 调用都是合法的。\n    2. 防止 函数体内包含了 Self 的默认实现混入虚表。因为虚表内 Self 无法确定。\n\n    ### Sized  vs  ?Sized \n\n    ```rust\n    trait WithConstructor {\n        fn build(param: usize) -> Self where Self: ?Sized;\n\n        fn new() -> Self where Self: ?Sized {\n            Self::build(0)\n        }\n    } \n    ```\n\n*/","span":{"file_name":"src/ch02/s5_trait_and_generic.rs","byte_start":119046,"byte_end":121135,"line_start":743,"line_end":853,"column_start":1,"column_end":3}}]},{"kind":"Mod","id":{"krate":0,"index":65},"span":{"file_name":"src/ch02/s6_paradigms.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"s6_paradigms","qualname":"::ch02::s6_paradigms","value":"src/ch02/s6_paradigms.rs","parent":null,"children":[{"krate":0,"index":66}],"decl_id":null,"docs":" 第二章：Rust核心概念\n 2.5 编程范式：面向编译器编程\n \n 讨论：\n \n 1. Rust 是 FP 语言吗？\n 2. Rust 是 OOP 语言吗？\n 3. 如果都不是，那 Rust 是面向啥的语言 ？ 面向编译器。\n \n \n","sig":null,"attributes":[{"value":"/ 第二章：Rust核心概念","span":{"file_name":"src/ch02/s6_paradigms.rs","byte_start":121216,"byte_end":121248,"line_start":1,"line_end":1,"column_start":1,"column_end":17}},{"value":"/ 2.5 编程范式：面向编译器编程","span":{"file_name":"src/ch02/s6_paradigms.rs","byte_start":121249,"byte_end":121293,"line_start":2,"line_end":2,"column_start":1,"column_end":21}},{"value":"/ ","span":{"file_name":"src/ch02/s6_paradigms.rs","byte_start":121294,"byte_end":121298,"line_start":3,"line_end":3,"column_start":1,"column_end":5}},{"value":"/ 讨论：","span":{"file_name":"src/ch02/s6_paradigms.rs","byte_start":121299,"byte_end":121312,"line_start":4,"line_end":4,"column_start":1,"column_end":8}},{"value":"/ ","span":{"file_name":"src/ch02/s6_paradigms.rs","byte_start":121313,"byte_end":121317,"line_start":5,"line_end":5,"column_start":1,"column_end":5}},{"value":"/ 1. Rust 是 FP 语言吗？","span":{"file_name":"src/ch02/s6_paradigms.rs","byte_start":121318,"byte_end":121349,"line_start":6,"line_end":6,"column_start":1,"column_end":22}},{"value":"/ 2. Rust 是 OOP 语言吗？","span":{"file_name":"src/ch02/s6_paradigms.rs","byte_start":121350,"byte_end":121382,"line_start":7,"line_end":7,"column_start":1,"column_end":23}},{"value":"/ 3. 如果都不是，那 Rust 是面向啥的语言 ？ 面向编译器。","span":{"file_name":"src/ch02/s6_paradigms.rs","byte_start":121383,"byte_end":121461,"line_start":8,"line_end":8,"column_start":1,"column_end":37}},{"value":"/ ","span":{"file_name":"src/ch02/s6_paradigms.rs","byte_start":121462,"byte_end":121466,"line_start":9,"line_end":9,"column_start":1,"column_end":5}},{"value":"/ ","span":{"file_name":"src/ch02/s6_paradigms.rs","byte_start":121467,"byte_end":121471,"line_start":10,"line_end":10,"column_start":1,"column_end":5}}]},{"kind":"Function","id":{"krate":0,"index":66},"span":{"file_name":"src/ch02/s6_paradigms.rs","byte_start":126312,"byte_end":126341,"line_start":193,"line_end":193,"column_start":8,"column_end":37},"name":"compiler_oriented_programming","qualname":"::ch02::s6_paradigms::compiler_oriented_programming","value":"pub fn compiler_oriented_programming()","parent":null,"children":[],"decl_id":null,"docs":"    ### Rust 是面向对象语言吗？","sig":null,"attributes":[{"value":"*\n\n    ### Rust 是面向对象语言吗？\n\n    OOP style:\n\n    1. 支持面向接口编程\n    2. 支持封装\n    3. 不支持继承(但可以模拟)\n\n    ```\n    interface Foo {}\n    class Bar: Foo {\n        //Implement Foo here\n    }\n    ```\n\n    ```rust\n    trait Foo {}\n    struct Bar;\n    impl Bar;\n    impl Foo for Bar {}\n    ```\n\n    ### Rust 是函数式语言吗？\n\n    函数式style：\n    1. 默认不可变（但也支持可变）\n    2. 支持递归（但不支持尾递归优化）\n    3. 函数是一等公民，高阶函数支持（有限）\n    4. 和类型/ 积类型 (Option/Result)\n\n    ```rust\n    fn get_sum(mut total: u32, mut i: u32) -> u32 {\n        if i > 10000000 {\n            return total;\n        }\n\n        total = total.wrapping_add(i);\n        i += 1;\n        get_sum(total, i)\n    }\n    fn main() {\n        let total = 0;\n        let total = get_sum(total, 1);\n        println!(\"{}\", total);\n    }\n\n    ```\n\n    curring:\n\n    ```\n    #[derive(Debug)]\n    struct States<'a> {\n        a: &'a i32,\n        b: &'a i32,\n    }\n\n    trait Currying {\n        type ReturnType: Fn(i32) -> i32;\n        fn add(self) -> Self::ReturnType;\n    }\n\n    impl Currying for States<'static>{\n        type ReturnType = Box<dyn Fn(i32) -> i32>;\n\n        fn add(self) -> Self::ReturnType {\n            Box::new(move|x| {\n                x * self.a\n            })\n        }\n    }\n\n    let r_value: States = States {\n        a: &100,\n        b: &100\n    };\n\n    let r1 = r_value.add();\n    let r2 = r1(5);\n\n    assert_eq!(500, r2);\n    ```\n\n    ### Rust 是 面向编译器 编程的语言\n\n    ```text\n    +----------------------------------------------------+\n    |                crate                               |\n    |                                                    |\n    |      +-----------------------------------+         |\n    |      |           std                     |         |\n    |      |                                   |         |\n    |      |       +---------------------+     |         |\n    |      |       |                     |     |         |\n    |      |       |     core            |     |         |\n    |      |       |    +----------+     |     |         |\n    |      |       |    | compiler |     |     |         |\n    |      |       |    +----------+     |     |         |\n    |      |       |                     |     |         |\n    |      |       +---------------------+     |         |\n    |      |                                   |         |\n    |      |                                   |         |\n    |      +-----------------------------------+         |\n    |                                                    |\n    |                                                    |\n    +----------------------------------------------------+\n\n    ```\n\n    查看 Rust 源码组织结构： [https://github.com/rust-lang/rust](https://github.com/rust-lang/rust)\n\n    洋葱模型：\n\n    1. 最小内核所谓所有权和借用规则，就是编译器特性\n    2. 基于最小内核开始构造了 core\n    3. 基于core 构造了 std\n    4. 基于 std 构造生态 crate\n    5. 命令式编程为主（类 C），OOP 和 FP Style 辅助\n\n    典型的实现：[std::cell::Cell](https://github.com/rust-lang/rust/blob/master/library/core/src/cell.rs)\n    \n    Cell 的语义：\n\n    1. 在不可变引用的基础上构造一个安全的内部可变性\n    2. 只针对实现 Copy 的类型提供 get 方法\n    3. 对于 非 Copy 的类型，提供 move out 的方法\n\n    ```rust\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[repr(transparent)]\n    pub struct Cell<T: ?Sized> {\n        value: UnsafeCell<T>,\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    unsafe impl<T: ?Sized> Send for Cell<T> where T: Send {}\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<T: ?Sized> !Sync for Cell<T> {}\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<T: Copy> Clone for Cell<T> {\n        #[inline]\n        fn clone(&self) -> Cell<T> {\n            Cell::new(self.get())\n        }\n    }\n\n    impl<T: Eq + Copy> Eq for Cell<T> {}\n\n    impl<T> Cell<T> {\n\n        pub const fn new(value: T) -> Cell<T> {\n            Cell { value: UnsafeCell::new(value) }\n        }\n\n        pub fn set(&self, val: T) {\n            let old = self.replace(val);\n            drop(old);\n        }\n    }\n\n    impl<T: Copy> Cell<T> {\n        pub fn get(&self) -> T {\n            // SAFETY: This can cause data races if called from a separate thread,\n            // but `Cell` is `!Sync` so this won't happen.\n            unsafe { *self.value.get() }\n        }\n    }\n\n    impl<T: Default> Cell<T> {\n        #[stable(feature = \"move_cell\", since = \"1.17.0\")]\n        pub fn take(&self) -> T {\n            self.replace(Default::default())\n        }\n    }\n    ```\n*/","span":{"file_name":"src/ch02/s6_paradigms.rs","byte_start":121473,"byte_end":126304,"line_start":12,"line_end":192,"column_start":1,"column_end":3}}]},{"kind":"Mod","id":{"krate":0,"index":67},"span":{"file_name":"src/ch02/s7_error_handle.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"s7_error_handle","qualname":"::ch02::s7_error_handle","value":"src/ch02/s7_error_handle.rs","parent":null,"children":[{"krate":0,"index":68},{"krate":0,"index":69},{"krate":0,"index":70}],"decl_id":null,"docs":" 第二章：Rust核心概念\n 2.6 错误处理\n \n 1. 类型系统保证函数契约\n 2. 断言用于防御\n 3. Option<T> 消除空指针失败\n 4. Result<T, E> 传播错误\n 5. Panic 恐慌崩溃\n \n","sig":null,"attributes":[{"value":"/ 第二章：Rust核心概念","span":{"file_name":"src/ch02/s7_error_handle.rs","byte_start":126393,"byte_end":126425,"line_start":1,"line_end":1,"column_start":1,"column_end":17}},{"value":"/ 2.6 错误处理","span":{"file_name":"src/ch02/s7_error_handle.rs","byte_start":126426,"byte_end":126446,"line_start":2,"line_end":2,"column_start":1,"column_end":13}},{"value":"/ ","span":{"file_name":"src/ch02/s7_error_handle.rs","byte_start":126447,"byte_end":126451,"line_start":3,"line_end":3,"column_start":1,"column_end":5}},{"value":"/ 1. 类型系统保证函数契约","span":{"file_name":"src/ch02/s7_error_handle.rs","byte_start":126452,"byte_end":126489,"line_start":4,"line_end":4,"column_start":1,"column_end":18}},{"value":"/ 2. 断言用于防御","span":{"file_name":"src/ch02/s7_error_handle.rs","byte_start":126490,"byte_end":126515,"line_start":5,"line_end":5,"column_start":1,"column_end":14}},{"value":"/ 3. Option<T> 消除空指针失败","span":{"file_name":"src/ch02/s7_error_handle.rs","byte_start":126516,"byte_end":126554,"line_start":6,"line_end":6,"column_start":1,"column_end":25}},{"value":"/ 4. Result<T, E> 传播错误","span":{"file_name":"src/ch02/s7_error_handle.rs","byte_start":126555,"byte_end":126587,"line_start":7,"line_end":7,"column_start":1,"column_end":25}},{"value":"/ 5. Panic 恐慌崩溃","span":{"file_name":"src/ch02/s7_error_handle.rs","byte_start":126588,"byte_end":126613,"line_start":8,"line_end":8,"column_start":1,"column_end":18}},{"value":"/ ","span":{"file_name":"src/ch02/s7_error_handle.rs","byte_start":126614,"byte_end":126618,"line_start":9,"line_end":9,"column_start":1,"column_end":5}}]},{"kind":"Function","id":{"krate":0,"index":68},"span":{"file_name":"src/ch02/s7_error_handle.rs","byte_start":127070,"byte_end":127082,"line_start":43,"line_end":43,"column_start":8,"column_end":20},"name":"elim_failure","qualname":"::ch02::s7_error_handle::elim_failure","value":"pub fn elim_failure()","parent":null,"children":[],"decl_id":null,"docs":"# 消除失败","sig":null,"attributes":[{"value":"*\n\n\n# 消除失败\n\n1. 类型系统保证函数契约\n\n```rust\nfn sum(a: i32, b: i32) -> i32 {\n    a + b\n}\nfn main() {\n    sum(1u32, 2u32); // 违反契约，报错\n}\n```\n\n2. 断言用于防御\n\n```rust\n\nfn extend_vec(v: &mut Vec<i32>, i: i32) {\n    assert!(v.len() == 5);\n    v.push(i);\n}\nfn main() {\n    let mut vec = vec![1, 2, 3];\n    extend_vec(&mut vec, 4);\n    extend_vec(&mut vec, 5);\n    extend_vec(&mut vec, 6); // panic!\n}\n```\n*/","span":{"file_name":"src/ch02/s7_error_handle.rs","byte_start":126620,"byte_end":127062,"line_start":11,"line_end":42,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":69},"span":{"file_name":"src/ch02/s7_error_handle.rs","byte_start":129847,"byte_end":129859,"line_start":167,"line_end":167,"column_start":8,"column_end":20},"name":"error_handle","qualname":"::ch02::s7_error_handle::error_handle","value":"pub fn error_handle()","parent":null,"children":[],"decl_id":null,"docs":"# 分层错误处理","sig":null,"attributes":[{"value":"*\n\n# 分层错误处理\n\n错误处理：顾名思义，处理错误。既然要处理错误，那肯定是指开发者可以处理的情况。\n\n-  Option: 「有」与「无」\n-  Result:「对」与「错」\n\n### Option\n\n```rust\nfn get_shortest(names: Vec<&str>) -> Option<&str> {\n    if names.len() > 0 {\n        let mut shortest = names[0];\n        for name in names.iter() {\n            if name.len() < shortest.len() {\n                shortest = *name;\n            }\n        }\n        Some(shortest)\n   } else {\n       None\n   }\n}\nfn show_shortest(names: Vec<&str>) -> &str {\n   match get_shortest(names) {\n       Some(shortest) => shortest,\n       None             => \"Not Found\",\n   }\n}\nfn main(){\n   assert_eq!(show_shortest(vec![\"Uku\", \"Felipe\"]), \"Uku\");\n   assert_eq!(show_shortest(Vec::new()), \"Not Found\");\n}\n```\n\n使用 Match 在 「盒内」处理 Option\n\n```rust\nfn get_shortest_length(names: Vec<&str>) -> Option<usize> {\n    match get_shortest(names) {\n        Some(shortest) => Some(shortest.len()),\n        None             => None,\n    }\n}\nfn main(){\n    assert_eq!(get_shortest_length(vec![\"Uku\",\"Felipe\"]),Some(3));\n    assert_eq!(get_shortest_length(Vec::new()), None);\n}\n```\n\n使用标准库内建组合子处理：\n\n```rust\nfn double(value: f64) -> f64 {\n    value * 2.\n}\nfn square(value: f64) -> f64 {\n    value.powi(2 as i32)\n}\nfn inverse(value: f64) -> f64 {\n    value * -1.\n}\nfn log(value: f64) -> Option<f64> {\n   match value.log2() {\n       x if x.is_normal() => Some(x),\n       _                      => None\n   }\n}\nfn sqrt(value: f64) -> Option<f64> {\n   match value.sqrt() {\n       x if x.is_normal() => Some(x),\n       _                      => None\n   }\n}\nfn main () {\n   let number: f64 = 20.;\n   let result = Option::from(number)\n       .map(inverse).map(double).map(inverse)\n       .and_then(log).map(square).and_then(sqrt);\n   match result {\n       Some(x) => println!(\"Result was {}.\", x),\n       None    => println!(\"This failed.\")\n   }\n}\n```\n\n\n### Result\n\n- Error trait:[https://doc.rust-lang.org/stable/std/error/trait.Error.html](https://doc.rust-lang.org/stable/std/error/trait.Error.html)\n- Result Error Handle : [read-sum crate]\n- `?` and [std::ops::Try](https://doc.rust-lang.org/stable/std/ops/trait.Try.html)\n\n\n\n\n```rust\nuse std::num::ParseIntError;\n// fn square(number_str: &str) -> Result<i32, ParseIntError>\n// {\n//    number_str.parse::<i32>().map(|n| n.pow(2))\n// }\ntype ParseResult<T> = Result<T, ParseIntError>;\nfn square(number_str: &str) -> ParseResult<i32>\n{\n    number_str.parse::<i32>().map(|n| n.pow(2))\n}\nfn main() {\n    match square(\"10\") {\n        Ok(n) => assert_eq!(n, 100),\n        Err(err) => println!(\"Error: {:?}\", err),\n    }\n}\n```\n\n\n*/","span":{"file_name":"src/ch02/s7_error_handle.rs","byte_start":127126,"byte_end":129839,"line_start":48,"line_end":166,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":70},"span":{"file_name":"src/ch02/s7_error_handle.rs","byte_start":132450,"byte_end":132467,"line_start":242,"line_end":242,"column_start":8,"column_end":25},"name":"panic_cant_handle","qualname":"::ch02::s7_error_handle::panic_cant_handle","value":"pub fn panic_cant_handle()","parent":null,"children":[],"decl_id":null,"docs":"### panic 的两种类型：","sig":null,"attributes":[{"value":"*\n\n### panic 的两种类型：\n\n- Unwinding（栈展开）。\n- Aborting（中止）。\n\nUnwinding 可以使应用程序线程以相对干净的方式关闭。 \n回收所有分配的系统资源，正确删除所有应用程序对象，依此类推。 \n此外，恐慌停止在有问题的线程的边界，而不是杀死整个应用程序过程。 \n所有这一切意味着，如果所有对象都具有明智的析构函数，则尽管有困难，但仍可以从紧急情况中恢复应用程序。\n\n如果你应用程序是为此目的而设计的，则可以检测到线程紧急情况并重新启动有问题的线程，希望该操作能够正确恢复。 \n在无法关闭应用程序的情况下，例如在关键系统中，类似于Erlang的容错方法可能是有意义的。\n\n对于Aborting，不存在应用程序恢复的可能性。一旦某些代码中止，应用程序进程将立即终止，这意味着要实现容错功能，就需要进行更加复杂的多进程设计。 \n另外，由于未运行资源析构函数，因此整个系统可能处于不一致状态，这意味着重新启动应用程序可能非常不容易。\n\n总而言之，仅应在确实不关心应用程序立即崩溃并可能破坏在崩溃过程中操作的任何硬件/操作系统状态的情况下启用Aborting恐慌。\n\n需要了解一个事实，Rust 目前对 OOM(out of memory)对处理是直接 Aborting ，无论你如何设置Panic类型。\n\n### 恐慌安全： \n\n[Rust Magazine #01 security](https://rustmagazine.github.io/rust_magazine_2021/chapter_1/rust_security_part1.html)\n- catch_unwind\n\n\n```rust\n\nuse std::panic;\nfn sum(a: i32, b: i32) -> i32{\n    a + b\n}\nfn main() {\n    let result = panic::catch_unwind(|| { println!(\"hello!\"); });\n    assert!(result.is_ok());\n    let result = panic::catch_unwind(|| { panic!(\"oh no!\"); });\n    assert!(result.is_err());\n   println!(\"{}\", sum(1, 2));\n}\n```\n\n使用 set_hook\n\n```rust\nuse std::panic;\nfn sum(a: i32, b: i32) -> i32{\n    a + b\n}\nfn main() {\n    let result = panic::catch_unwind(|| { println!(\"hello!\"); });\n    assert!(result.is_ok());\n    panic::set_hook(Box::new(|panic_info| {\n        if let Some(location) = panic_info.location() {\n            println!(\"panic occurred '{}' at {}\",\n                location.file(), location.line()\n            );\n       } else {\n            println!(\"can't get location information...\");\n       }\n   }));\n   let result = panic::catch_unwind(|| { panic!(\"oh no!\"); });\n   assert!(result.is_err());\n   println!(\"{}\", sum(1, 2));\n}\n```\n\n\n*/","span":{"file_name":"src/ch02/s7_error_handle.rs","byte_start":129897,"byte_end":132442,"line_start":172,"line_end":241,"column_start":1,"column_end":3}}]},{"kind":"Mod","id":{"krate":0,"index":71},"span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"s8_metaprogramming","qualname":"::ch02::s8_metaprogramming","value":"src/ch02/s8_metaprogramming.rs","parent":null,"children":[{"krate":0,"index":72},{"krate":0,"index":73},{"krate":0,"index":74},{"krate":0,"index":75}],"decl_id":null,"docs":" 第二章：Rust核心概念\n 2.7 元编程\n \n 内容包括：\n  - 反射\n  - 宏\n     - Rust 编译过程再解析\n     - 声明宏\n         - 标准库内置宏\n         - 自定义宏\n     - 过程宏\n         - bang 宏\n         - derive 宏\n         - 属性宏\n     - 过程宏实际项目的应用\n         - dervie_more\n         - metric\n         - reflect\n \n \n","sig":null,"attributes":[{"value":"/ 第二章：Rust核心概念","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132508,"byte_end":132540,"line_start":1,"line_end":1,"column_start":1,"column_end":17}},{"value":"/ 2.7 元编程","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132541,"byte_end":132558,"line_start":2,"line_end":2,"column_start":1,"column_end":12}},{"value":"/ ","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132559,"byte_end":132563,"line_start":3,"line_end":3,"column_start":1,"column_end":5}},{"value":"/ 内容包括：","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132564,"byte_end":132583,"line_start":4,"line_end":4,"column_start":1,"column_end":10}},{"value":"/  - 反射","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132584,"byte_end":132597,"line_start":5,"line_end":5,"column_start":1,"column_end":10}},{"value":"/  - 宏","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132598,"byte_end":132608,"line_start":6,"line_end":6,"column_start":1,"column_end":9}},{"value":"/     - Rust 编译过程再解析","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132609,"byte_end":132645,"line_start":7,"line_end":7,"column_start":1,"column_end":23}},{"value":"/     - 声明宏","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132646,"byte_end":132665,"line_start":8,"line_end":8,"column_start":1,"column_end":14}},{"value":"/         - 标准库内置宏","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132666,"byte_end":132698,"line_start":9,"line_end":9,"column_start":1,"column_end":21}},{"value":"/         - 自定义宏","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132699,"byte_end":132725,"line_start":10,"line_end":10,"column_start":1,"column_end":19}},{"value":"/     - 过程宏","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132726,"byte_end":132745,"line_start":11,"line_end":11,"column_start":1,"column_end":14}},{"value":"/         - bang 宏","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132746,"byte_end":132768,"line_start":12,"line_end":12,"column_start":1,"column_end":21}},{"value":"/         - derive 宏","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132769,"byte_end":132793,"line_start":13,"line_end":13,"column_start":1,"column_end":23}},{"value":"/         - 属性宏","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132794,"byte_end":132817,"line_start":14,"line_end":14,"column_start":1,"column_end":18}},{"value":"/     - 过程宏实际项目的应用","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132818,"byte_end":132858,"line_start":15,"line_end":15,"column_start":1,"column_end":21}},{"value":"/         - dervie_more","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132859,"byte_end":132884,"line_start":16,"line_end":16,"column_start":1,"column_end":26}},{"value":"/         - metric","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132885,"byte_end":132905,"line_start":17,"line_end":17,"column_start":1,"column_end":21}},{"value":"/         - reflect","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132906,"byte_end":132927,"line_start":18,"line_end":18,"column_start":1,"column_end":22}},{"value":"/ ","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132928,"byte_end":132932,"line_start":19,"line_end":19,"column_start":1,"column_end":5}},{"value":"/ ","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132933,"byte_end":132937,"line_start":20,"line_end":20,"column_start":1,"column_end":5}}]},{"kind":"Function","id":{"krate":0,"index":72},"span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":134847,"byte_end":134860,"line_start":115,"line_end":115,"column_start":8,"column_end":21},"name":"any_refection","qualname":"::ch02::s8_metaprogramming::any_refection","value":"pub fn any_refection()","parent":null,"children":[],"decl_id":null,"docs":"   # 动态自省","sig":null,"attributes":[{"value":"*\n   \n   # 动态自省\n\n   示例1:\n\n   [https://doc.rust-lang.org/std/any/index.html](https://doc.rust-lang.org/std/any/index.html)\n\n    示例2:\n\n    ```rust\n\n    use std::any::Any;\n\n    trait Foo: Any {\n        fn as_any(&self) -> &Any;\n    }\n\n    impl<T: Any> Foo for T {\n        fn as_any(&self) -> &Any {\n            self\n        }\n    }\n\n    struct Bar {}\n\n    struct Baz {}\n\n    impl PartialEq for Foo {\n        fn eq(&self, other: &Foo) -> bool {\n            let me = self.as_any();\n            let you = other.as_any();\n            if me.is::<Bar>() && you.is::<Bar>() {\n                true\n            } else if me.is::<Baz>() && you.is::<Baz>() {\n                true\n            } else {\n                false\n            }\n        }\n    }\n\n    fn main() {\n        let bar: Bar = Bar {};\n        let baz: Baz = Baz {};\n        let foo1: &Foo = &bar;\n        let foo2: &Foo = &baz;\n        println!(\"{:?}\", foo1 == foo2);\n    }\n\n    ```\n\n    示例 3:\n\n    ```rust\n        use std::any::Any;\n        struct UnStatic<'a> { x: &'a i32 }\n        fn main() {\n            let a = 42;\n            let v = UnStatic { x: &a };\n            let mut any: &Any;\n            //any = &v;  // Compile Error!\n        }\n    ```\n    \n    修正：\n\n    ```rust\n    use std::any::Any;\n    struct UnStatic<'a> { x: &'a i32 }\n    static ANSWER: i32 = 42;\n    fn main() {\n        let v = UnStatic { x: &ANSWER };\n        let mut a: &Any;\n        a = &v;\n        assert!(a.is::<UnStatic>());\n    }\n    ```\n\n    示例4:\n\n    oso 库应用\n\n    [https://github.com/osohq/oso/blob/main/languages/rust/oso/src/host/class.rs](https://github.com/osohq/oso/blob/main/languages/rust/oso/src/host/class.rs)\n\n    示例 5:\n\n    bevy_reflect 库应用\n\n    [https://github.com/bevyengine/bevy/blob/main/crates/bevy_reflect/src/lib.rs](https://github.com/bevyengine/bevy/blob/main/crates/bevy_reflect/src/lib.rs)\n\n */","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":132940,"byte_end":134839,"line_start":23,"line_end":114,"column_start":1,"column_end":4}}]},{"kind":"Function","id":{"krate":0,"index":73},"span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":139027,"byte_end":139045,"line_start":312,"line_end":312,"column_start":8,"column_end":26},"name":"declarative_macros","qualname":"::ch02::s8_metaprogramming::declarative_macros","value":"pub fn declarative_macros()","parent":null,"children":[],"decl_id":null,"docs":"  # 声明宏","sig":null,"attributes":[{"value":"*\n  # 声明宏\n\n  宏展开命令： cargo rustc -- -Z unstable-options --pretty=expanded\n\n  示例1:\n\n  ```rust\n    macro_rules! unless {\n        ($arg:expr, $branch:expr) => ( if !$arg { $branch };); \n    } \n    fn cmp(a: i32, b: i32) {\n        unless!( a > b, {\n            println!(\"{} < {}\", a, b);\n        });\n    }\n    fn main() {\n        let (a, b) = (1, 2);\n        cmp(a, b);\n    }\n  ```\n\n  支持 token 类型：\n\n  ```text\n        item — an item, like a function, struct, module, etc.\n        block — a block (i.e. a block of statements and/or an expression, surrounded by braces)\n        stmt — a statement\n        pat — a pattern\n        expr — an expression\n        ty — a type\n        ident — an identifier\n        path — a path (e.g., foo, ::std::mem::replace, transmute::<_, int>, …)\n        meta — a meta item; the things that go inside #[...] and #![...] attributes\n        tt — a single token tree\n        vis — a possibly empty Visibility qualifier\n  ```\n\n\n  示例2:\n\n  ```rust\n\n    macro_rules! hashmap {\n        ($($key:expr => $value:expr),* ) => {\n            {\n                let mut _map = ::std::collections::HashMap::new();\n                $(  \n                    _map.insert($key, $value); \n                )*\n                _map\n            }\n        };\n    }\n    fn main(){\n        let map = hashmap!{\n            \"a\" => 1,\n            \"b\" => 2\n        //  \"c\" => 3, // V1.0不支持结尾有逗号\n        };\n        assert_eq!(map[\"a\"], 1);\n    }\n\n  ```\n\n  示例3:\n\n  ```rust\n    macro_rules! hashmap {\n        ($($key:expr => $value:expr,)*) =>\n            {  hashmap!($($key => $value),*) };\n        ($($key:expr => $value:expr),* ) => {\n            {\n                let mut _map = ::std::collections::HashMap::new();\n                $(\n                    _map.insert($key, $value);\n                )*\n            _map\n        }\n    };\n    }\n    fn main(){\n        let map = hashmap!{\n            \"a\" => 1,\n            \"b\" => 2,\n            \"c\" => 3, \n        };\n        assert_eq!(map[\"a\"], 1);\n    }\n  ```\n\n  示例4:\n\n  ```rust\n    macro_rules! hashmap {\n        ($($key:expr => $value:expr),* $(,)*) => {\n            {\n                let mut _map = ::std::collections::HashMap::new();\n                $(\n                    _map.insert($key, $value);\n                )*\n                _map\n            }\n    };\n    }\n    fn main(){\n        let map = hashmap!{\n            \"a\" => 1,\n            \"b\" => 2,\n            \"c\" => 3, \n        };\n        assert_eq!(map[\"a\"], 1);\n    }\n\n  ```\n\n  示例5:\n\n  ```rust\n    macro_rules! unit {\n        ($($x:tt)*) => (());\n    }\n    macro_rules! count {\n        ($($key:expr),*) => (<[()]>::len(&[$(unit!($key)),*]));\n    }\n    macro_rules! hashmap {\n        ($($key:expr => $value:expr),* $(,)*) => {\n            {\n            let _cap = count!($($key),*);\n            let mut _map \n                = ::std::collections::HashMap::with_capacity(_cap);\n            $(\n                _map.insert($key, $value);\n            )*\n            _map\n        }\n    };\n    }\n    fn main(){\n        let map = hashmap!{\n            \"a\" => 1,\n            \"b\" => 2,\n            \"c\" => 3, \n        };\n        assert_eq!(map[\"a\"], 1);\n    }\n\n  ```\n\n  示例6: \n\n  ```rust\n    macro_rules! hashmap {\n        (@unit $($x:tt)*) => (());\n        (@count $($rest:expr),*) => \n            (<[()]>::len(&[$(hashmap!(@unit $rest)),*]));\n        ($($key:expr => $value:expr),* $(,)*) => {\n            {\n                let _cap = hashmap!(@count $($key),*);\n                let mut _map = \n                    ::std::collections::HashMap::with_capacity(_cap);\n            $(\n                _map.insert($key, $value);\n            )*\n            _map\n        }\n    };\n    }\n    fn main(){\n    let map = hashmap!{\n        \"a\" => 1,\n        \"b\" => 2,\n        \"c\" => 3, \n    };\n    assert_eq!(map[\"a\"], 1);\n    }\n  ```\n\n  示例7:\n\n  ```rust\n    macro_rules! sum {\n        ($e:expr) => ({\n            let a = 2;\n            $e + a\n        })\n    }\n    fn main(){\n        // error[E0425]: cannot find value `a` in this scope\n        let four = sum!(a);\n    }\n  ```\n*/","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":134868,"byte_end":139019,"line_start":119,"line_end":311,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":74},"span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":142063,"byte_end":142081,"line_start":425,"line_end":425,"column_start":8,"column_end":26},"name":"derive_proc_macros","qualname":"::ch02::s8_metaprogramming::derive_proc_macros","value":"pub fn derive_proc_macros()","parent":null,"children":[],"decl_id":null,"docs":"介绍：[serde.rs](https://serde.rs/)","sig":null,"attributes":[{"value":"*\n\n介绍：[serde.rs](https://serde.rs/)\n\n参阅 :  [https://github.com/ZhangHanDong/proc_codegen](https://github.com/ZhangHanDong/proc_codegen)\n\n过程宏三件套：\n\n- [syn](https://github.com/dtolnay/syn)\n- [quote](https://github.com/dtolnay/quote)\n- [proc-macro2](https://github.com/alexcrichton/proc-macro2)\n\n示例：封装 Diesel 方便 crud\n\n```rust\n\n    // find_by_or!{ Person -> people::[name:String || company_name:String]   }\n\n    use super::*;\n\n    pub struct DbOpByOrBy {\n        pub model: Type,\n        pub table: Ident,\n        pub bracket_token: token::Bracket,\n        pub content: FieldContentOr,\n    }\n\n    pub struct FieldContentOr {\n        pub name1: Ident,\n        pub ty1: Type,\n        pub name2: Ident,\n        pub ty2: Type,\n    }\n\n    impl Parse for DbOpByOrBy {\n        fn parse(input: ParseStream) -> Result<Self> {\n            let content;\n            let model: Type = input.parse()?;\n            input.parse::<Token![->]>()?;\n            let table: Ident = input.parse()?;\n            input.parse::<Token![::]>()?;\n            let bracket_token = bracketed!(content in input);\n            let content = content.parse()?;\n            Ok(DbOpByOrBy {\n                model,\n                table,\n                bracket_token,\n                content,\n            })\n        }\n    }\n\n    impl Parse for FieldContentOr {\n        fn parse(input: ParseStream) -> Result<Self> {\n            let name1: Ident = input.parse()?;\n            input.parse::<Token![:]>()?;\n            let ty1: Type = input.parse()?;\n            input.parse::<Token![||]>()?;\n            let name2: Ident = input.parse()?;\n            input.parse::<Token![:]>()?;\n            let ty2: Type = input.parse()?;\n            Ok(FieldContentOr {\n                name1,\n                ty1,\n                name2,\n                ty2,\n            })\n        }\n    }\n\n    // in lib.rs\n\n    // find_by_or!{ Person -> people::[name:String || company_name:String]   }\n\n    #[proc_macro]\n    pub fn find_by_or(input: TokenStream) -> TokenStream {\n        let DbOpByOrBy {\n            model,\n            table,\n            bracket_token,\n            content,\n        } = parse_macro_input!(input as DbOpByOrBy);\n        let (name1, name2) = (content.name1, content.name2);\n        let (ty1, ty2) = (content.ty1, content.ty2);\n        let fn_name = format!(\"find_by_{}_or_{}\", name1, name2);\n        let fn_name = Ident::new(&fn_name, proc_macro2::Span::call_site());\n\n        let expanded = quote! {\n            impl #model {\n                pub fn #fn_name(conn: &PgConnection, #name1: #ty1, #name2: #ty2) -> QueryResult<#model> {\n                    #table::table\n                    .filter(#table::dsl::#name1.eq(#name1))\n                    .or_filter(#table::dsl::#name2.eq(#name2))\n                    .get_result(conn)\n                }\n            }\n        };\n        TokenStream::from(expanded)\n    }\n\n\n```\n\n有用的第三方库：\n\n- [derive_more](https://github.com/JelteF/derive_more)\n\n*/","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":139054,"byte_end":142055,"line_start":317,"line_end":424,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":75},"span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":142353,"byte_end":142375,"line_start":441,"line_end":441,"column_start":8,"column_end":30},"name":"attributes_proc_macros","qualname":"::ch02::s8_metaprogramming::attributes_proc_macros","value":"pub fn attributes_proc_macros()","parent":null,"children":[],"decl_id":null,"docs":"    # 属性宏","sig":null,"attributes":[{"value":"*\n\n    # 属性宏\n\n    案例：[magnet/metered-rs](https://github.com/magnet/metered-rs)\n\n    有用的第三方库介绍：[darling](https://github.com/TedDriggs/darling)\n\n    案例： [elichai/log-derive](https://github.com/elichai/log-derive)\n \n\n*/","span":{"file_name":"src/ch02/s8_metaprogramming.rs","byte_start":142089,"byte_end":142345,"line_start":429,"line_end":440,"column_start":1,"column_end":3}}]},{"kind":"Mod","id":{"krate":0,"index":76},"span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"s9_unsafe_rust","qualname":"::ch02::s9_unsafe_rust","value":"src/ch02/s9_unsafe_rust.rs","parent":null,"children":[{"krate":0,"index":77},{"krate":0,"index":78},{"krate":0,"index":79}],"decl_id":null,"docs":" 第二章：Rust核心概念\n 2.8 Unsafe Rust\n \n 内容包括：\n \n - 什么是 Unsafe Rust ？\n     \n - Unsafe Rust 安全抽象\n     - drop 检查\n     - Unbound Lifetime\n     - 型变\n \n - 标准库 [LinkedList 源码](https://doc.rust-lang.org/stable/src/alloc/collections/linked_list.rs.html#38-43)导读","sig":null,"attributes":[{"value":"/ 第二章：Rust核心概念","span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":142380,"byte_end":142412,"line_start":1,"line_end":1,"column_start":1,"column_end":17}},{"value":"/ 2.8 Unsafe Rust","span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":142413,"byte_end":142432,"line_start":2,"line_end":2,"column_start":1,"column_end":20}},{"value":"/ ","span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":142433,"byte_end":142437,"line_start":3,"line_end":3,"column_start":1,"column_end":5}},{"value":"/ 内容包括：","span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":142438,"byte_end":142457,"line_start":4,"line_end":4,"column_start":1,"column_end":10}},{"value":"/ ","span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":142458,"byte_end":142462,"line_start":5,"line_end":5,"column_start":1,"column_end":5}},{"value":"/ - 什么是 Unsafe Rust ？","span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":142463,"byte_end":142494,"line_start":6,"line_end":6,"column_start":1,"column_end":24}},{"value":"/     ","span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":142495,"byte_end":142503,"line_start":7,"line_end":7,"column_start":1,"column_end":9}},{"value":"/ - Unsafe Rust 安全抽象","span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":142504,"byte_end":142534,"line_start":8,"line_end":8,"column_start":1,"column_end":23}},{"value":"/     - drop 检查","span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":142535,"byte_end":142556,"line_start":9,"line_end":9,"column_start":1,"column_end":18}},{"value":"/     - Unbound Lifetime","span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":142557,"byte_end":142583,"line_start":10,"line_end":10,"column_start":1,"column_end":27}},{"value":"/     - 型变","span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":142584,"byte_end":142600,"line_start":11,"line_end":11,"column_start":1,"column_end":13}},{"value":"/ ","span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":142601,"byte_end":142605,"line_start":12,"line_end":12,"column_start":1,"column_end":5}},{"value":"/ - 标准库 [LinkedList 源码](https://doc.rust-lang.org/stable/src/alloc/collections/linked_list.rs.html#38-43)导读","span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":142606,"byte_end":142729,"line_start":13,"line_end":13,"column_start":1,"column_end":110}},{"value":"/","span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":142730,"byte_end":142733,"line_start":14,"line_end":14,"column_start":1,"column_end":4}},{"value":"/  - Unsafe 工具集介绍","span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":142734,"byte_end":142763,"line_start":15,"line_end":15,"column_start":1,"column_end":20}}]},{"kind":"Function","id":{"krate":0,"index":77},"span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":145117,"byte_end":145129,"line_start":86,"line_end":86,"column_start":8,"column_end":20},"name":"unsafe_intro","qualname":"::ch02::s9_unsafe_rust::unsafe_intro","value":"pub fn unsafe_intro()","parent":null,"children":[],"decl_id":null,"docs":"    # Unsafe Rust 介绍","sig":null,"attributes":[{"value":"*\n\n    # Unsafe Rust 介绍\n\n    示例1: Unsafe Rust 是 Safe Rust 的超集\n\n    ```rust\n        fn main(){\n            unsafe {\n                let mut a = \"hello\";\n                let b = &a;\n                let c = &mut a;\n            }\n        }\n    ```\n\n  Unsafe Rust是指，在进行以下五种操作的时候，并不会提供任何安全检查：\n\n    - 解引用裸指针。\n    - 调用unsafe的函数或方法。\n    - 访问或修改可变静态变量。\n    - 实现unsafe trait。\n    - 读写Union联合体中的字段。\n\n    解引用裸指针\n\n    - Rust提供了*const T（不变）和*mut T（可变）两种指针类型。因为这两种指针和C语言中的指针十分相近，所以叫其原生指针（Raw Pointer）。\n    \n    原生指针具有以下特点：\n    - 并不保证指向合法的内存。比如很可能是一个空指针。\n    - 不能像智能指针那样自动清理内存。需要像C语言那样手动管理内存。\n    - 没有生命周期的概念，也就是说，编译器不会对其提供借用检查。\n    - 不能保证线程安全。\n\n     可见，原生指针并不受Safe Rust提供的那一层“安全外衣”保护，所以也被称为“裸指针”。所以，在对裸指针进行解引用操作的时候，属于不安全行为。\n\n\n    Unsafe语法  \n\n    通过unsafe关键字和unsafe块就可以使用Unsafe Rust，它们的作用如下：\n\n    - unsafe关键字，用于标记（或者说声明）函数、方法和trait。\n    - unsafe块，用于执行Unsafe Rust允许的五种操作。\n\n    查看标准库String中的 unsafe 函数[from_utf8_unchecked](https://doc.rust-lang.org/stable/std/str/fn.from_utf8_unchecked.html)，看看为什么是Unsafe的。\n\n    这里最大的风险在于，如果一个函数存在违反“契约”的风险，而开发者并没有使用unsafe关键字将其标记，那该函数就很可能会成为Bug的温床。\n    被unsafe关键字标记的不安全函数或方法，只能在unsafe块中被调用。\n\n    \n\n    示例2:\n\n    ```rust\n    static mut COUNTER: u32 = 0;\n    fn main() {\n        let inc = 3;\n        unsafe {\n            COUNTER += inc;\n            println!(\"COUNTER: {}\", COUNTER);\n        }\n    }\n    ```\n\n    Safe Rust 是基于很多 Unsafe Rust 实现的，那么 Safe Rust 凭什么 Safe ？\n\n*/","span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":142767,"byte_end":145109,"line_start":19,"line_end":85,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":78},"span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":157331,"byte_end":157348,"line_start":584,"line_end":584,"column_start":8,"column_end":25},"name":"security_abstract","qualname":"::ch02::s9_unsafe_rust::security_abstract","value":"pub fn security_abstract()","parent":null,"children":[],"decl_id":null,"docs":"    # 安全抽象","sig":null,"attributes":[{"value":"*\n\n    # 安全抽象\n\n    什么叫安全抽象？ 最简单的示例：\n\n    ```rust\n    fn unbound_lifetime_foo<'a>(input: *const u32) -> &'a u32 {\n        unsafe {\n            return &*input\n        }\n    }\n\n    fn normal_foo<'a>(input: &'a u32) -> &'a u32 {\n        &input\n        \n    }\n\n    fn main() {\n        let x;\n        { // -----------------------------------------------------------------------------------  `y` lifetime start\n            // unbound lifetime broken lifetime\n            let y = 7;\n            x = unbound_lifetime_foo(&y);\n            \n            // normal lifetime will error: error[E0597]: `y` does not live long enough\n            // let y = 8;\n            // x = normal_foo(&y);\n        } // ----------------------------------------------------------------------------------- `y` lifetime end\n        println!(\"hello: {}\", x);\n    }\n    ```\n\n    示例2:\n\n    ```rust\n    pub fn insert(&mut self, index: usize, element: T) {\n        let len = self.len();\n        // 通过该断言保证了数组不能越界\n        assert!(index <= len);\n        // 通过判断长度是否达到容量极限来决定是否进行扩容\n        if len == self.buf.cap() {\n            self.reserve(1);\n        }\n        unsafe {\n            {\n                let p = self.as_mut_ptr().offset(index as isize);\n                ptr::copy(p, p.offset(1), len - index);\n                ptr::write(p, element);\n            }\n            self.set_len(len + 1);\n        }\n    }\n    ```\n\n\n    ### Drop check \n    \n    示例1：正常的drop check\n\n    ```rust\n    #![allow(unused)]\n    #![allow(unused)]\n    #![feature(alloc_layout_extra)]\n    #![feature(dropck_eyepatch)]\n    use std::alloc::{GlobalAlloc, Layout, System};\n    use std::fmt;\n    use std::marker::PhantomData;\n    use std::mem;\n    use std::ptr;\n\n    #[derive(Copy, Clone, Debug)]\n\n    enum State {\n        InValid,\n        Valid,\n    }\n\n    #[derive(Debug)]\n    struct Hello<T: fmt::Debug>(&'static str, T, State);\n    impl<T: fmt::Debug> Hello<T> {\n        fn new(name: &'static str, t: T) -> Self {\n            Hello(name, t, State::Valid)\n        }\n    }\n    impl<T: fmt::Debug> Drop for Hello<T> {\n        fn drop(&mut self) {\n            println!(\"drop Hello({}, {:?}, {:?})\", self.0, self.1, self.2);\n            self.2 = State::InValid;\n        }\n    }\n    struct WrapBox<T> {\n        v: Box<T>,\n    }\n    impl<T> WrapBox<T> {\n        fn new(t: T) -> Self {\n            WrapBox { v: Box::new(t) }\n        }\n    }\n    fn f1() {\n        let x;\n        let y;\n        x = Hello::new(\"x\", 13);\n        y = WrapBox::new(Hello::new(\"y\", &x));\n    }\n\n    struct MyBox<T> {\n        v: *const T,\n    }\n    impl<T> MyBox<T> {\n        fn new(t: T) -> Self {\n            unsafe {\n                let p = System.alloc(Layout::array::<T>(1).unwrap());\n                let p = p as *mut T;\n                ptr::write(p, t);\n                MyBox {\n                    v: p, \n                }\n            }\n        }\n    }\n\n\n    impl< T> Drop for MyBox<T> {\n        fn drop(&mut self) {\n            unsafe {\n                let p = self.v as *mut _;\n                System.dealloc(p, Layout::array::<T>(mem::align_of::<T>()).unwrap());\n            }\n        }\n    }\n\n\n    fn f2() {\n        {\n            let (x1, y1);\n            x1 = Hello::new(\"x1\", 13);\n            y1 = MyBox::new(Hello::new(\"y1\", &x1));\n        }\n        {\n            let (y2,x2 ); // 此处交换，会报错，注意编译错误\n            x2 = Hello::new(\"x2\", 13);\n            y2 = MyBox::new(Hello::new(\"y2\", &x2));\n        }\n    }\n\n    fn main() {\n        f1();\n        f2();\n    }\n\n    ```\n\n    使用 改进：\n\n    ```rust\n    #![allow(unused)]\n    #![allow(unused)]\n    #![feature(alloc_layout_extra)]\n    #![feature(dropck_eyepatch)]\n    use std::alloc::{GlobalAlloc, Layout, System};\n    use std::fmt;\n    use std::marker::PhantomData;\n    use std::mem;\n    use std::ptr;\n\n    #[derive(Copy, Clone, Debug)]\n\n    enum State {\n        InValid,\n        Valid,\n    }\n\n    #[derive(Debug)]\n    struct Hello<T: fmt::Debug>(&'static str, T, State);\n    impl<T: fmt::Debug> Hello<T> {\n        fn new(name: &'static str, t: T) -> Self {\n            Hello(name, t, State::Valid)\n        }\n    }\n    impl<T: fmt::Debug> Drop for Hello<T> {\n        fn drop(&mut self) {\n            println!(\"drop Hello({}, {:?}, {:?})\", self.0, self.1, self.2);\n            self.2 = State::InValid;\n        }\n    }\n    struct WrapBox<T> {\n        v: Box<T>,\n    }\n    impl<T> WrapBox<T> {\n        fn new(t: T) -> Self {\n            WrapBox { v: Box::new(t) }\n        }\n    }\n    fn f1() {\n        let x;\n        let y;\n        x = Hello::new(\"x\", 13);\n        y = WrapBox::new(Hello::new(\"y\", &x));\n    }\n\n    struct MyBox<T> {\n        v: *const T,\n    }\n    impl<T> MyBox<T> {\n        fn new(t: T) -> Self {\n            unsafe {\n                let p = System.alloc(Layout::array::<T>(1).unwrap());\n                let p = p as *mut T;\n                ptr::write(p, t);\n                MyBox {\n                    v: p, \n                }\n            }\n        }\n    }\n\n\n    unsafe impl<#[may_dangle] T> Drop for MyBox<T> {\n        fn drop(&mut self) {\n            unsafe {\n                let p = self.v as *mut _;\n                System.dealloc(p, Layout::array::<T>(mem::align_of::<T>()).unwrap());\n            }\n        }\n    }\n\n    fn f2() {\n        {\n            let (x1, y1);\n            x1 = Hello::new(\"x1\", 13);\n            y1 = MyBox::new(Hello::new(\"y1\", &x1));\n        }\n        {\n            let (y2,x2 ); // 此处改变\n            x2 = Hello::new(\"x2\", 13);\n            y2 = MyBox::new(Hello::new(\"y2\", &x2));\n        }\n    }\n\n    fn main() {\n        f1();\n        f2();\n    }\n\n    ```\n\n    使用 PhantomData 防止出现 UB:\n\n    ```rust\n    #![allow(unused)]\n    #![allow(unused)]\n    #![feature(alloc_layout_extra)]\n    #![feature(dropck_eyepatch)]\n    use std::alloc::{GlobalAlloc, Layout, System};\n    use std::fmt;\n    use std::marker::PhantomData;\n    use std::mem;\n    use std::ptr;\n\n    #[derive(Copy, Clone, Debug)]\n\n    enum State {\n        InValid,\n        Valid,\n    }\n\n    #[derive(Debug)]\n    struct Hello<T: fmt::Debug>(&'static str, T, State);\n    impl<T: fmt::Debug> Hello<T> {\n        fn new(name: &'static str, t: T) -> Self {\n            Hello(name, t, State::Valid)\n        }\n    }\n    impl<T: fmt::Debug> Drop for Hello<T> {\n        fn drop(&mut self) {\n            println!(\"drop Hello({}, {:?}, {:?})\", self.0, self.1, self.2);\n            self.2 = State::InValid;\n        }\n    }\n    struct WrapBox<T> {\n        v: Box<T>,\n    }\n    impl<T> WrapBox<T> {\n        fn new(t: T) -> Self {\n            WrapBox { v: Box::new(t) }\n        }\n    }\n    fn f1() {\n        let x;\n        let y;\n        x = Hello::new(\"x\", 13);\n        y = WrapBox::new(Hello::new(\"y\", &x));\n    }\n\n    struct MyBox<T> {\n        v: *const T,\n        // _pd: PhantomData<T>,\n    }\n    impl<T> MyBox<T> {\n        fn new(t: T) -> Self {\n            unsafe {\n                let p = System.alloc(Layout::array::<T>(1).unwrap());\n                let p = p as *mut T;\n                ptr::write(p, t);\n                MyBox {\n                    v: p, \n                    // _pd: Default::default()\n                }\n            }\n        }\n    }\n\n\n    unsafe impl<#[may_dangle] T> Drop for MyBox<T> {\n        fn drop(&mut self) {\n            unsafe {\n                ptr::read(self.v); // 此处新增，出现UB (use after free,UAF)\n                let p = self.v as *mut _;\n                System.dealloc(p, Layout::array::<T>(mem::align_of::<T>()).unwrap());\n            }\n        }\n    }\n\n    fn f2() {\n        {\n            let (x1, y1);\n            x1 = Hello::new(\"x1\", 13);\n            y1 = MyBox::new(Hello::new(\"y1\", &x1));\n        }\n        {\n            let (y2,x2 ); // 此处改变\n            x2 = Hello::new(\"x2\", 13);\n            y2 = MyBox::new(Hello::new(\"y2\", &x2));\n        }\n    }\n\n    fn main() {\n        f1();\n        f2();\n    }\n\n    ```\n\n\n\n    示例：型变\n\n    在一门程序设计语言的类型系统中，一个类型规则或者类型构造器是：\n\n    - 协变（covariant），如果它保持了子类型序关系≦。该序关系是：子类型≦基类型。\n    - 逆变（contravariant），如果它逆转了子类型序关系。\n    - 不变（invariant），如果上述两种均不适用。\n\n    Rust 里唯一的类型父子关系是生命周期：`'a: 'b` 。比如，`'static: 'a` ，并且默认都是协变，唯一逆变的地方在 `fn(T)`\n\n    `'static: 'a` 对应： `子类型: 父类型`。\n\n    - 协变： 能用 'a 的地方，也可以用 'static。\n    - 逆变： 能用 'static 的地方，可以可以用 'a。\n\n    规则：\n\n    PhantomData规则：\n\n    - PhantomData，在T上是协变。 \n    - PhantomData<&'a T>，在'a 和T上是协变。 \n    - PhantomData<&'a mut T>，在'a上是协变，在T上是不变。 \n    - PhantomData<*const T>，在T上是协变。 \n    - PhantomData<*mut T>，在T上不变。 \n    - PhantomData<fn(T)>，在T上是逆变，如果以后语法修改的话，会成为不变。 \n    - PhantomData<fn() -> T>，在T上是协变。 \n    - PhantomData<fn(T) -> T>，在T上是不变。 \n    - PhantomData<Cell<&'a ()>>，在'a上是不变。\n\n    ```rust\n    // 协变类型\n    struct MyCell<T> {\n        value: T,\n    }\n    impl<T: Copy> MyCell<T> {\n        fn new(x: T) -> MyCell<T> {\n            MyCell { value: x }\n        }\n        fn get(&self) -> T {\n            self.value\n    }\n    fn set(&self, value: T) {\n        use std::ptr;\n        unsafe {\n            ptr::write(&self.value as *const _ as *mut _, value);\n        }\n    }\n    }\n\n    fn step1<'a>(r_c1: &MyCell<&'a i32>) {\n        let val: i32 = 13;\n        step2(&val, r_c1); // step2函数执行完再回到step1\n        println!(\"step1 value: {}\", r_c1.value);\n    } // step1调用完，栈帧将被清理，val将不复存在，&val将成为悬垂指针\n\n    fn step2<'b>(r_val: &'b i32, r_c2: &MyCell<&'b i32>) {\n        r_c2.set(r_val);\n    }\n    static X: i32 = 10;\n    fn main() {\n    let cell = MyCell::new(&X);\n    step1(&cell);\n    println!(\"  end value: {}\", cell.value); //此处 cell.value的值将无法预期，UB风险\n    }\n\n    ```\n\n    Basic usage: 修改MyCell 类型为不变\n\n    解决上面示例UB的问题，编译将报错，因为安全检查生效了，成功阻止了UB风险\n\n    ```rust\n    use std::marker::PhantomData;\n    struct MyCell<T> {\n        value: T,\n        mark: PhantomData<fn(T)> , //通过PhantomData<fn(T)>将MyCell<T>改为逆变类型\n    }\n    impl<T: Copy> MyCell<T> {\n        fn new(x: T) -> MyCell<T> {\n            MyCell { value: x , mark: PhantomData}\n        }\n    fn get(&self) -> T {\n        self.value\n    }\n    fn set(&self, value: T) {\n        use std::ptr;\n        unsafe {\n            ptr::write(&self.value as *const _ as *mut _, value);\n        }\n    }\n    }\n    fn step1<'a>(r_c1: &MyCell<&'a i32>) {\n        let val: i32 = 13;\n        step2(&val, r_c1); // error[E0597]: `val` does not live long enough\n        println!(\"step1 value: {}\", r_c1.value);\n    } // step1调用完，栈帧将被清理，val将不复存在，&val将成为悬垂指针\n\n    fn step2<'b>(r_val: &'b i32, r_c2: &MyCell<&'b i32>) {\n        r_c2.set(r_val);\n    }\n    static X: i32 = 10;\n    fn main() {\n        let cell = MyCell::new(&X);\n        step1(&cell);\n        println!(\"  end value: {}\", cell.value);\n    }\n    ```\n    \n    示例：逆变\n\n    ```rust\n    #![allow(unused)]\n    trait A {\n        fn foo(&self, s: &'static str);\n    }\n    struct B;\n    impl A for B {\n        fn foo(&self, s: &str){\n            println!(\"{:?}\", s);\n        }\n    }\n    impl B{\n    fn foo2(&self, s: &'static str){\n        println!(\"{:?}\", s);\n    }\n    }\n    fn main() {\n        B.foo(\"hello\");\n        let s = \"hello\".to_string();\n        B.foo2(&s)\n    }\n\n    ```\n\n    示例2:\n\n    ```rust\n    fn foo(input: &str)  {\n        println!(\"{:?}\", input);               \n    }\n    fn bar(f: fn(&'static str), v: &'static str) {\n        (f)(v);\n    }\n    fn main(){\n        let v : &'static str = \"hello\";\n        bar(foo, v);\n    }\n    ```\n\n*/","span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":145135,"byte_end":157323,"line_start":88,"line_end":583,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":79},"span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":157962,"byte_end":157969,"line_start":598,"line_end":598,"column_start":8,"column_end":15},"name":"nonnull","qualname":"::ch02::s9_unsafe_rust::nonnull","value":"pub fn nonnull()","parent":null,"children":[],"decl_id":null,"docs":"    # 其他介绍","sig":null,"attributes":[{"value":"*\n\n    # 其他介绍\n\n    - [NonNull](https://doc.rust-lang.org/nightly/std/ptr/struct.NonNull.html)\n    - [Play](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2015&gist=d95a1c5ec1a8c4279f366bb044ad6202)\n    - [LinkedList](https://doc.rust-lang.org/nightly/src/alloc/collections/linked_list.rs.html#39-44)\n    - [MaybeUninit](https://doc.rust-lang.org/std/mem/union.MaybeUninit.html)\n    - 推荐阅读：[Unsafe Rust: How and when (not) to use it](https://blog.logrocket.com/unsafe-rust-how-and-when-not-to-use-it/)\n    - [rustsec advisories](https://rustsec.org/advisories/)\n*/","span":{"file_name":"src/ch02/s9_unsafe_rust.rs","byte_start":157355,"byte_end":157954,"line_start":587,"line_end":597,"column_start":1,"column_end":3}}]},{"kind":"Mod","id":{"krate":0,"index":80},"span":{"file_name":"src/ch03/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"ch03","qualname":"::ch03","value":"src/ch03/mod.rs","parent":null,"children":[{"krate":0,"index":81},{"krate":0,"index":87},{"krate":0,"index":90}],"decl_id":null,"docs":" 第三章：Rust 异步编程概念","sig":null,"attributes":[{"value":"/ 第三章：Rust 异步编程概念","span":{"file_name":"src/ch03/mod.rs","byte_start":157974,"byte_end":158013,"line_start":1,"line_end":1,"column_start":1,"column_end":20}},{"value":"/","span":{"file_name":"src/ch03/mod.rs","byte_start":158014,"byte_end":158017,"line_start":2,"line_end":2,"column_start":1,"column_end":4}},{"value":"/ 本章至下而上的方式来带领大家理解异步编程:","span":{"file_name":"src/ch03/mod.rs","byte_start":158018,"byte_end":158083,"line_start":3,"line_end":3,"column_start":1,"column_end":26}},{"value":"/ ","span":{"file_name":"src/ch03/mod.rs","byte_start":158084,"byte_end":158088,"line_start":4,"line_end":4,"column_start":1,"column_end":5}},{"value":"/ 1. 异步 I/O 模型","span":{"file_name":"src/ch03/mod.rs","byte_start":158089,"byte_end":158113,"line_start":5,"line_end":5,"column_start":1,"column_end":17}},{"value":"/ 2. 异步编程模型：","span":{"file_name":"src/ch03/mod.rs","byte_start":158114,"byte_end":158142,"line_start":6,"line_end":6,"column_start":1,"column_end":15}},{"value":"/     - 事件驱动模型","span":{"file_name":"src/ch03/mod.rs","byte_start":158143,"byte_end":158171,"line_start":7,"line_end":7,"column_start":1,"column_end":17}},{"value":"/     - Futures","span":{"file_name":"src/ch03/mod.rs","byte_start":158172,"byte_end":158189,"line_start":8,"line_end":8,"column_start":1,"column_end":18}},{"value":"/     - 生成器 与 Pin","span":{"file_name":"src/ch03/mod.rs","byte_start":158190,"byte_end":158217,"line_start":9,"line_end":9,"column_start":1,"column_end":20}},{"value":"/     - async/await","span":{"file_name":"src/ch03/mod.rs","byte_start":158218,"byte_end":158239,"line_start":10,"line_end":10,"column_start":1,"column_end":22}},{"value":"/     - 异步运行时介绍：async-std、tokio、bastion、smol","span":{"file_name":"src/ch03/mod.rs","byte_start":158240,"byte_end":158308,"line_start":11,"line_end":11,"column_start":1,"column_end":47}},{"value":"/ ","span":{"file_name":"src/ch03/mod.rs","byte_start":158309,"byte_end":158313,"line_start":12,"line_end":12,"column_start":1,"column_end":5}}]},{"kind":"Mod","id":{"krate":0,"index":81},"span":{"file_name":"src/ch03/s1_io_model.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"s1_io_model","qualname":"::ch03::s1_io_model","value":"src/ch03/s1_io_model.rs","parent":null,"children":[{"krate":0,"index":82},{"krate":0,"index":83},{"krate":0,"index":84},{"krate":0,"index":85},{"krate":0,"index":86}],"decl_id":null,"docs":" 第三章：Rust 异步编程概念","sig":null,"attributes":[{"value":"/ 第三章：Rust 异步编程概念","span":{"file_name":"src/ch03/s1_io_model.rs","byte_start":158429,"byte_end":158468,"line_start":1,"line_end":1,"column_start":1,"column_end":20}},{"value":"/","span":{"file_name":"src/ch03/s1_io_model.rs","byte_start":158469,"byte_end":158472,"line_start":2,"line_end":2,"column_start":1,"column_end":4}},{"value":"/ # 3.1 异步 I/O 模型","span":{"file_name":"src/ch03/s1_io_model.rs","byte_start":158473,"byte_end":158500,"line_start":3,"line_end":3,"column_start":1,"column_end":20}},{"value":"/ ","span":{"file_name":"src/ch03/s1_io_model.rs","byte_start":158501,"byte_end":158505,"line_start":4,"line_end":4,"column_start":1,"column_end":5}},{"value":"/ - 基本概念： 同步/异步、阻塞/非阻塞IO、多路复用、epoll/io_uring","span":{"file_name":"src/ch03/s1_io_model.rs","byte_start":158506,"byte_end":158594,"line_start":5,"line_end":5,"column_start":1,"column_end":47}},{"value":"/ - Reactor/Preactor模型 与 事件抽象","span":{"file_name":"src/ch03/s1_io_model.rs","byte_start":158595,"byte_end":158640,"line_start":6,"line_end":6,"column_start":1,"column_end":32}},{"value":"/ - minimio/mio","span":{"file_name":"src/ch03/s1_io_model.rs","byte_start":158641,"byte_end":158658,"line_start":7,"line_end":7,"column_start":1,"column_end":18}}]},{"kind":"Function","id":{"krate":0,"index":82},"span":{"file_name":"src/ch03/s1_io_model.rs","byte_start":161871,"byte_end":161884,"line_start":93,"line_end":93,"column_start":8,"column_end":21},"name":"basic_concept","qualname":"::ch03::s1_io_model::basic_concept","value":"pub fn basic_concept()","parent":null,"children":[],"decl_id":null,"docs":"    # 异步 I/O 模型","sig":null,"attributes":[{"value":"*\n\n    # 异步 I/O 模型\n\n    ## 基本概念\n\n    - 同步和异步，关注的是消息通信机制。（调用者视角）\n        - 同步，发出一个调用，在没有得到结果之前不返回。\n        - 异步，发出一个调用，在没有得到结果之前返回。\n    - 阻塞和非阻塞，关注的是程序等待调用结果的状态。（被调用者视角）\n        - 阻塞，在调用结果返回之前，线程被挂起。\n        - 非阻塞，在调用结果返回之前，线程不会被挂起。\n    \n    阻塞，与系统调用有关。\n\n\n    ### I/O 模型\n\n    ```text\n                                     +-+ 阻 塞 I/O (BIO)\n                                     |\n                                     +-+ 非 阻 塞 I/O (NIO)\n                                     |\n                  +----+ 同 步 I/O +--+\n                  |                  |\n                  |                  +-+ I/O 多 路 复 用\n                  |                  |\n                  |                  +-+ 信 号 驱 动 I/O\n    I/O 模 型  +---+\n                  |\n                  |\n                  |                  +-+ Linux (AIO)\n                  |                  |         (io_uring)\n                  +----+ 异 步 I/O +--+\n                                     |\n                                     +-+ windows (IOCP)\n\n    ```\n\n    ### 同步阻塞I/O (blocking I/O)\n\n    ```text\n    Application               kernel\n    +---------+            +-----------+  +---+\n    |         |   syscall  | no        |      |\n    |   Read  | +--------> | datagram  |      |\n    | recvfrom|            | ready     |      |\n    |         |            |    +      |      +-+ wait for\n    |         |            |    |      |      +-+ data\n    |         |            |    v      |      |\n    |         |            | datagram  |      |\n    |         |            | ready     |  +---+\n    |         |            |           |\n    |         |            | copy      |  +---+\n    |         |            | datagram  |      |\n    |process  |            |    +      |      +-+ copy data\n    |datagram |   return   |    |      |      +-+ from kernel to user\n    |         | <--------+ |    v      |      |\n    |         |            |  copy     |  +---+\n    |         |            |  complete |\n    +---------+            +-----------+\n    ```\n\n    输入操作两个阶段：\n\n    1. 进程等待内核把数据准备好；这个阶段可以阻塞也可非阻塞，设置socket属性。\n        - 阻塞： recvfrom 阻塞线程直到返回数据就绪的结果。\n        - 非阻塞：立即返回一个错误，轮询直到数据就绪。\n    2. 从内核缓冲区向进程缓冲区复制数据。（一直阻塞）\n\n    异步I/O，recvfrom总是立即返回，两个阶段都由内核完成。\n\n    ### I/O 多路复用（I/O Multiplexing )\n\n    IO多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄。\n\n    支持I/O多路复用的系统调用有 select/pselect/poll/epoll，本质都是 同步 I/O，因为数据拷贝都是阻塞的。\n    通过 select/epoll 来判断数据报是否准备好，即判断可读可写状态。\n\n\n    \n\n */","span":{"file_name":"src/ch03/s1_io_model.rs","byte_start":158661,"byte_end":161863,"line_start":10,"line_end":92,"column_start":1,"column_end":4}}]},{"kind":"Function","id":{"krate":0,"index":83},"span":{"file_name":"src/ch03/s1_io_model.rs","byte_start":165075,"byte_end":165080,"line_start":142,"line_end":142,"column_start":8,"column_end":13},"name":"epoll","qualname":"::ch03::s1_io_model::epoll","value":"pub fn epoll()","parent":null,"children":[],"decl_id":null,"docs":"    ## epoll","sig":null,"attributes":[{"value":"*\n\n    ## epoll\n\n    ```text\n                            +--------------------------------+     +-------------------------+\n                            | epoll_ctl                      |     | epoll_wait              |\n                            |                                |     |                         |\n                            |                                |     |         +----+          |\n                            |                 +---+          |     |         |    |          |\n                            |                 |   |          |     |         |    |          |\n                            |               +-+---+--+       |     |         +--+-+          |\n                            |               |        |       |     |            |            |\n                            |            +--++     +-++      |     |            |            |\n    epoll_create  +---->    |            |   |     |  |      |     |         +--+-+          |\n                            |            +-+-+     +--+      +---->+         |    |          |\n                            |              |                 |event|         |    |          |\n                            |         +----+--+              |     |         +--+-+          |\n                            |         |       |              |     |            |            |\n                            |         ++      |              |     |            |            |\n                            |        +--+   +-+-+            |     |         +--+-+          |\n                            |        |  |   |   |            |     |         |    |          |\n                            |        +--+   +---+            |     |         |    |          |\n                            |                                |     |         +----+          |\n                            |                    红 黑 树     |     |                 链 表    |\n                            +--------------------------------+     +-------------------------+\n\n\n    ```\n\n    - epoll_create(int size) : 内核产生一个epoll实例数据结构，并返回一个epfd\n    - epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)：将被监听的描述符添加到红黑树或从红黑树中删除或者对监听事件进行修改。\n    - epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout): 阻塞等待注册的事件发生，返回事件的数目，并将触发的事件写入events数组中\n\n\n    epoll 两种触发机制：\n\n    - 水平触发机制（LT)。缓冲区只要有数据就触发读写。epoll 默认工作方式。select/poll只支持该方式。\n    - 边缘触发机制（ET)。缓冲区空或满的状态才触发读写。nginx 使用该方式，避免频繁读写。\n\n    惊群问题：\n\n    当多个进程/线程调用epoll_wait时会阻塞等待，当内核触发可读写事件，所有进程/线程都会进行响应，但是实际上只有一个进程/线程真实处理这些事件。\n    Liux 4.5 通过引入 EPOLLEXCLUSIVE 标识来保证一个事件发生时候只有一个线程会被唤醒，以避免多侦听下的惊群问题。\n*/","span":{"file_name":"src/ch03/s1_io_model.rs","byte_start":161892,"byte_end":165067,"line_start":97,"line_end":141,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":84},"span":{"file_name":"src/ch03/s1_io_model.rs","byte_start":167138,"byte_end":167146,"line_start":190,"line_end":190,"column_start":8,"column_end":16},"name":"io_uring","qualname":"::ch03::s1_io_model::io_uring","value":"pub fn io_uring()","parent":null,"children":[],"decl_id":null,"docs":"    ## io_uring 异步 I/O 模型","sig":null,"attributes":[{"value":"*\n    ## io_uring 异步 I/O 模型\n\n    Linux AIO 实现的并不理想，所以引入了新的异步I/O接口 io_uring。\n\n    ```text\n    +----+ Head  +---------+               +----------+ Head\n    |            |         |               |          |\n    |            |         |               |          |\n    |            +---------+               +----------+\n    |            |         |               |          |\n    |            |         |               |          |\n    |            +---------+               +----------+\n    |            |         |               |          |\n    |            |         |               |          |\n    |            +---------+               +----------+\n    |            |         |               |          |\n    |      Tail  +---------+               +----------+ Tail <--+\n    |        +--------------------------------------------+     |\n    |        | Kernel                                     |     |\n    |        |                                            |     |\n    |        |        +-------+              +-------+    |     |\n    |        |        |       |              |       |    |     |\n    +---------------> | SQ    |              |  CQ   | +--------+\n             |        |       |              |       |    |\n             |        +-------+              +-------+    |\n             |                                            |\n             +--------------------------------------------+\n\n    ```\n\n    io_uring接口通过两个主要数据结构工作：\n    \n    - 提交队列条目（sqe）\n    - 完成队列条目（cqe）\n    \n    这些结构的实例位于内核和应用程序之间的**共享内存**单生产者单消费者环形缓冲区中。\n\n    参考：\n    \n    [https://thenewstack.io/how-io_uring-and-ebpf-will-revolutionize-programming-in-linux/](https://thenewstack.io/how-io_uring-and-ebpf-will-revolutionize-programming-in-linux/)\n\n    [https://cor3ntin.github.io/posts/iouring/#io_uring](https://cor3ntin.github.io/posts/iouring/#io_uring)\n\n*/","span":{"file_name":"src/ch03/s1_io_model.rs","byte_start":165087,"byte_end":167130,"line_start":145,"line_end":189,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":85},"span":{"file_name":"src/ch03/s1_io_model.rs","byte_start":170129,"byte_end":170141,"line_start":247,"line_end":247,"column_start":8,"column_end":20},"name":"event_driven","qualname":"::ch03::s1_io_model::event_driven","value":"pub fn event_driven()","parent":null,"children":[],"decl_id":null,"docs":"    ## 事件驱动编程模型","sig":null,"attributes":[{"value":"*\n\n    ## 事件驱动编程模型\n\n    因为处理 I/O 复用的编程模型相当复杂，为了简化编程，引入了下面两种模型。\n\n    - Reactor（反应器） 模式，对应同步I/O，被动的事件分离和分发模型。服务等待请求事件的到来，再通过不受间断的同步处理事件，从而做出反应。\n    - Preactor（主动器） 模式，对应异步I/O，主动的事件分离和分发模型。这种设计允许多个任务并发的执行，从而提高吞吐量；并可执行耗时长的任务（各个任务间互不影响）。\n\n    Reactor Model: \n\n    ```text\n                                                         +----------------+\n    req                                        Dispatch  |                |\n    +------+                                  +--------> | req handler    |\n    |      |                                  |          +----------------+\n    |      | +----+                           |\n    +------+      | event    +------------+   |\n                  |          |            |   |\n                  +--------> |  Service   |   |Dispatch  +----------------+\n                             |  Handler   +------------> |                |\n    req          +---------> |            |   |          | req handler    |\n    +------+     |           +------------+   |          +----------------+\n    |      |     | event                      |\n    |      +----+                             |\n    +------+                                  | Dispatch +----------------+\n                                              +--------->+                |\n                                                         | req handler    |\n                                                         +----------------+\n\n    ```\n\n    三种实现方式：\n\n    - 单线程模式。 accept()、read()、write()以及connect()操作 都在同一线程。\n    - 工作者线程池模式。非 I/O 操作交给线程池处理\n    - 多线程模式。主Reactor (master) ，负责网络监听 ， 子Reactor(worker) 读写网络数据。\n\n    读写操作流程：\n\n    1. 应用注册读写就绪事件和相关联的事件处理器\n    2. 事件分离器等待事件发生\n    3. 当发生读写就绪事件，事件分离器调用已注册的事件处理器\n    4. 事件处理器执行读写操作\n\n    参与者：\n    1. 描述符（handle）：操作系统提供的资源，识别 socket等。\n    2. 同步事件多路分离器。开启事件循环，等待事件的发生。封装了 多路复用函数 select/poll/epoll等。\n    3. 事件处理器。提供回调函数，用于描述与应用程序相关的某个事件的操作。\n    4. 具体的事件处理器。事件处理器接口的具体实现。使用描述符来识别事件和程序提供的服务。\n    5. Reactor 管理器。事件处理器的调度核心。分离每个事件，调度事件管理器，调用具体的函数处理某个事件。\n\n*/","span":{"file_name":"src/ch03/s1_io_model.rs","byte_start":167154,"byte_end":170121,"line_start":194,"line_end":246,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":86},"span":{"file_name":"src/ch03/s1_io_model.rs","byte_start":170597,"byte_end":170609,"line_start":263,"line_end":263,"column_start":8,"column_end":20},"name":"epoll_server","qualname":"::ch03::s1_io_model::epoll_server","value":"pub fn epoll_server()","parent":null,"children":[],"decl_id":null,"docs":"    ## Rust 实现 epoll server 示例讲解","sig":null,"attributes":[{"value":"*\n\n    ## Rust 实现 epoll server 示例讲解\n\n    1. [https://github.com/zupzup/rust-epoll-example/blob/main/src/main.rs](https://github.com/zupzup/rust-epoll-example/blob/main/src/main.rs)\n    2. [Reactor executor Example](https://github.com/zupzup/rust-reactor-executor-example)\n\n    ## 实现跨平台 \n\n    1. [minimio](https://github.com/cfsamson/examples-minimio)\n    2. [mio](https://github.com/tokio-rs/mio) and mio-examples\n\n*/","span":{"file_name":"src/ch03/s1_io_model.rs","byte_start":170148,"byte_end":170589,"line_start":250,"line_end":262,"column_start":1,"column_end":3}}]},{"kind":"Mod","id":{"krate":0,"index":87},"span":{"file_name":"src/ch03/s2_async_await.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"s2_async_await","qualname":"::ch03::s2_async_await","value":"src/ch03/s2_async_await.rs","parent":null,"children":[{"krate":0,"index":88},{"krate":0,"index":89}],"decl_id":null,"docs":" 第三章：Rust 异步编程概念","sig":null,"attributes":[{"value":"/ 第三章：Rust 异步编程概念","span":{"file_name":"src/ch03/s2_async_await.rs","byte_start":170614,"byte_end":170653,"line_start":1,"line_end":1,"column_start":1,"column_end":20}},{"value":"/","span":{"file_name":"src/ch03/s2_async_await.rs","byte_start":170654,"byte_end":170657,"line_start":2,"line_end":2,"column_start":1,"column_end":4}},{"value":"/ # 3.2 异步 编程 模型","span":{"file_name":"src/ch03/s2_async_await.rs","byte_start":170658,"byte_end":170688,"line_start":3,"line_end":3,"column_start":1,"column_end":19}},{"value":"/ ","span":{"file_name":"src/ch03/s2_async_await.rs","byte_start":170689,"byte_end":170693,"line_start":4,"line_end":4,"column_start":1,"column_end":5}},{"value":"/ - Future ","span":{"file_name":"src/ch03/s2_async_await.rs","byte_start":170694,"byte_end":170707,"line_start":5,"line_end":5,"column_start":1,"column_end":14}},{"value":"/ - 生成器 与 协程","span":{"file_name":"src/ch03/s2_async_await.rs","byte_start":170708,"byte_end":170734,"line_start":6,"line_end":6,"column_start":1,"column_end":15}},{"value":"/ - Pin 与 UnPin","span":{"file_name":"src/ch03/s2_async_await.rs","byte_start":170735,"byte_end":170754,"line_start":7,"line_end":7,"column_start":1,"column_end":18}},{"value":"/ - Async/Await","span":{"file_name":"src/ch03/s2_async_await.rs","byte_start":170755,"byte_end":170772,"line_start":8,"line_end":8,"column_start":1,"column_end":18}},{"value":"/ ","span":{"file_name":"src/ch03/s2_async_await.rs","byte_start":170773,"byte_end":170777,"line_start":9,"line_end":9,"column_start":1,"column_end":5}},{"value":"/ ","span":{"file_name":"src/ch03/s2_async_await.rs","byte_start":170778,"byte_end":170782,"line_start":10,"line_end":10,"column_start":1,"column_end":5}}]},{"kind":"Function","id":{"krate":0,"index":88},"span":{"file_name":"src/ch03/s2_async_await.rs","byte_start":171909,"byte_end":171916,"line_start":49,"line_end":49,"column_start":8,"column_end":15},"name":"futures","qualname":"::ch03::s2_async_await::futures","value":"pub fn futures()","parent":null,"children":[],"decl_id":null,"docs":"    # Future 和 Futures-rs\n    \n    - [Future](https://doc.rust-lang.org/std/future/index.html) and [task](https://doc.rust-lang.org/std/task/index.html)\n    - [futures-rs](https://github.com/rust-lang/futures-rs)","sig":null,"attributes":[{"value":"*\n\n    # Future 和 Futures-rs\n    \n    - [Future](https://doc.rust-lang.org/std/future/index.html) and [task](https://doc.rust-lang.org/std/task/index.html)\n    - [futures-rs](https://github.com/rust-lang/futures-rs)\n\n    示例：\n\n    ```rust\n    pub struct SocketRead<'a> {\n        socket: &'a Socket,\n    }\n\n    impl SimpleFuture for SocketRead<'_> {\n        type Output = Vec<u8>;\n\n        fn poll(&mut self, wake: fn()) -> Poll<Self::Output> {\n            if self.socket.has_data_to_read() {\n                // The socket has data-- read it into a buffer and return it.\n                Poll::Ready(self.socket.read_buf())\n            } else {\n                // The socket does not yet have data.\n                //\n                // Arrange for `wake` to be called once data is available.\n                // When data becomes available, `wake` will be called, and the\n                // user of this `Future` will know to call `poll` again and\n                // receive data.\n                self.socket.set_readable_callback(wake);\n                Poll::Pending\n            }\n        }\n    }\n    ```\n\n*/","span":{"file_name":"src/ch03/s2_async_await.rs","byte_start":170784,"byte_end":171900,"line_start":12,"line_end":47,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":89},"span":{"file_name":"src/ch03/s2_async_await.rs","byte_start":172180,"byte_end":172189,"line_start":72,"line_end":72,"column_start":8,"column_end":17},"name":"generator","qualname":"::ch03::s2_async_await::generator","value":"pub fn generator()","parent":null,"children":[],"decl_id":null,"docs":"    # 生成器 与 协程","sig":null,"attributes":[{"value":"*\n\n    # 生成器 与 协程\n\n    ## 历史\n\n    处理异步事件的三种方式：\n    - Callback\n    - Promise\n    - async/await \n\n    async/await 是目前体验最好的方式，Rust 要支持它并不容易。\n\n    ## 生成器\n\n    \n\n*/","span":{"file_name":"src/ch03/s2_async_await.rs","byte_start":171925,"byte_end":172172,"line_start":54,"line_end":71,"column_start":1,"column_end":3}}]},{"kind":"Mod","id":{"krate":0,"index":90},"span":{"file_name":"src/ch03/s3_async_runtime.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"s3_async_runtime","qualname":"::ch03::s3_async_runtime","value":"src/ch03/s3_async_runtime.rs","parent":null,"children":[],"decl_id":null,"docs":" 第三章：Rust 异步编程概念","sig":null,"attributes":[{"value":"/ 第三章：Rust 异步编程概念","span":{"file_name":"src/ch03/s3_async_runtime.rs","byte_start":172194,"byte_end":172233,"line_start":1,"line_end":1,"column_start":1,"column_end":20}},{"value":"/","span":{"file_name":"src/ch03/s3_async_runtime.rs","byte_start":172234,"byte_end":172237,"line_start":2,"line_end":2,"column_start":1,"column_end":4}},{"value":"/ # 3.3 异步 运行时","span":{"file_name":"src/ch03/s3_async_runtime.rs","byte_start":172238,"byte_end":172264,"line_start":3,"line_end":3,"column_start":1,"column_end":17}},{"value":"/ ","span":{"file_name":"src/ch03/s3_async_runtime.rs","byte_start":172265,"byte_end":172269,"line_start":4,"line_end":4,"column_start":1,"column_end":5}},{"value":"/ - [tokio](https://github.com/tokio-rs/tokio)","span":{"file_name":"src/ch03/s3_async_runtime.rs","byte_start":172270,"byte_end":172318,"line_start":5,"line_end":5,"column_start":1,"column_end":49}},{"value":"/ - [async-std](https://github.com/async-rs/async-std)","span":{"file_name":"src/ch03/s3_async_runtime.rs","byte_start":172319,"byte_end":172375,"line_start":6,"line_end":6,"column_start":1,"column_end":57}},{"value":"/ - [smol](https://github.com/smol-rs/smol)","span":{"file_name":"src/ch03/s3_async_runtime.rs","byte_start":172376,"byte_end":172421,"line_start":7,"line_end":7,"column_start":1,"column_end":46}},{"value":"/ - [bastion](https://github.com/bastion-rs/bastion)","span":{"file_name":"src/ch03/s3_async_runtime.rs","byte_start":172422,"byte_end":172476,"line_start":8,"line_end":8,"column_start":1,"column_end":55}},{"value":"/ - [glommio](https://github.com/DataDog/glommio)","span":{"file_name":"src/ch03/s3_async_runtime.rs","byte_start":172477,"byte_end":172528,"line_start":9,"line_end":9,"column_start":1,"column_end":52}},{"value":"/ ","span":{"file_name":"src/ch03/s3_async_runtime.rs","byte_start":172529,"byte_end":172533,"line_start":10,"line_end":10,"column_start":1,"column_end":5}},{"value":"/ 框架剖析：","span":{"file_name":"src/ch03/s3_async_runtime.rs","byte_start":172534,"byte_end":172553,"line_start":11,"line_end":11,"column_start":1,"column_end":10}},{"value":"/ ","span":{"file_name":"src/ch03/s3_async_runtime.rs","byte_start":172554,"byte_end":172558,"line_start":12,"line_end":12,"column_start":1,"column_end":5}},{"value":"/ - [rocket](https://github.com/SergioBenitez/Rocket)","span":{"file_name":"src/ch03/s3_async_runtime.rs","byte_start":172559,"byte_end":172614,"line_start":13,"line_end":13,"column_start":1,"column_end":56}},{"value":"/ - [acitx-web](https://github.com/actix/actix-web)","span":{"file_name":"src/ch03/s3_async_runtime.rs","byte_start":172615,"byte_end":172668,"line_start":14,"line_end":14,"column_start":1,"column_end":54}},{"value":"/ - [tide](https://github.com/http-rs/tide)","span":{"file_name":"src/ch03/s3_async_runtime.rs","byte_start":172669,"byte_end":172714,"line_start":15,"line_end":15,"column_start":1,"column_end":46}},{"value":"/ - [lunatic](https://github.com/lunatic-solutions/lunatic)","span":{"file_name":"src/ch03/s3_async_runtime.rs","byte_start":172715,"byte_end":172776,"line_start":16,"line_end":16,"column_start":1,"column_end":62}}]}],"impls":[],"refs":[{"kind":"Mod","span":{"file_name":"src/lib.rs","byte_start":202,"byte_end":206,"line_start":8,"line_end":8,"column_start":9,"column_end":13},"ref_id":{"krate":0,"index":3}},{"kind":"Mod","span":{"file_name":"src/ch01/mod.rs","byte_start":284,"byte_end":291,"line_start":6,"line_end":6,"column_start":9,"column_end":16},"ref_id":{"krate":0,"index":4}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6935}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6935}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6935}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6935}},{"kind":"Function","span":{"file_name":"src/ch01/lexical.rs","byte_start":3186,"byte_end":3193,"line_start":131,"line_end":131,"column_start":13,"column_end":20},"ref_id":{"krate":2,"index":5683}},{"kind":"Type","span":{"file_name":"src/ch01/lexical.rs","byte_start":3196,"byte_end":3199,"line_start":131,"line_end":131,"column_start":23,"column_end":26},"ref_id":{"krate":5,"index":5370}},{"kind":"Type","span":{"file_name":"src/ch01/lexical.rs","byte_start":3179,"byte_end":3184,"line_start":131,"line_end":131,"column_start":6,"column_end":11},"ref_id":{"krate":2,"index":29003}},{"kind":"Variable","span":{"file_name":"src/ch01/lexical.rs","byte_start":3179,"byte_end":3180,"line_start":131,"line_end":131,"column_start":6,"column_end":7},"ref_id":{"krate":2,"index":29005}},{"kind":"Variable","span":{"file_name":"src/ch01/lexical.rs","byte_start":3182,"byte_end":3184,"line_start":131,"line_end":131,"column_start":9,"column_end":11},"ref_id":{"krate":2,"index":29006}},{"kind":"Function","span":{"file_name":"src/ch01/lexical.rs","byte_start":3222,"byte_end":3235,"line_start":132,"line_end":132,"column_start":16,"column_end":29},"ref_id":{"krate":5,"index":5378}},{"kind":"Type","span":{"file_name":"src/ch01/lexical.rs","byte_start":3211,"byte_end":3214,"line_start":132,"line_end":132,"column_start":5,"column_end":8},"ref_id":{"krate":5,"index":5370}},{"kind":"Mod","span":{"file_name":"src/ch01/mod.rs","byte_start":301,"byte_end":305,"line_start":7,"line_end":7,"column_start":9,"column_end":13},"ref_id":{"krate":0,"index":15}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Mod","span":{"file_name":"src/ch01/mod.rs","byte_start":315,"byte_end":319,"line_start":8,"line_end":8,"column_start":9,"column_end":13},"ref_id":{"krate":0,"index":20}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6935}},{"kind":"Mod","span":{"file_name":"src/lib.rs","byte_start":216,"byte_end":220,"line_start":9,"line_end":9,"column_start":9,"column_end":13},"ref_id":{"krate":0,"index":33}},{"kind":"Mod","span":{"file_name":"src/ch02/mod.rs","byte_start":14850,"byte_end":14862,"line_start":10,"line_end":10,"column_start":9,"column_end":21},"ref_id":{"krate":0,"index":34}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Mod","span":{"file_name":"src/ch02/mod.rs","byte_start":14886,"byte_end":14897,"line_start":12,"line_end":12,"column_start":9,"column_end":20},"ref_id":{"krate":0,"index":42}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Mod","span":{"file_name":"src/ch02/mod.rs","byte_start":14921,"byte_end":14935,"line_start":14,"line_end":14,"column_start":9,"column_end":23},"ref_id":{"krate":0,"index":50}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Mod","span":{"file_name":"src/ch02/mod.rs","byte_start":14959,"byte_end":14970,"line_start":16,"line_end":16,"column_start":9,"column_end":20},"ref_id":{"krate":0,"index":55}},{"kind":"Mod","span":{"file_name":"src/ch02/mod.rs","byte_start":14994,"byte_end":15014,"line_start":18,"line_end":18,"column_start":9,"column_end":29},"ref_id":{"krate":0,"index":57}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Mod","span":{"file_name":"src/ch02/mod.rs","byte_start":15038,"byte_end":15050,"line_start":20,"line_end":20,"column_start":9,"column_end":21},"ref_id":{"krate":0,"index":65}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Mod","span":{"file_name":"src/ch02/mod.rs","byte_start":15074,"byte_end":15089,"line_start":22,"line_end":22,"column_start":9,"column_end":24},"ref_id":{"krate":0,"index":67}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Function","span":{"file_name":"/Users/zhangalex/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":197658,"byte_end":197691,"line_start":112,"line_end":112,"column_start":28,"column_end":61},"ref_id":{"krate":2,"index":6942}},{"kind":"Mod","span":{"file_name":"src/ch02/mod.rs","byte_start":15113,"byte_end":15131,"line_start":24,"line_end":24,"column_start":9,"column_end":27},"ref_id":{"krate":0,"index":71}},{"kind":"Mod","span":{"file_name":"src/ch02/mod.rs","byte_start":15155,"byte_end":15169,"line_start":26,"line_end":26,"column_start":9,"column_end":23},"ref_id":{"krate":0,"index":76}},{"kind":"Mod","span":{"file_name":"src/lib.rs","byte_start":230,"byte_end":234,"line_start":10,"line_end":10,"column_start":9,"column_end":13},"ref_id":{"krate":0,"index":80}},{"kind":"Mod","span":{"file_name":"src/ch03/mod.rs","byte_start":158337,"byte_end":158348,"line_start":15,"line_end":15,"column_start":9,"column_end":20},"ref_id":{"krate":0,"index":81}},{"kind":"Mod","span":{"file_name":"src/ch03/mod.rs","byte_start":158372,"byte_end":158386,"line_start":17,"line_end":17,"column_start":9,"column_end":23},"ref_id":{"krate":0,"index":87}},{"kind":"Mod","span":{"file_name":"src/ch03/mod.rs","byte_start":158410,"byte_end":158426,"line_start":19,"line_end":19,"column_start":9,"column_end":25},"ref_id":{"krate":0,"index":90}}],"macro_refs":[],"relations":[]}